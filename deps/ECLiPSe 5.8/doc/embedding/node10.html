<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Passing generic C or C++ data to ECLiPSe</TITLE>
<META NAME="description" CONTENT="Passing generic C or C++ data to ECLiPSe">
<META NAME="keywords" CONTENT="embroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="embroot.css">
<LINK REL="previous" HREF="node9.html">
<LINK REL="up" HREF="node6.html">
<LINK REL="next" HREF="node11.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html811"
 HREF="node11.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html807"
 HREF="node6.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html803"
 HREF="node9.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html809"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html812"
 HREF="node11.html">External Predicates in C</A>
<B> Up:</B> <A NAME="tex2html808"
 HREF="node6.html">Managing Data and Memory</A>
<B> Previous:</B> <A NAME="tex2html804"
 HREF="node9.html">Referring to ECLiPSe terms</A>
 &nbsp <B>  <A NAME="tex2html810"
 HREF="node76.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html813"
 HREF="node10.html#SECTION00341000000000000000">Wrapping and unwrapping external data in an ECLiPSe term</A>
<LI><A NAME="tex2html814"
 HREF="node10.html#SECTION00342000000000000000">The method table</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00340000000000000000">
Passing generic C or C++ data to ECLiPSe</A>
</H1>

<P>
<A NAME="504"></A>
It is possible to include any C or C++ data in an ECLiPSe term. To do this
it is wrapped into a handle to tell ECLiPSe that this is external data.
You also have to supply a method table, which is a set of functions
that are called when ECLiPSe wants to make common operations that it
assumes can be done on any data (eg. comparing, printing).

<P>

<H2><A NAME="SECTION00341000000000000000">
Wrapping and unwrapping external data in an ECLiPSe term</A>
</H2>

<P>
To create an ECLiPSe wrapper for a C/C++ object,
the function <code>handle()</code> is used. It takes a pointer to any C or C++
data, and a pointer to a suitable method table (<code>t_ext_type</code> structure)
and creates an ECLiPSe handle term which refers to them.
Method tables for the common case of arrays of char, long or double
<A NAME="511"></A>
are predefined. For example a handle for a double array is made like this
<PRE>
    double my_array[5] = {1.1, 2.2, 3.3, 4.4, 5.5};
    EC_word w = handle(&amp;ec_xt_double_arr, my_array);
</PRE>
where <code>ec_xt_double_arr</code> is a predefined method table for arrays of doubles.
To convert back from an ECLiPSe term <code>is_handle()</code> is used.
The method table passed in indicates the sort of data you expect to get.
If the ECLiPSe handle contains the wrong sort, the function returns
TYPE_ERROR:
<PRE>
    if ((EC_succeed == w.is_handle(&amp;ec_xt_double_arr, &amp;obj))
        obj-&gt;my_method();
    else
        cerr &lt;&lt; "unexpected type\n";
</PRE>

<P>

<H2><A NAME="SECTION00342000000000000000"></A>
<A NAME="519"></A>
<BR>
The method table
</H2>
Apart from the predefined method tables ec_xt_double_arr,
ec_xt_long_arr and ec_xt_char_arr, new ones can easily be defined.
The address of the table is used as a type identifier, so when you
get an external object back from ECLiPSe you can check its type
to determine the kinds of operations you can do on it.
You can choose not to implement one or more of these functions, by
leaving a null pointer (<code>(void*)0</code>) in its field.

<P>
<PRE>
    typedef void *t_ext_ptr;

    typedef struct {
        void       (*free)       (t_ext_ptr obj);
        t_ext_ptr  (*copy)       (t_ext_ptr obj);
        void       (*mark_dids)  (t_ext_ptr obj);
        int        (*string_size)(t_ext_ptr obj, int quoted);
        int        (*to_string)  (t_ext_ptr obj, char *buf, int quoted);
        int        (*equal)      (t_ext_ptr obj1, t_ext_ptr obj2);
        t_ext_ptr  (*remote_copy)(t_ext_ptr obj);
        EC_word    (*get)        (t_ext_ptr obj, int idx);
        int        (*set)        (t_ext_ptr obj, int idx, EC_word data);
    } t_ext_type;
</PRE>

<P>
<DL>
<DT><STRONG>free(t_ext_ptr obj)</STRONG>
<DD><A NAME="524"></A>
This is called by ECLiPSe if it loses a reference to the external
data. This could happen if the ECLiPSe execution were to fail
to a point before the external object was created, or if a
permanent copy was explicitly removed with built-ins like
<A NAME="tex2html71"
 HREF="../bips/kernel/arrays/setval-2.html">setval/2</A><A NAME="586"></A>,
<A NAME="tex2html73"
 HREF="../bips/kernel/record/erase-2.html">erase/2</A><A NAME="589"></A>
or <A NAME="tex2html75"
 HREF="../bips/kernel/arrays/bag_dissolve-2.html">bag_dissolve/2</A><A NAME="592"></A>.
Note that an invocation of this function only means that <EM>one</EM>
reference has been deleted (while the copy function indicates that
a reference is added).

<P>
<DT><STRONG>copy(t_ext_ptr obj)</STRONG>
<DD>This is called by ECLiPSe when it wants to make a copy of an object.
This happens when calling ECLiPSe built-ins like <A NAME="tex2html77"
 HREF="../bips/kernel/arrays/setval-2.html">setval/2</A><A NAME="595"></A> or
<A NAME="tex2html79"
 HREF="../bips/kernel/record/recordz-2.html">recordz/2</A><A NAME="598"></A> which make permanent copies of data. The return value is
the copy.
If no copy-method is specified, these operations will not be possible
with terms that contain an object of this type.
A possible implementation is to return a pointer to the original and
e.g. increment a reference counter (and decrement the counter in
the free-method correspondingly).

<P>
<DT><STRONG>mark_dids( t_ext_ptr obj)</STRONG>
<DD>This is called during dictionary garbage collection. If an external
object contains references to the dictionary (<code>dident</code>) then
it needs to mark these as referenced.

<P>
<DT><STRONG>string_size(t_ext_ptr obj, int quoted)</STRONG>
<DD><DT><STRONG>to_string(t_ext_ptr obj,char *buf, int quoted)</STRONG>
<DD>When ECLiPSe wants to print an external object it calls <code>string_size()</code>
to get an estimate of how large the string would be that represents it.
This is used by ECLiPSe to allocate a buffer. The string representation must
be guaranteed to fit in the buffer.

<P>
Finally  the <code>to_string()</code> function is called. This should write the
string representation of the object into the buffer.

<P>
<DT><STRONG>equal(t_ext_ptr obj1, t_ext_ptr obj2)</STRONG>
<DD>This is called when two external objects are unified or compared.
Prolog views the external object as a ground, atomic element.

<P>
<DT><STRONG>remote_copy(t_ext_ptr obj)</STRONG>
<DD>This is called by parallel ECLiPSe when it needs to make a copy of an
object in another worker. If the object is in shared memory, this method
can be the same as the copy method.

<P>
<DT><STRONG>get(t_ext_ptr obj, int idx)</STRONG>
<DD>Returns the value of a field of the C++ object.
This methods gets invoked when the ECLiPSe predicate <A NAME="tex2html81"
 HREF="../bips/kernel/externals/xget-3.html">xget/3</A><A NAME="601"></A> is called.
The mapping of index values to fields is defined by the get/set-method pair.

<P>
<DT><STRONG>set(t_ext_ptr obj, int idx, EC_word data)</STRONG>
<DD>Set the value of a field of the C++ object.
This methods gets invoked when the ECLiPSe predicate <A NAME="tex2html83"
 HREF="../bips/kernel/externals/xset-3.html">xset/3</A><A NAME="604"></A> is called.
The mapping of index values to fields is defined by the get/set-method pair.
</DL>

<P>
Example of the simplest possible user-defined method table:
<PRE>
    t_ext_type my_type = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
    my_struct data_in;
    ...
    // creating a handle for data_in
    EC_word w = handle(&amp;my_type, &amp;data_in);
    ...
    // checking a handle and extracting the data pointer
    my_struct *data_out;
    if ((EC_succeed == w.is_handle(&amp;my_type, &amp;data_out))
        data_out-&gt;my_method();
    else
        cerr &lt;&lt; "unexpected type\n";
</PRE>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html811"
 HREF="node11.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html807"
 HREF="node6.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html803"
 HREF="node9.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html809"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html812"
 HREF="node11.html">External Predicates in C</A>
<B> Up:</B> <A NAME="tex2html808"
 HREF="node6.html">Managing Data and Memory</A>
<B> Previous:</B> <A NAME="tex2html804"
 HREF="node9.html">Referring to ECLiPSe terms</A>
 &nbsp <B>  <A NAME="tex2html810"
 HREF="node76.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
