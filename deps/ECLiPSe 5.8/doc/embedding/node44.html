<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Communicating between Java and ECLiPSe using queues</TITLE>
<META NAME="description" CONTENT="Communicating between Java and ECLiPSe using queues">
<META NAME="keywords" CONTENT="embroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="embroot.css">
<LINK REL="next" HREF="node45.html">
<LINK REL="previous" HREF="node43.html">
<LINK REL="up" HREF="node39.html">
<LINK REL="next" HREF="node45.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html1380"
 HREF="node45.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1376"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1370"
 HREF="node43.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1378"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1381"
 HREF="node45.html">Managing connections to ECLiPSe</A>
<B> Up:</B> <A NAME="tex2html1377"
 HREF="node39.html">Using the Java-ECLiPSe Interface</A>
<B> Previous:</B> <A NAME="tex2html1371"
 HREF="node43.html">Executing an ECLiPSe goal</A>
 &nbsp <B>  <A NAME="tex2html1379"
 HREF="node76.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html1382"
 HREF="node44.html#SECTION00851000000000000000">Opening, using and closing queues</A>
<UL>
<LI><A NAME="tex2html1383"
 HREF="node44.html#SECTION00851100000000000000">Opening a queue using Java methods</A>
</UL>
<LI><A NAME="tex2html1384"
 HREF="node44.html#SECTION00852000000000000000">Opening a queue using ECLiPSe predicates</A>
<UL>
<LI><A NAME="tex2html1385"
 HREF="node44.html#SECTION00852100000000000000">Transferring data using Java methods</A>
<LI><A NAME="tex2html1386"
 HREF="node44.html#SECTION00852200000000000000">Transferring data using ECLiPSe predicates</A>
<LI><A NAME="tex2html1387"
 HREF="node44.html#SECTION00852300000000000000">Note: <B>always</B> flush</A>
<LI><A NAME="tex2html1388"
 HREF="node44.html#SECTION00852400000000000000">Closing a queue using Java methods</A>
<LI><A NAME="tex2html1389"
 HREF="node44.html#SECTION00852500000000000000">Closing a queue using ECLiPSe predicates</A>
</UL>
<LI><A NAME="tex2html1390"
 HREF="node44.html#SECTION00853000000000000000">Writing and reading ECLiPSe terms on queues</A>
<UL>
<LI><A NAME="tex2html1391"
 HREF="node44.html#SECTION00853100000000000000">Initialising <I>EXDRInputStream</I> and <I>EXDROutputStream</I></A>
<LI><A NAME="tex2html1392"
 HREF="node44.html#SECTION00853200000000000000"><I>EXDRInputStream</I> and <I>EXDROutputStream</I> at work</A>
</UL>
<LI><A NAME="tex2html1393"
 HREF="node44.html#SECTION00854000000000000000">Using the <I>QueueListener</I> interface</A>
<LI><A NAME="tex2html1394"
 HREF="node44.html#SECTION00855000000000000000">Access to ECLiPSe's standard streams</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00850000000000000000"></A><A NAME="4019"></A> 
<A NAME="sec:ji-using-queue-streams"></A>
<BR>
Communicating between Java and ECLiPSe using queues
</H1>

<P>
In the Java-ECLiPSe Interface, <I>queues</I> are one-way data
streams used for communication between ECLiPSe and Java. These are
represented on the ECLiPSe side using ``peer queues'', which are 
I/O streams. The Java-ECLiPSe Interface includes the classes <I>FromEclipseQueue</I> and <I>ToEclipseQueue</I> which represent these
queues on the Java side. <I>FromEclipseQueue</I> represents a queue
which can be written to in ECLiPSe and read from in Java. A <I>ToEclipseQueue</I> is a queue which can be written to in Java and read
from in ECLiPSe.

<P>
Section <A HREF="node44.html#sec:ji-open-close">8.5.1</A> discusses how queues are opened,
<A NAME="4033"></A>referenced and closed<A NAME="4034"></A> from either the Java 
or ECLiPSe sides. We also discuss here how to transfer byte data in both
directions. However, the programmer need not be concerned with low-level
data operations on queues: whole terms can be written and read using the
<I>EXDRInputStream</I> and <I>EXDROutputStream</I> classes discussed in
Section
<A HREF="node44.html#sec:ji-formatting-queue-data">8.5.2</A>.

<P>
Via the <I>QueueListener</I> feature<A NAME="4040"></A>, Java
code can be invoked (in a sense) from within ECLiPSe. The use of this
feature is discussed in Section <A HREF="node44.html#sec:ji-queue-listeners">8.5.3</A>. In some
cases, the standard streams (<TT>stdin</TT>, <TT>stdout</TT> and <TT>stderr</TT>) of
the ECLiPSe engine will be visible to Java as queues. How to use these
is discussed in Section <A HREF="node44.html#sec:ji-standard-streams">8.5.4</A>.

<P>

<H2><A NAME="SECTION00851000000000000000"></A><A NAME="4048"></A>
<A NAME="sec:ji-open-close"></A><A NAME="4050"></A>
<A NAME="4051"></A>
<BR>
Opening, using and closing queues
</H2>
We now explain the standard sequence of events for using
queues. Opening and closing, can be performed in a single step from
either the Java or the ECLiPSe side.

<P>

<H3><A NAME="SECTION00851100000000000000">
Opening a queue using Java methods</A>
</H3>

<P>
<I>FromEclipseQueue</I> and <I>ToEclipseQueue</I> do not have public
constructors. Instead, we invoke <TT>getFromEclipseQueue</TT> or <TT>getToEclipseQueue</TT>. This asks the <I>EclipseConnection</I> object for a
reference to a <I>FromEclipseQueue</I> or <I>ToEclipseQueue</I> instance
which represents a new queue. To specify the stream for later
reference, we supply the method with a string which will equal to the
atom by which the queue is referred to as a stream in ECLiPSe. For
example the following code creates two queues<A NAME="4062"></A>, one in each direction:
<PRE>
...
  ToEclipseQueue java_to_eclipse = 
    eclipse.getToEclipseQueue("java_to_eclipse");
  FromEclipseQueue eclipse_to_java = 
    eclipse.getFromEclipseQueue("eclipse_to_java");
...
</PRE>
These methods will create and return new <I>FromEclipseQueue</I> or
<I>ToEclipseQueue</I> objects, and will also open streams with the
specified names on the ECLiPSe side. No stream in ECLiPSe should
exist with the specified name. If a stream exists which has this name
and is not a queue between the Java object and ECLiPSe, the Java
method throws an exception. If the name is used by a pre-existing
queue, it is returned, so the <TT>getFromEclipseQueue</TT> and <TT>getToEclipseQueue</TT> methods can also be used to retrieve the queue
objects by name once if they have already been created.

<P>

<H2><A NAME="SECTION00852000000000000000"></A>
<A NAME="4073"></A>
<BR>
Opening a queue using ECLiPSe predicates
</H2>
You can use the ECLiPSe builtin <A NAME="tex2html280"
 HREF="../bips/kernel/externals/peer_queue_create-5.html">peer_queue_create/5</A><A NAME="4859"></A> to open a
queue. Used correctly, these have the same effect as the Java methods
explained above. For the peer name, you should use the atom returned
by the <TT>getPeerName()</TT> method of the relevant <I>EclipseConnection</I> instance. The direction should be <TT>fromec</TT> for
a <I>FromEclipseQueue</I> and <TT>toec</TT> for a <I>ToEclipseQueue</I>. The queue type should always be <TT>sync</TT> when using
the Java-ECLiPSe interface: asynchronous queues<A NAME="4085"></A> are not supported.

<P>

<H3><A NAME="SECTION00852100000000000000">
Transferring data using Java methods</A>
</H3>

<P>
On the Java side, once a <I>FromEclipseQueue</I> has been established,
you can treat it as you would any instance of <I>java.io.InputStream</I>, of which <I>FromEclipseQueue</I> is a
subclass. Similarly, <I>ToEclipseQueue</I> is a subclass of <I>java.io.OutputStream</I>. The only visible difference is that <I>FromEclipseQueue</I> and <I>ToEclipseQueue</I> instances may have <I>QueueListeners</I> attached, as is discussed in Section
<A HREF="node44.html#sec:ji-queue-listeners"
 NAME="4096">8.5.3</A>. 

<P>

<H3><A NAME="SECTION00852200000000000000">
Transferring data using ECLiPSe predicates</A>
</H3>

<P>
On the ECLiPSe side, there are built-in predicates for writing to,
reading from and otherwise interacting with streams. Any of these may
be used. Perhaps most useful are <A NAME="tex2html284"
 HREF="../bips/kernel/ioterm/read_exdr-2.html">read_exdr/2</A><A NAME="4862"></A> and <A NAME="tex2html286"
 HREF="../bips/kernel/ioterm/write_exdr-2.html">write_exdr/2</A><A NAME="4865"></A>; these are explained in Section
<A HREF="node44.html#sec:ji-formatting-queue-data"
 NAME="4104">8.5.2</A>. For the stream ID, you may either use the stream name, or the stream number, obtained for example using <A NAME="tex2html289"
 HREF="../bips/kernel/externals/peer_get_property-3.html">peer_get_property/3</A><A NAME="4868"></A>.

<P>

<H3><A NAME="SECTION00852300000000000000">
Note: <B>always</B> flush</A>
</H3>

<P>
When communicating between Java and ECLiPSe using queues<A NAME="4109"></A>, you
should always invoke the <TT>flush()</TT> method of the Java <I>OutputStream</I> which you have written to, whether it be a <I>ToEclipseQueue</I> or an <I>EXDROutputStream</I>. Similarly, on the
ECLiPSe side, <TT>flush/1</TT> should always be executed after
writing. Although in some cases reading of the data is possible
without a flush, flushing guarantees the transfer of data.

<P>

<H3><A NAME="SECTION00852400000000000000">
Closing a queue using Java methods</A>
</H3>

<P>
This is done simply by calling the <TT>close()</TT><A NAME="4118"></A> method on the <I>FromEclipseQueue</I> or <I>ToEclipseQueue</I> instance.

<P>

<H3><A NAME="SECTION00852500000000000000"></A>
<A NAME="4122"></A>
<BR>
Closing a queue using ECLiPSe predicates
</H3>
This is done by executing the builtin <A NAME="tex2html294"
 HREF="../bips/kernel/externals/peer_queue_close-1.html">peer_queue_close/1</A><A NAME="4871"></A>. Note
that the builtin <TT>close/1</TT> should not be used in this situation,
as it will not terminate the Java end of the queue.

<P>

<H2><A NAME="SECTION00853000000000000000"></A><A NAME="4127"></A>
<A NAME="sec:ji-formatting-queue-data"></A>
<BR>
Writing and reading ECLiPSe terms on queues
</H2>
Rather than dealing with low-level data I/O instructions such as reading
and writing bytes, the Java-ECLiPSe Interface provides classes for
reading and writing whole terms. In the underlying implementation of these
classes, the EXDR (ECLiPSe eXternal Data Representation) format is
used<A NAME="4131"></A>. This allows ECLiPSe to communicate with other
languages using a common data type. However, it is not necessary for the
API user to know about EXDR in detail to use the Java-ECLiPSe Interface
features discussed in this section.

<P>
<I>EXDRInputStream</I> is a subclass of <I>java.io.DataInputStream</I> which can read EXDR format. <I>EXDROutputStream</I> is a subclass of <I>java.io.FilterOutputStream</I> which can write EXDR format.

<P>

<H3><A NAME="SECTION00853100000000000000"></A>
<A NAME="4140"></A>
<BR>
Initialising <I>EXDRInputStream</I> and <I>EXDROutputStream</I>
</H3>
The constructor for <I>EXDRInputStream</I> takes an instance of <I>java.io.InputStream</I> as a parameter. This parameter stream is the
source of the EXDR data for the new stream. If data has been written
to the <I>InputStream</I> in EXDR format, you can access it by invoking
the <TT>readTerm</TT> method of the new <I>EXDRInputStream</I>. This
will read the data from the <I>InputStream</I> and translate the EXDR
format into the Java representation of the data, which is then
returned by <TT>readTerm</TT>.

<P>
Similarly, the constructor for <I>EXDROutputStream</I> takes an
instance of <I>java.io.OutputStream</I> as a parameter. This parameter
stream is the destination of the data written to the new stream. You
write data by invoking the <TT>write</TT> method of the stream. The
parameter of this method is a Java object representing the piece of
data to be written. The class of this object can be any of the Java
classes mentioned in Table <A HREF="#tab:ec-java-data">8.1</A>. The object gets
translated into EXDR format and this is written to the destination
<I>OutputStream</I>.

<P>

<H3><A NAME="SECTION00853200000000000000"></A>
<A NAME="4155"></A>
<BR>
<I>EXDRInputStream</I> and <I>EXDROutputStream</I> at work
</H3>
Although the underlying stream could be any kind of stream (e.g. a
file stream), the most common use of <I>EXDRInputStream</I> and <I>EXDROutputStream</I> is to read data from and write data to queues<A NAME="4158"></A> in
EXDR format. In other words, we usually wrap these classes around <I>FromEclipseQueue</I> and <I>ToEclipseQueue</I> classes. We now look at an
example which does just this.

<P>
The example is in these two files: 
<BLOCKQUOTE>
<A NAME="tex2html300"
 HREF="../examples/JavaInterface/QueueExample1.java"><TT>&lt;eclipse_dir&gt;/doc/examples/JavaInterface/QueueExample1.java</TT></A>
<BR>
<A NAME="tex2html301"
 HREF="../examples/JavaInterface/queue_example_1.pl"><TT>&lt;eclipse_dir&gt;/doc/examples/JavaInterface/queue_example_1.pl</TT></A>

</BLOCKQUOTE>
The Java program's first relevant action is to invoke the <TT>compile</TT> method of the <I>EclipseEngine</I>. This causes the ECLiPSe
program to be loaded by ECLiPSe engine. After <TT>compile</TT>
completes, the Java program creates a <I>ToEclipseQueue</I> and a <I>FromEclipseQueue</I>, with the following lines:
<PRE>
    // Create the two queues
    java_to_eclipse = eclipse.getToEclipseQueue("java_to_eclipse");
    eclipse_to_java = eclipse.getFromEclipseQueue("eclipse_to_java");
</PRE>
Then in the next two lines we create an <I>EXDROutputStream</I> to
format data going to <TT>java_to_eclipse</TT> and an <I>EXDRInputStream</I> to format data coming from <TT>eclipse_to_java</TT>.
<PRE>
    // Set up the two formatting streams
    java_to_eclipse_formatted = new EXDROutputStream(java_to_eclipse);
    eclipse_to_java_formatted = new EXDRInputStream(eclipse_to_java);
</PRE>
The Java program writes two atoms to <TT>java_to_eclipse_formatted</TT>, and then flushes the stream. This
causes each atom to be translated into EXDR format and the translation
to then be written on to <TT>java_to_eclipse</TT>. The Java program then
makes an <TT>rpc</TT><A NAME="4187"></A> invocation to the ECLiPSe program's only predicate
<TT>read_2_write_1/0</TT>, which is defined as follows:
<PRE>
read_2_write_1:-
        read_exdr(java_to_eclipse, Term1),
        read_exdr(java_to_eclipse, Term2),
        write_exdr(eclipse_to_java, pair(Term1, Term2)),
        flush(eclipse_to_java).
</PRE>
The built-in <A NAME="tex2html304"
 HREF="../bips/kernel/ioterm/read_exdr-2.html">read_exdr/2</A><A NAME="4876"></A> reads a term's worth of data from the
stream supplied and instantiates it to the second argument. So <TT>read_2_write_1/0</TT> reads the two terms from the stream. They are
then written on to the <TT>eclipse_to_java</TT> stream within a <TT>pair(...)</TT> functor using the built-in <A NAME="tex2html306"
 HREF="../bips/kernel/ioterm/write_exdr-2.html">write_exdr/2</A><A NAME="4879"></A>, and the
stream is flushed. When the predicate succeeds, the <TT>rpc</TT><A NAME="4200"></A> invocation
returns and the term data is on <TT>eclipse_to_java</TT> in EXDR
format. The next step of the java program is the following:
<PRE>
    System.out.println(eclipse_to_java_formatted.readTerm());
</PRE>
Since <TT>eclipse_to_java</TT> was the <I>FromEclipseQueue</I> passed as a
parameter when <TT>eclipse_to_java_formatted</TT> was initialised, the
<TT>readTerm</TT> method of this object reads the EXDR data which is on
<TT>eclipse_to_java</TT> and converts it into the appropriate Object to
represent the piece of data, in this case a <TT>CompoundTerm</TT>. This Object is
then returned by <TT>readTerm</TT>. Hence the output of the program is
<TT>pair(a,b)</TT>.

<P>

<H2><A NAME="SECTION00854000000000000000"></A>
<A NAME="sec:ji-queue-listeners"></A><A NAME="4214"></A>
<BR>
Using the <I>QueueListener</I> interface
</H2>
It may sometimes be useful to have Java react automatically to data
arriving on a queue from ECLiPSe. An example of this would
be where a Java program has a graphical display monitoring the state
of search in ECLiPSe. We would like ECLiPSe to be able to send a
message along a queue every time an element of the search state
updates, and have Java react with some appropriate graphical action
according to the message.

<P>
Similarly, ECLiPSe may require information from a Java database at
some point during its operation. Again we could use a queue to
transfer this information. If ECLiPSe tries to read from this queue
when it is empty, we would like Java to step in and supply the next
piece of data. 

<P>
The <I>QueueListener</I> interface is the means by which handlers are
attached to queues<A NAME="4221"></A> on the Java side so that Java reacts
automatically to ECLiPSe's interaction with the queue.

<P>
Any object which implements the <I>QueueListener</I> interface can be
attached to either a <I>FromEclipseQueue</I> or a <I>ToEclipseQueue</I>, using
the <TT>setListener</TT> method. The <I>QueueListener</I> can be removed
using <TT>removeListener</TT>. Queues<A NAME="4229"></A> can only have one Java
listener at any one time. 

<P>
The <I>QueueListener</I> interface has two methods: <TT>dataAvailable</TT>
and <TT>dataRequest</TT>. 

<P>
<DL>
<DT><STRONG><TT>dataAvailable</TT></STRONG>
<DD>is invoked only if the <I>QueueListener</I> is 
  attached to a <I>FromEclipseQueue</I>. It is invoked when the queue is 
  flushed on the ECLiPSe side.
<DT><STRONG><TT>dataRequest</TT></STRONG>
<DD>is invoked only if the <I>QueueListener</I> is 
  attached to a <I>ToEclipseQueue</I>. It is invoked when ECLiPSe tries
  to read from the queue when it is empty<A NAME="tex2html310"
 HREF="footnode.html#foot4803"><SUP>8.1</SUP></A>.
</DL>

<P>
Both methods have a single <I>Object</I> parameter named <TT>source</TT>. When they are invoked this parameter is the <I>FromEclipseQueue</I>
or <I>ToEclipseQueue</I> on which the flush or read happened.

<P>
There is an example Java program <TT>QueueExample2.java</TT> with an
accompanying example ECLiPSe program <TT>queue_example_2.pl</TT>
which use <I>QueueListeners</I> attached to queues going in both
directions.
<BLOCKQUOTE>
<A NAME="tex2html311"
 HREF="../examples/JavaInterface/QueueExample2.java"><TT>&lt;eclipse_dir&gt;/doc/examples/JavaInterface/QueueExample2.java</TT></A>
<BR>
<A NAME="tex2html312"
 HREF="../examples/JavaInterface/queue_example_2.pl"><TT>&lt;eclipse_dir&gt;/doc/examples/JavaInterface/queue_example_2.pl</TT></A>

</BLOCKQUOTE>
After the queues streams are set up on both sides, the Java program
attaches as listeners a <I>TermProducer</I> to the <I>ToEclipseQueue</I>
and a <I>TermConsumer</I> to the <I>FromEclipseQueue</I>. These are both
locally defined classes which implement <I>QueueListener</I>. The <I>TermProducer</I>, each time its <TT>dataRequest</TT> method is invoked, sends
one of five different atoms down its queue in EXDR format<A NAME="4269"></A>. The
<I>TermConsumer</I>, when its <TT>dataAvailable</TT> method is invoked,
reads some EXDR data from its queue and translates it into the
appropriate Java object. It then writes this object out to stdout.

<P>
Next, the Java program, using <TT>rpc</TT><A NAME="4273"></A>, executes the only predicate
in the ECLiPSe program: <TT>read_5_write_5/0</TT>. This repeats the
following operation five times: read in a term in EXDR format from the
relevant incoming stream, write it out in EXDR format with an
extra functor to the relevant outgoing stream, and flush the
outgoing stream.

<P>

<H2><A NAME="SECTION00855000000000000000"></A>
<A NAME="sec:ji-standard-streams"></A>
<BR>
Access to ECLiPSe's standard streams
</H2>
If the object representing the ECLiPSe implements the <I>EclipseEngine</I> <A NAME="4280"></A> interface, then the API user
may have access to the ECLiPSe's standard streams (see Section
<A HREF="node45.html#sec:ji-use-queues-flag">8.6.2</A>). These are returned as <I>FromEclipseQueue</I>s and <I>ToEclipseQueue</I>s by the methods <TT>getEclipseStdin</TT>, <TT>getEclipseStdout</TT> and <TT>getEclipseStderr</TT>.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html1380"
 HREF="node45.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1376"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1370"
 HREF="node43.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1378"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1381"
 HREF="node45.html">Managing connections to ECLiPSe</A>
<B> Up:</B> <A NAME="tex2html1377"
 HREF="node39.html">Using the Java-ECLiPSe Interface</A>
<B> Previous:</B> <A NAME="tex2html1371"
 HREF="node43.html">Executing an ECLiPSe goal</A>
 &nbsp <B>  <A NAME="tex2html1379"
 HREF="node76.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
