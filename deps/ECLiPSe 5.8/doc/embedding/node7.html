<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Constructing ECLiPSe data</TITLE>
<META NAME="description" CONTENT="Constructing ECLiPSe data">
<META NAME="keywords" CONTENT="embroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="embroot.css">
<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="node6.html">
<LINK REL="next" HREF="node8.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html770"
 HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html766"
 HREF="node6.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html760"
 HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html768"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html771"
 HREF="node8.html">Converting ECLiPSe data to</A>
<B> Up:</B> <A NAME="tex2html767"
 HREF="node6.html">Managing Data and Memory</A>
<B> Previous:</B> <A NAME="tex2html761"
 HREF="node6.html">Managing Data and Memory</A>
 &nbsp <B>  <A NAME="tex2html769"
 HREF="node76.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html772"
 HREF="node7.html#SECTION00311000000000000000">ECLiPSe atoms and functors</A>
<LI><A NAME="tex2html773"
 HREF="node7.html#SECTION00312000000000000000">Building ECLiPSe terms</A>
<LI><A NAME="tex2html774"
 HREF="node7.html#SECTION00313000000000000000">Building atomic ECLiPSe terms</A>
<LI><A NAME="tex2html775"
 HREF="node7.html#SECTION00314000000000000000">Building ECLiPSe lists</A>
<LI><A NAME="tex2html776"
 HREF="node7.html#SECTION00315000000000000000">Building ECLiPSe structures</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00310000000000000000">
Constructing ECLiPSe data</A>
</H1>

<H2><A NAME="SECTION00311000000000000000">
ECLiPSe atoms and functors</A>
</H2>

<P>
<A NAME="436"></A>
<A NAME="437"></A>
<A NAME="438"></A>
<PRE>
    /* ECLiPSe code */
    S = book("Gulliver's Tales","Swift",hardback,fiction),
</PRE>

<P>
In the above structure 'hardback' and 'fiction' are atoms. 'book'
is the functor of that structure, and it has an arity (number
of arguments) of 4.

<P>
Each functor and atom is entered into a dictionary, and is always
referred to by its dictionary entry. Two classes, <code>EC_atom</code>
and <code>EC_functor</code> are used to access such dictionary entries.

<P>
The 'Name' method applies to both, to get their string form.
The 'Arity' method can be used to find out how many arguments
a functor has.

<P>
<PRE>
    /* C++ code */
    EC_functor book("book",4);
    EC_atom hardback("hardback");

    if (book.Arity()) == 4) .. /* evaluates to true */
    if (book == hardback) ..   /* evaluates to false */
    s = hardback.Name();       /* like s = "hardback"; */
</PRE>

<P>

<H2><A NAME="SECTION00312000000000000000">
Building ECLiPSe terms</A>
</H2>

<P>
<A NAME="444"></A>
<A NAME="445"></A>
<A NAME="446"></A>
The <code>pword</code> C data type is used to store ECLiPSe terms. In C++ the
<code>EC_word</code> data type is used. This is used for any C type as well
as for ECLiPSe structures and lists. The size remains fixed in all
cases, since large terms are constructed on the ECLiPSe global stack.

<P>
<A NAME="450"></A>
The consequences of this are that terms will be garbage collected
or moved so terms do not survive the execution of ECLiPSe. In
particular, one cannot build such terms asynchronously while
ECLiPSe is running, for example this precludes building terms from
within a signal handler unless it can make sure that ECLiPSe has
yielded when it is running.

<P>

<H2><A NAME="SECTION00313000000000000000">
Building atomic ECLiPSe terms</A>
</H2>
It is possible to simply cast from a number of simple C++ types to
build an <code>EC_word</code> In addition, functions exist for creating
<A NAME="455"></A>
new variables, and for the nil which terminates ECLiPSe lists.
In C++ you can just cast.
<PRE>
    /* making simple terms in C++ */
    EC_word w;
    EC_atom hardback("hardback");
    w = (EC_word) "Swift";
    w = (EC_word) hardback;
    w = (EC_word) 1.002e-7;
    w = (EC_word) 12345;
    w = (EC_word) nil();
    w = (EC_word) newvar();

    /* ECLiPSe equivalent code */
    P1 = "Swift",
    P2 = hardback,
    P3 = 1.002e-7,
    P4 = 12345,
    P5 = [],
    P6 = _,
</PRE>

<P>

<H2><A NAME="SECTION00314000000000000000"></A>
<A NAME="460"></A>
<BR>
Building ECLiPSe lists
</H2>
The <code>list(head,tail)</code> function builds a list out of two terms. Well
formed lists have lists as their tail term and a nil ("[]") at the end, or a
variable at the end for difference lists.

<P>
<PRE>
    /* making the list [1, "b", 3.0] in C++ */
    EC_word w = list(1, list("b", list(3.0, nil())));
</PRE>

<P>
The following example shows how you can write functions to build
variable length lists.

<P>
<PRE>
/* function to build a list [n,n+1,n+2,.....,m-1,m] */
EC_word fromto(int n, int m)
{
    EC_word tail = nil();
    for(int i = m ; i &gt;= n ; i--)
        tail = list(i,tail);
    return tail;
}
</PRE>

<P>
The list is constructed starting from the end, so at all points during its
construction you have a valid term. The interface is designed to
make it hard to construct terms with uninitialised sub-terms, which is
what you would need if you were to construct the list starting with
the first elements.

<P>

<H2><A NAME="SECTION00315000000000000000"></A>
<A NAME="466"></A>
<A NAME="467"></A>
<A NAME="468"></A>
<BR>
Building ECLiPSe structures
</H2>
The 
structures. A number of different functions each with a different
number of arguments is defined so as not to disable C++ casting
which would be the case if we defined a function with variable
arguments.

<P>
<PRE>
    /* making s(1,2,3) in C++ */
    EC_functor s_3("s",3);
    EC_word w = term(s_3,1,2,3);
</PRE>

<P>
The above interface is convenient for terms with small fixed arities,
for much larger terms an array based interface is provided.

<P>
<PRE>
    /* making s(1,2,..,n-1,n) */
    EC_word args[n];
    for(int i=0 ; i&lt;n ; i++)
        args[i] = i+1;
    EC_word w = term(EC_functor("s",n),args);
</PRE>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html770"
 HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html766"
 HREF="node6.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html760"
 HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html768"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html771"
 HREF="node8.html">Converting ECLiPSe data to</A>
<B> Up:</B> <A NAME="tex2html767"
 HREF="node6.html">Managing Data and Memory</A>
<B> Previous:</B> <A NAME="tex2html761"
 HREF="node6.html">Managing Data and Memory</A>
 &nbsp <B>  <A NAME="tex2html769"
 HREF="node76.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
