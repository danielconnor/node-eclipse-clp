<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Java representation of ECLiPSe data</TITLE>
<META NAME="description" CONTENT="Java representation of ECLiPSe data">
<META NAME="keywords" CONTENT="embroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="embroot.css">
<LINK REL="next" HREF="node43.html">
<LINK REL="previous" HREF="node41.html">
<LINK REL="up" HREF="node39.html">
<LINK REL="next" HREF="node43.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html1340"
 HREF="node43.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1336"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1330"
 HREF="node41.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1338"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1341"
 HREF="node43.html">Executing an ECLiPSe goal</A>
<B> Up:</B> <A NAME="tex2html1337"
 HREF="node39.html">Using the Java-ECLiPSe Interface</A>
<B> Previous:</B> <A NAME="tex2html1331"
 HREF="node41.html">Functionality overview: A closer</A>
 &nbsp <B>  <A NAME="tex2html1339"
 HREF="node76.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html1342"
 HREF="node42.html#SECTION00831000000000000000">General correspondence between ECLiPSe and Java data types</A>
<LI><A NAME="tex2html1343"
 HREF="node42.html#SECTION00832000000000000000">Atoms and compound terms</A>
<LI><A NAME="tex2html1344"
 HREF="node42.html#SECTION00833000000000000000">Lists</A>
<LI><A NAME="tex2html1345"
 HREF="node42.html#SECTION00834000000000000000">Floats and Doubles</A>
<LI><A NAME="tex2html1346"
 HREF="node42.html#SECTION00835000000000000000">Integers</A>
<LI><A NAME="tex2html1347"
 HREF="node42.html#SECTION00836000000000000000">Variables</A>
<LI><A NAME="tex2html1348"
 HREF="node42.html#SECTION00837000000000000000">The <TT>equals()</TT> method</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00830000000000000000"></A>
<A NAME="sec:ji-terms-in-java"></A>
<BR>
Java representation of ECLiPSe data
</H1>
<A NAME="4776"></A>
The Java-ECLiPSe Interface uses a set of conventions and Java classes so that data
types common in ECLiPSe can be represented. Representing ECLiPSe data types is useful for:

<UL><LI>Constructing compound goals to be sent to ECLiPSe for execution.

<LI>Deconstructing the results of ECLiPSe's computation, which are returned as a compound goal.

<LI>Communicating compound terms and other data via queues<A NAME="3738"></A>. 

</UL>
More details on these tasks will be provided in Sections
<A HREF="node43.html#sec:ji-calling-goals">8.4</A> and <A HREF="node44.html#sec:ji-using-queue-streams">8.5</A>, but it is first necessary to understand how ECLiPSe data is represented in Java.

<P>

<H2><A NAME="SECTION00831000000000000000"></A>
<A NAME="sec:ji-type-correspondence"></A>
<BR>
General correspondence between ECLiPSe and Java data types
</H2>
Not all ECLiPSe data types are represented: for example, at present
the ECLiPSe type <TT>rational</TT> has no Java equivalent. However, all
the most useful ECLiPSe types have a corresponding Java class.  Table
<A HREF="#tab:ec-java-data">8.1</A> gives the general correspondence between those
ECLiPSe data types which are supported and the Java classes or
interfaces which are used to represent them. The ECLiPSe types/Java
classes which appear in the table are those which map to or from 
the ECLiPSe external data representation (EXDR)<A NAME="3753"></A> definition.

<P>
<BR>
<DIV ALIGN="CENTER"><A NAME="4778"></A>
<TABLE>
<CAPTION><STRONG>Table:</STRONG>
The correspondence between ECLiPSe and Java data types. The Java classes are within the <TT> com.parctechnologies.eclipse</TT> package unless otherwise specified.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT">ECLiPSe data type</TD>
<TD ALIGN="LEFT">Java class/interface</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> atom</TT></TD>
<TD ALIGN="LEFT"><I> Atom</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> compound</TT></TD>
<TD ALIGN="LEFT"><I> CompoundTerm</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> integer</TT></TD>
<TD ALIGN="LEFT"><I> java.lang.Integer</I></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><I> java.lang.Long</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> list</TT></TD>
<TD ALIGN="LEFT"><I> java.util.Collection</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> float</TT></TD>
<TD ALIGN="LEFT"><I> java.lang.Double</I></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><I> java.lang.Float</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> string</TT></TD>
<TD ALIGN="LEFT"><I> java.lang.String</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT> variable</TT></TD>
<TD ALIGN="LEFT"><I> null</I></TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV>
<BR>

<P>
The general rule is that you can send data to ECLiPSe by passing
the relevant method an instance of the Java class corresponding to the
ECLiPSe data type you want on the ECLiPSe side. When data comes
back from ECLiPSe it will be an instance of <I>java.lang.Object</I>
but this can be cast to the relevant Java class, which must either be
known beforehand or determined e.g. using the <TT>getClass()</TT> method.

<P>
There are also a number of peculiarities for certain cases which we
now explain.

<P>

<H2><A NAME="SECTION00832000000000000000"></A>
<A NAME="sec:ji-atoms-and-terms"></A>
<BR>
Atoms and compound terms
</H2>
Atoms are simple: these are constructed in Java using the constructor
of the <I>Atom</I> class: the string parameter of the constructor
becomes the atom symbol. Although the Java interface <I>CompoundTerm</I> is
listed above, compound terms (except lists) are usually constructed
using the <I>CompoundTermImpl</I> class, which implements <I>CompoundTerm</I>. Incidentally, <I>Atom</I> also implements <I>CompoundTerm</I>, even though strictly speaking ECLiPSe atoms are not compound. Here is an
example of <I>CompoundTermImpl</I> at work:

<P>
<PRE>
  // Construct a term in Java to represent the Eclipse term foo(a, b, 3).
  private static CompoundTerm construct_term()
  {
    Atom a = new Atom("a");
    Atom b = new Atom("b");
    Integer numberThree = new Integer(3);
    CompoundTerm theTerm = new CompoundTermImpl("foo", a, b, numberThree);

    return(theTerm);
  }
</PRE>
This method is taken from the example Java program <A NAME="tex2html226"
 HREF="../examples/JavaInterface/DataExample1.java"><TT>DataExample1.java</TT></A>
which can be found in the examples directory <TT>&lt;eclipse_dir&gt;/doc/examples/JavaInterface</TT>. The rest of the program sends
ECLiPSe a goal which tells it to write the term created by <TT>construct_term()</TT> to <TT>stdout</TT>.

<P>
In this example we use an <I>CompoundTermImpl</I> constructor whose
first parameter is a string which becomes the functor of the term. The
remaining parameters are instances of <I>java.lang.Object</I>. They may
be instances of any class or interface which appears in Table
<A HREF="#tab:ec-java-data">8.1</A>. These become the arguments of the term. <I>CompoundTermImpl</I> has a number of other convenient constructors. See
the API documentation for details of these.

<P>
Note that the object returned by <TT>construct_term()</TT> is declared
not as a <I>CompoundTermImpl</I> but as a <I>CompoundTerm</I>. CompoundTerm is the Java interface for objects
representing compound terms. Anything which implements CompoundTerm
can be sent to ECLiPSe as a compound term.

<P>
Instead of using <I>CompoundTermImpl</I>, you may wish to implement
<I>CompoundTerm</I> yourself. The benefit of this is that you can pass
any object implementing <I>CompoundTerm</I> to an <TT>rpc</TT><A NAME="3817"></A> invocation, and
it can supply a functor and arguments without the unnecessary creation
of another object. To do this you may wish to subclass <I>AbstractCompoundTerm</I>.

<P>

<H2><A NAME="SECTION00833000000000000000">
Lists</A>
</H2>

<P>
Whenever you want to construct a list for ECLiPSe or deconstruct a
list coming from ECLiPSe, you use the <I>java.util.Collection</I>
interface. Look at the following method, taken from the example Java
program <A NAME="tex2html228"
 HREF="../examples/JavaInterface/DataExample2.java"><TT>DataExample2.java</TT></A>
(which can be found in the examples
directory <TT>&lt;eclipse_dir&gt;/doc/examples/JavaInterface</TT>).

<P>
<PRE>
  // Construct a collection in Java to represent the Eclipse 
  // list [1, foo(3.5), bar].
  private static Collection construct_collection()
  {
      Collection theCollection = new LinkedList();

      theCollection.add(new Integer(1));
      theCollection.add(new CompoundTermImpl("foo", new Double(3.5)));
      theCollection.add(new Atom("bar"));

      return(theCollection);
  }
</PRE>

<P>
If you study, compile and run <TT>DataExample2.java</TT> you will see
that the collection is indeed translated into the required ECLiPSe
list. You will also see that order is maintained in the sense that the
order of elements as they appear in the ECLiPSe list will equal the
collection's iterator order (the converse is true if the data is
coming from ECLiPSe to Java).

<P>
Also note that the ECLiPSe empty list (<TT>[]</TT>) is represented in
Java by the constant <I>java.util.Collections.EMPTY_LIST</I>.

<P>

<H2><A NAME="SECTION00834000000000000000">
Floats and Doubles</A>
</H2>

<P>
The ECLiPSe data type <TT>float</TT> is always converted to <I>java.lang.Double</I> in Java. However, ECLiPSe can be sent an instance
of <I>java.lang.Double</I> or <I>java.lang.Float</I>: both will be
converted to <TT>float</TT> in ECLiPSe. One value of <I>java.lang.Double</I> and <I>java.lang.Float</I> has no counterpart in
ECLiPSe: the not-a-number (NaN) value. Infinite values can be sent
in either direction.

<P>

<H2><A NAME="SECTION00835000000000000000">
Integers</A>
</H2>
ECLiPSe can be sent instances of either <I>java.lang.Integer</I>
(32-bit integers) or <I>java.lang.Long</I> (64-bit integers). Both of
these will be translated to type <TT>integer</TT> on the ECLiPSe side.
When ECLiPSe sends data to Java, it will decide between the two
classes depending on the number of bits needed for the integer. So for
example, if the number is small enough to fit in an Integer, that is
what will be returned. Note that therefore, the type of number
coming back from ECLiPSe cannot be relied upon to be of one type or
the other if it could fall on either side of the 32-/64-bit boundary.

<P>
If you require a set of numbers coming from ECLiPSe to be all of
one Java type e.g. long, then the best approach is to cast the object
returned by ECLiPSe to an instance of <I>java.lang.Number</I> and
then invoke the appropriate conversion method e.g. <TT>longValue()</TT>.

<P>

<H2><A NAME="SECTION00836000000000000000"></A>
<A NAME="sec:ji-variables-null"></A>
<BR>
Variables
</H2>
The Java <I>null</I> token is used to represent any variables being
sent to ECLiPSe. All variables coming from ECLiPSe will appear as
<I>null</I>. The limitations of this are discussed in more detail in
Section <A HREF="node43.html#sec:ji-calling-goals">8.4</A>.

<P>

<H2><A NAME="SECTION00837000000000000000">
The <TT>equals()</TT> method</A>
</H2>
The <TT>equals()</TT> method has been overridden for <I>AbstractCompoundTerm</I> and therefore also for <I>Atom</I> and <I>CompoundTermImpl</I>. The implementation returns <TT>true</TT> iff the
parameter <I>Object</I> implements <I>CompoundTerm</I> and its functor
and arity are equal to those of the <I>AbstractCompoundTerm</I>, and
pairwise invocations of <TT>equals()</TT> return <TT>true</TT> between each
of the <I>AbstractCompoundTerm</I>'s arguments and the corresponding
argument of the parameter object.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html1340"
 HREF="node43.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1336"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1330"
 HREF="node41.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1338"
 HREF="node76.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1341"
 HREF="node43.html">Executing an ECLiPSe goal</A>
<B> Up:</B> <A NAME="tex2html1337"
 HREF="node39.html">Using the Java-ECLiPSe Interface</A>
<B> Previous:</B> <A NAME="tex2html1331"
 HREF="node41.html">Functionality overview: A closer</A>
 &nbsp <B>  <A NAME="tex2html1339"
 HREF="node76.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
