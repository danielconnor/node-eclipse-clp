<HTML><HEAD><TITLE>trace_parent_port(+Port)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Debugging</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>trace_parent_port(+Port)</H1>
Create a user-defined debugger port for the parent box.
<DL>
<DT><EM>Port</EM></DT>
<DD>An atom.
</DD>
</DL>
<H2>Description</H2>

    This predicate allows to generate a user-defined debugger port,
    thus enhancing the debugger's basic box model with application-
    specific checkpoints. In the box model, the execution is viewed as
    consisting of nested boxes, which are being entered via CALL or
    REDO ports, and left via EXIT, FAIL or LEAVE ports.
<P>
    When the debugger is on, this predicate causes a trace line to
    be displayed for the current innermost box, with Port being the
    name of the port, and all other information being the current
    box's ones.
<P>

<H2>Examples</H2>
<PRE>
    p :-
	trace_parent_port(clause1),  
	writeln(hello),
	fail.
    p :-
	trace_parent_port(clause2),  
	writeln(world).

?- p.
  (1) 1 CALL  p   %&gt; creep
  (1) 1 CLAUSE1  p   %&gt; creep
S (2) 2 CALL  writeln(hello)   %&gt; creep
hello
S (2) 2 EXIT  writeln(hello)   %&gt; creep
  (3) 2 CALL  fail   %&gt; creep
  (3) 2 FAIL  fail   %&gt; creep
  (1) 1 NEXT  p   %&gt; creep
  (1) 1 CLAUSE2  p   %&gt; creep
S (4) 2 CALL  writeln(world)   %&gt; creep
world
S (4) 2 EXIT  writeln(world)   %&gt; creep
  (1) 1 EXIT  p   %&gt; creep

Yes (0.00s cpu)
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/debug/trace_call_port-3.html">trace_call_port / 3</A>, <A HREF="../../kernel/debug/trace_point_port-3.html">trace_point_port / 3</A>, <A HREF="../../kernel/debug/trace_exit_port-0.html">trace_exit_port / 0</A>, <A HREF="../../kernel/debug/spy_term-2.html">spy_term / 2</A>, <A HREF="../../kernel/debug/spy_var-1.html">spy_var / 1</A>, <A HREF="../../kernel/debug/trace-1.html">trace / 1</A>
</BODY></HTML>
