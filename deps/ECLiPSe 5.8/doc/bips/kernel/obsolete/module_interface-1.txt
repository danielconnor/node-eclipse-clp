
module_interface(+Module)

   Create the module Module and start defining its interface.



Arguments
   +Module             Atom.

Type
   Obsolete

Description
   This is a directive that can occur only in a compiled file.  If Module
   is an existing module, it is first erased.  Then a new module is created
   and all following code up to the next begin_module/1 or
   module_interface/1 directive or the file end defines the interface part
   of this module.  The module interface can contain both queries and
   predicate definitions, however usually only those predicates need to be
   defined in the interface that must be always compiled in order to read
   the module body.  For instance, macro transformation predicates for
   macros used in the file must be compiled, otherwise the parser cannot
   parse the file.  If another module uses this module by means of the
   use_module/1 predicate, all queries in the module interface except
   export/1 and global/1 will be executed in that module, and exported
   predicates will be imported into it.




Resatisfiable
      No.

Fail Conditions
      None.



Exceptions
     4 --- Module is not instantiated.
     5 --- Module is not an atom.
    68 --- When called from Prolog.
    82 --- Module is locked.

Examples
   
Success:
     [eclipse 2]: [user].
     :- module_interface(m).
     :- op(700, xf, there).
     :- export p/1.
     :- begin_module(m).
      p(X) :- writeln(X).
      user compiled 56 bytes in 0.03 seconds
     yes.
     [eclipse 3]: p(hello there).
     syntax error: postfix/infix operator expected
     | p(hello there).
     |             ^ here
     [eclipse 3]: use_module(m).

     yes.
     [eclipse 4]: p(hello there).
     hello there

     yes.

Error:
    module_interface(M).                 (Error 4).
    module_interface(1).                 (Error 5).
    module_interface(a_locked_module).   (Error 82).





See Also
   module / 1, begin_module / 1, create_module / 1, erase_module / 1, current_module / 1
