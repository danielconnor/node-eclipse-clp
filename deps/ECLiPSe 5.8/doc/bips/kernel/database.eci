:- comment(alias, "Predicate Database and Compiler").
:- comment(summary, "Built-ins for creation of handling of executable code").

:- comment(current_compiled_file / 3, [
	summary:"Succeeds if File is a file that has been compiled into the system.

",
	template:"current_compiled_file(?File, ?Time, ?Module)",
	desc:html("   This predicate enumerates all files that have been compiled during this
   ECLiPSe session.  Time is the modification time of the file at the time
   it was compiled, and Module is the module from where it was compiled
   (the latter is irrelevant if the file contains a module itself).  The
   information can be used to determine if a file needs to be recompiled.

<P>
"),
	args:["?File" : "Atom or variable.", "?Time" : "Integer or variable.", "?Module" : "Atom or variable."],
	resat:"   Yes.",
	fail_if:"   None.\n\n",
	exceptions:[5 : "File instantiated, but not to an atom.", 5 : "Time instantiated, but not to an integer.", 5 : "Module instantiated, but not to an atom."],
	eg:"
make :- current_compiled_file(File, Time, Module),
        get_file_info(File, mtime) =\\= Time,
        compile(File, Module),
        fail.
make.



",
	see_also:[compile / 1, compile / 2, ensure_loaded / 1, make / 0]]).

:- comment('.' / 2, [
	summary:"Compile file or list of files --- shorthand for compile/1.

",
	template:"[+File_1, ...., +File_N]",
	desc:html("   Used to compile file or list of files.  The ``square bracket'' notation
   is used as a shorthand notation for compile/1.  See the specification of
   compile/1 for details.

<P>
"),
	args:["+File_i" : "Atom or string."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "File_n is not instantiated.", 5 : "File_n is instantiated, but not to an atom or string.", 171 : "File_n does not exist."],
	eg:"
Success:
     [hanoi].         % compiles the file hanoi.pl

     [eclipse]: sh('cat file1').
     p:-writeln(hello).
     yes.
     [eclipse]: sh('cat file2').
     q(X) :- write(X).
     yes.
     [eclipse]: [user], p.
      p :- writeln(hi).
      user compiled 92 bytes in 0.00 seconds
     hi
     yes.
     [eclipse]: [file1, file2], p.
     /home/lp/user/file1 compiled 32 bytes in 0.02 seconds
     /home/lp/user/file2 compiled 92 bytes in 0.00 seconds
     hello
     yes.
Error:
     [F].            (Error 4).
     [file1/1].      (Error 5).
     [noexist].      (Error 171).



",
	see_also:[compile/1, compile/2, fcompile:fcompile/1 ]]).

:- comment(is_predicate / 1, [
	summary:"Succeeds if PredSpec is a defined predicate.

",
	template:"is_predicate(+PredSpec)",
	desc:html("   Used to test whether PredSpec is defined as a user or a built-in
   predicate.

<P>
"),
	args:["+PredSpec" : "Predicate of the form Atom/Integer."],
	resat:"   No.",
	fail_if:"   Fails if PredSpec is not a valid predicate.\n\n",
	exceptions:[4 : "PredSpec is not fully instantiated.", 5 : "PredSpec is not in the format Atom/Integer."],
	eg:"
Success:
[eclipse]: [user].
    a(1).
    a(1,2).
    a(1,2,3).
    user compiled 144 bytes in 0.00 seconds
   yes.
   [eclipse]: is_predicate(a/1).
   yes.
   [eclipse]: is_predicate(a/2).
   yes.
   [eclipse]: is_predicate(nl/0).
   yes.
   [eclipse]: is_predicate(a/2).
   yes.
Fail:
   is_predicate(a/0).         % Fails if a/0 is not a predicate
Error:
   is_predicate(X).          (Error 4).
   is_predicate(a/X).        (Error 4).
   is_predicate(a).          (Error 5).
   is_predicate(1).          (Error 5).



",
	see_also:[get_flag / 3, pred / 1, current_predicate / 1, current_built_in / 1]]).

:- comment(lib / 1, [
	summary:"Makes the library LibraryName available in the current module if not loaded
already.

",
	template:"lib(+LibraryName)",
	desc:html("
   Used to load the library LibraryName into the system if it has not
   already been loaded.  The currently used Prolog suffix(es) is appended
   to LibraryName and the resulting library is loaded if it exists.
<P>
   The search path used when loading libraries is specified by the global
   flag library_path using the get_flag/2 and set_flag/2 predicates.  This
   flag contains a list of strings containing the pathnames of the
   directories to be searched when loading a library file.  User libraries
   may be added to the system simply by copying the desired file into the
   ECLiPSe library directory.  Alternatively the library_path flag may be
   updated to point at a number of user specific directories.
<P>
   lib(Lib) is identical to use_module(library(Lib)).
<P>
"),
	args:["+LibraryName" : "String or atom."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "LibraryName is not instantiated.",
	    5 : "LibraryName is neither a string nor an atom.",
	    80 : "Library file does not contain a matching module.",
	    173 : "Library file LibraryName not found."],
	eg:"
Success:
   [eclipse]: lib(sorts).
   loading the library /usr/local/ECLIPSE/lib/sorts.pl
   yes.
   [eclipse]: lib(sorts).
   yes.              % library already loaded - succeeds
Error:
   lib(X).            (Error 4).
   lib(1).            (Error 5).
   lib(no_lib).       (Error 173).


",
	see_also:[ensure_loaded / 1, existing_file/4, get_flag / 2, set_flag / 2, use_module / 1]]).


:- comment(als / 1, [
	summary:"Outputs the abstract code for the compiled predicate PredSpec.

",
	template:"als(+PredSpec)",
	desc:html("   If PredSpec is a predicate compiled into a sequence of abstract
   instructions, this predicate will list on the current output stream this
   abstract code.  The ECLiPSe abstract machine is a modification of the
   Warren Abstract Machine.

<P>
"),
	args:["+PredSpec" : "Atom/Integer or just Atom."],
	resat:"   No.",
	fail_if:"   Fails if PredSpec is not a predicate compiled into the WAM.\n\n",
	exceptions:[4 : "PredSpec is not instantiated.", 5 : "PredSpec is not of the form Atom/Integer or Atom.", 60 : "PredSpec does not exist."],
	eg:"
Success:
    [eclipse 1]: als(true).

    true/0 :
            Debug_exit
            Retd


    yes.

Error:
    als(X).                  (Error 4).
    als(a/a).                (Error 5).
    als(undef/3).            (Error 60).



",
	see_also:[asm:disasm/2]]).

:- comment(compiled_stream / 1, [
	summary:"Succeeds if the I/O stream currently being compiled is Stream.

",
	template:"compiled_stream(?Stream)",
	desc:html("   Used to find the stream that is currently being compiled.
   compiled_stream/1 is meaningful mainly in queries inside a compiled
   file, or in event handlers for compilation events.

<P>
"),
	args:["?Stream" : "Atom, Integer or variable."],
	resat:"   No.",
	fail_if:"   Fails if no compilation from a stream is currently active.\n\n",
	exceptions:[5 : "Stream is instantiated, but not to an atom or integer."],
	eg:"
    [eclipse]: [user].
     a.
     :- compiled_stream(S), get_stream_info(S, name, File),
        printf(\"Compiling stream %d, file %s\\n\", [S, File]).
    Compiling stream 0, file user
    ^D
     user       compiled traceable 28 bytes in 0.00 seconds

    yes.
    [eclipse]: exec('cat a.pl', []).
    a.
    :- compiled_stream(S), get_stream_info(S, name, File),
       printf(\"Compiling stream %d, file %s\\n\", [S, File]).

    yes.
    [eclipse]: [a].
    Compiling stream 5, file /home/joe/a.pl
    a.pl       compiled traceable 28 bytes in 0.00 seconds

    yes.



",
	see_also:[compile / 1, compile / 2, compile_stream / 1]]).

:- comment((demon) / 1, [
	summary:"Declares the procedure(s) specified by SpecList to be demons.

",
	template:"demon +SpecList",
	desc:html("   The demon annotation specifies that the listed predicates are to
   be treated as demons. The only difference between a normal predicate
   and a demon is the behaviour on waking: When a normal predicate is
   delayed and gets woken, the delayed goal disappears. When a delayed
   demon gets woken, the delayed goal stays around.
   The only way to remove a demon is to explicitly kill it.

<P>
"),
	args:["+SpecList" : "Comma-separated sequence of expressions of the form Atom/Integer."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "SpecList is not instantiated.", 5 : "SpecList is
	instantiated, but not to a sequence of    expressions of the form Atom/Integer.",
                    62: "Predicate in SpecList already defined and is not a demon" 
],
	eg:"
     % A demon that wakes whenever X becomes more constrained
     report(X) :-
\t     suspend(report(X, Susp), 1, X->constrained, Susp).

     :- demon report/2.
     report(X, _Susp) :-
\t     var(X),
\t     writeln(constrained(X)).  % implicitly re-suspend
     report(X, Susp) :-
\t     nonvar(X),
\t     writeln(instantiated(X)),
             kill_suspension(Susp).    % remove from the resolvent



     [eclipse 1]:  report(X),
             notify_constrained(X), wake,
             notify_constrained(X), wake.
     constrained(X)
     constrained(X)

     X = X

     Delayed goals:
                 report(X)
     yes.

     [eclipse 2]:  report(X),
             notify_constrained(X), wake,
             X=123.
     constrained(X)
     instantiated(123)

     X = 123
     yes.




",
	see_also:[kill_suspension / 1, make_suspension / 3, notify_constrained / 1, schedule_suspensions / 2, set_suspension_data / 3, get_suspension_data / 3]]).

:- comment(ensure_loaded / 1, [
	summary:"Compile the specified Files if necessary.

",
	template:"ensure_loaded(+Files)",
	desc:html("
	Compiles the specified files or libraries if they haven't been compiled
	yet or if they have been modified since the last compilation.
	The file name expansion rules are the same as for compile/1,
	except that it tries to load a precompiled file (with the
	eclipse_object_suffix) before looking for source files.
"),
	args:["+Files" : "Atom, string, library(Atom) or a list thereof."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "Files is not instantiated.", 5 : "File is instantiated but not to a (list of) files."],
	eg:"
    ensure_loaded(prog).
    ensure_loaded('dir/file').
    ensure_loaded([file1, 'file2.pl']).
    ensure_loaded(library(lists)).
",
	see_also:['.' / 2, compile / 1, compile / 2, current_compiled_file / 3, fcompile:fcompile/1, get_flag/2]]).

:- comment((parallel) / 1, [
	summary:"Declares the procedure(s) specified by SpecList as parallel.

",
	template:"parallel +SpecList",
	desc:html("   The parallel annotation specifies that the system is allowed to execute
   the clauses of the annotated predicate in parallel (Or-parallelism),
   instead of sequentially by backtracking.  This has the following
   consequences:

<P>
  * the predicate is a source of or-parallelism which will hopefully speed
    up execution of the program on a parallel machine

<P>
  * calls to this predicate may return alternative solutions in
    unpredictable order

<P>
  * side effects within the parallel execution may happen in unpredictable
    order

<P>
   The parallel annotation has simply no effect when the predicate (or a
   particular call to it) is deterministic or when it is used with a
   sequential ECLiPSe system.

<P>
   A procedure can be declared parallel before it is actually defined.

<P>
"),
	args:["+SpecList" : "Comma-separated sequence of expressions of the form Atom/Integer."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "SpecList is not instantiated.", 5 : "SpecList is instantiated, but not to a sequence of    expressions of the form Atom/Integer."],
	eg:"
  [eclipse 1]: [user].
   :- parallel p/1.
   p(a).  p(b).  p(c).
  user       compiled traceable 220 bytes in 0.02 seconds
  yes.
  [eclipse 2]: get_flag(p/1, parallel, Flag).
  Flag = on
  yes.
  [eclipse 3]: p(X), use(X).
  % The three clauses of p/1 as well as the resulting goals
  % use(a), use(b) and use(c) may be executed in parallel!




",
	see_also:[compile / 1, get_flag / 3, set_flag / 3]]).

:- comment((abolish) / 1, [
	summary:"Remove the definition of the predicates specified in SpecList.

",
	template:"abolish +SpecList",
	desc:html("\
   Removes the definition of the predicates specified in SpecList. These
   predicates must have their definition (clauses) in the caller module.
<P>
   Predicates that are defined elsewhere (i.e. imported or reexported
   predicates) cannot be abolished. They can only be abolished from their
   definition module.
<P>
   After a predicate has been abolished, any attempt to invoke it will
   give rise to an error 68 (calling an undefined procedure).
<P>
   Certain declarations about properties of a predicate will remain in
   effect even after abolishing the predicate. These include declarations
   that affect the predicate's calling convention (modes, demon, parallel,
   tool).  Moreover, the predicate's visibility (local, exported) is not
   affected, i.e. if the predicate was exported, it will remain exported.
<P>
   Predicates can be abolished, no matter whether they are static or
   dynamic. For dynamic predicates, the difference between retract_all/1
   and abolish/1 is that retract_all/1 leaves the predicates with no
   clauses (call of the predicate will fail) and the predicate retains
   its dynamic-property.  In contrast, abolish/1 makes the predicates
   undefined (calls will raise and error) and the predicate loses its
   dynamic-property.
<P>
   Error 60 (``referring to an undefined procedure'') is raised when no
   predicate of name SpecList is visible.  Error 100 (``accessing a
   procedure defined in another module'') is raised if the visible
   predicate is defined or declared in a different module than the
   caller module.
<P>
   abolish/1 satisfies the logical update semantics.  Abolishing a
   predicate will not, in any way, affect previous calls to it (when
   backtracking).
<P>
"),
	args:["+SpecList" : "Sequence of expressions of the form Atom/Integer."],
	resat:"   No",
	fail_if:"   None\n\n",
	exceptions:[4 : "SpecList is not instantiated",
	    5 : "SpecList is instantiated, but not to a sequence of expressions of the form Atom/Integer",
	    60 : "SpecList is undefined in the caller module",
	    100 : "SpecList is not defined in the caller module"],
	eg:"
[eclipse 1]: [user].
 p :- writeln(hello).
Yes (0.00s cpu)

[eclipse 2]: p.
hello
Yes (0.00s cpu)

[eclipse 3]: abolish p/0.
Yes (0.00s cpu)

[eclipse 4]: p.
calling an undefined procedure p in module eclipse
Abort

[eclipse 5]: abolish writeln/1.
accessing a procedure defined in another module in abolish writeln / 1
Abort

[eclipse 6]: abolish foo/33.
referring to an undefined procedure in abolish foo / 33 in module eclipse
Abort



Logical semantics :

If the following clauses are in the database :
    p(1) :- abolish(p/1).
    p(2).

The call p(X). will produce all the solutions visible when it started
executing :

    [eclipse]: p(X).
    X = 1     More? (;)
    X = 2
    yes.
",
	see_also:[retract_all / 1]]).

:- comment(compile / 1, [
	summary:"Compile specified file or list of files File.

",
	template:"compile(+File)",
	desc:html("   Compiles the specified Prolog source file or list of source files.  The
   atom or string File must be instantiated to a legitimate specification
   for an existing file except for the suffix.
<P>
   The predicate tries to add to it the Prolog suffixes from the list
   specified in the Prolog flag prolog_suffix and look for an existing and
   readable file.  As soon as a file is found which exists, it is taken as
   the input file name.  The default Prolog suffixes are empty suffix,
   .ecl and .pl.
<P>
   If File is of the form library(Name), the predicates looks for the file
   in the directories from the library_path flag.
<P>
   When File is not in the current directory, ECLiPSe first changes the
   current directory to that of the file.  Consequently, recursive
   compile/1 calls inside compiled files can use relative pathnames.  This
   makes it possible to compile the program top files from any directory
   and still use only local file names.  At the end of the compilation, the
   current directory is changed back to the initial one.  This has the side
   effect that all calls to cd/1 in queries in the compiled file are
   ignored.
<P>
   Compiling a file which contains a module/1 or module/3 directive
   completely redefines an existing module of the same name.  Otherwise,
   static procedures are redefined by those occurring in the compiled file,
   the clauses of dynamic procedures are appended to the existing ones.  To
   add new procedures to an existing module without erasing the whole
   module the predicate compile/2 is to be used.
<P>
   Note that the alternative notation [File1, File2, ...  , FileN] may be
   used instead of compile([File1, File2,...  , FileN]).

<P>
   In addition to the exceptions listed below, any exception can occur during
   compilation, because general code may be executed in directives (:-/2), file
   queries (?-/2), macro transformations and inline expansion code.
"),
	args:["+File" : "Atom, structure or string, or a list of them."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "File is not instantiated.",
	    5 : "File is instantiated, but not to an atom or string, or a list of atoms or strings.",
	    61 : "A predicate that was already defined is later declared to be a tool.",
	    62 : "Illegal attempt to change a predicate's properties like: tool, dynamic, demon, parallel, calling convention.",
	    82 : "The module in which the clauses should be compiled is locked.",
	    94 : "There is already am imported predicate of the same name.",
	    130 : "The head of a clause is not an atom or a compound term.",
	    131 : "A subgoal in the body of a clause is not an atom, a compound term or a variable.",
	    134 : "The clauses of a procedure are not consecutive.",
	    137 : "A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.",
	    139 : "This event is invoked at the end of each compiled file, by default it prints the compilation time and size of compiled code.",
	    143 : "A query in the compiled file has failed. This is by default ignored and the compilation continues.",
	    145 : "A procedure is being redefined in another file than the original one.",
	    147 : "This event is raised just before a compilation is aborted because of an error.",
	    148 : "An unrecognised pragma was used in the code.",
	    171 : "File does not exist."
	    ],

	eg:"
Success:
   [hanoi].         % compiles the file hanoi.pl

   [eclipse]: sh('cat file1').
   p:-q(hello).
   yes.
   [eclipse]: sh('cat file2').
   q(X) :- writeln(X).
   yes.
   [eclipse]: compile(user), p.
    p :- writeln(hi).
    user compiled 92 bytes in 0.00 seconds
   hi
   yes.
   [eclipse]: compile([file1, file2]), p.
   /home/lp/user/file1 compiled 32 bytes in 0.02 seconds
   /home/lp/user/file2 compiled 92 bytes in 0.00 seconds
   hello
   yes.


   % example showing use of relative pathnames.
   [eclipse]: sh('ls -FR /home/lp/user/pl').
   a.pl        util/

   /home/lp/user/pl/util:
   b.pl        c.pl

   yes.
   [eclipse]: sh('cat /home/lp/user/pl/a.pl').
   :- compile('util/b').
   p.

   yes.
   [eclipse]: compile('/home/lp/user/pl/a').
   /home/lp/user/pl/util/b.pl compiled 92 bytes in 0.00 seconds
   /home/lp/user/pl/a.pl compiled 28 bytes in 0.00 seconds
   yes.

Error:
   compile(F).            (Error 4).
   compile(file1/1).      (Error 5).
   compile(file).         (Error 171).



",
	see_also:[ensure_loaded / 1, compile / 2, '.' / 2, compile_stream / 1, compile_term / 1, lib / 1, set_flag / 2, use_module / 1, pragma/1, fcompile:fcompile / 1]]).

:- comment(compile / 2, [
	summary:"Compiles specified file or list of files File into the specified module
Module.

",
	template:"compile(+File,+Module)",
	desc:html("   Similar to compile/1 except that the specified file or list of files is
   compiled into the specified module Module.

<P>
   If the file contains no module/1 or module/3 directive,
   procedures that occur in File are written to the module Module
   (overwriting if necessary); the rest of the module remains unchanged.  If
   the file contains a module directive it works like compile/1.

<P>
   If Module does not exist, compile/2 will create such a module and
   compile File into it.

<P>
   In addition to the exceptions listed below, any exception can occur during
   compilation, because general code may be executed in directives (:-/2), file
   queries (?-/2), macro transformations and inline expansion code.
"),
	args:["+File" : "Atom or string, or list of atoms or strings.", "+Module" : "Atom."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "Either File or Module is not instantiated.",
	    5 : "File is instantiated, but not to an atom or string, or a list of atoms or strings.",
	    5 : "Module is instantiated, but not to    an atom.",
	    61 : "A predicate that was already defined is later declared to be a tool.",
	    62 : "Illegal attempt to change a predicate's properties like: tool, dynamic, demon, parallel, calling convention.",
	    82 : "The module in which the clauses should be compiled is locked.",
	    94 : "There is already am imported predicate of the same name.",
	    130 : "The head of a clause is not an atom or a compound term.",
	    131 : "A subgoal in the body of a clause is not an atom, a compound term or a variable.",
	    134 : "The clauses of a procedure are not consecutive.",
	    136 : "Attempt to redefine a built-in predicate without declaring it first.",
	    137 : "A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.",
	    139 : "This event is invoked at the end of each compiled file, by default it prints the compilation time and size of compiled code.",
	    143 : "A query in the compiled file has failed. This is by default ignored and the compilation continues.",
	    145 : "A procedure is being redefined in another file than the original one.",
	    147 : "This event is raised just before a compilation is aborted because of an error.",
	    148 : "An unrecognised pragma was used in the code.",
	    171 : "File does not exist."
	    ],

	eg:"
Success:
   [hanoi].         % compiles the file hanoi.pl

   [eclipse]: sh('cat file1').
   p.
   yes.
   [eclipse]: sh('cat file2').
   q(X) :- write(X).
   yes.
   [eclipse]: [user], p.
    p :- write(hi).
    user compiled 92 bytes in 0.00 seconds
   hi
   yes.
   [eclipse]: compile([file1, file2],b), p.
   /home/lp/user/file1 compiled 32 bytes in 0.02 seconds
   /home/lp/user/file2 compiled 92 bytes in 0.00 seconds
   hi               % p/0 not compiled into module eclipse
   yes.
   [eclipse]: module(b).
   [b]: p.
   yes.
   [b]: q(ho).
   ho.
   yes.


   % example showing use of relative pathnames.
   [eclipse]: sh('ls -FR /home/lp/user/pl').
   a.pl        util/

   /home/lp/user/pl/util:
   b.pl        c.pl

   yes.
   [eclipse]: sh('cat /home/lp/user/pl/a.pl').
   :- compile('util/b').
   p.

   yes.
   [eclipse]: compile('/home/lp/user/pl/a', b).
   /home/lp/user/pl/util/b.pl compiled 92 bytes in 0.00 seconds

   /home/lp/user/pl/a.pl compiled 28 bytes in 0.00 seconds
   yes.

Error:
   compile(file1,M).         (Error 4).
   compile(F,eclipse).         (Error 4).
   compile(file1, \"b\").      (Error 5).
   compile(file1/1, b).      (Error 5).
   compile(file,eclipse).      (Error 171).



",
	see_also:[compile / 1, compile_stream / 1, compile_term / 1, set_flag / 2, use_module / 1, pragma/1, fcompile:fcompile / 1]]).

:- comment(compile_stream / 1, [
	summary:"Compile the given stream Stream.

",
	template:"compile_stream(+Stream)",
	desc:html("   Used to compile from an arbitrary input stream Stream.

<P>
   Stream may be a physical stream number or a reserved or user-defined
   symbolic stream name.  The stream can be of any type, e.g. file, tty,
   socket, queue, string, etc.

<P>
   If Stream is an opened input stream, its content is read and compiled as
   in compile/1.  The compilation stops at the stream end, but the stream
   remains open.

<P>
"),
	args:["+Stream" : "Integer or atom."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "Stream is not instantiated.",
		5 : "Stream is instantiated, but not to an atom or integer.",
		192 : "Stream is in an illegal stream mode.",
		193 : "Stream is an illegal stream specification."],
	eg:"
compile_string(String) :-
	open(string(String), read, S),
	compile_stream(S),
	close(S).


Error:
     compile_stream(X).      (Error 4).
     compile_stream(1.0).    (Error 5).
     compile_stream(1).      (Error 192).
     compile_stream(2).      (Error 192).
     compile_stream(20).     (Error 192).
     compile_stream(a).      (Error 193).



",
	see_also:[compile / 1, compile / 2, compiled_stream / 1, compile_term / 1, current_compiled_file / 3, set_flag / 2, pragma/1]]).

:- comment(compile_term / 1, [
	summary:"Compile specified clause or list of clauses Clause.

",
	template:"compile_term(+Clause)",
	desc:html("\
   Compiles the specified clause, or list of clauses, similar to
   compilation from a file.  If the clauses are for a predicate that
   was undefined so far, a new static predicate will be created.  If
   the clauses are for an existing static predicate, the new clauses
   will replace the old definition of the predicate.  If the clauses
   are for an existing dynamic predicate, the new clauses will be
   added to the exiting ones for the dynamic predicate.
<P>
   If Clause is a list, the list elements are interpreted as consecutive
   clauses.  Otherwise, Clause will be taken as a single clause.
   Each clause may be a fact or a rule.
<P>
   This predicate works almost as if all the clauses in the list
   were written into a file and this file was then compiled using
   compile/1. It does however not perform any inline expansion on
   the goals in the clause bodies. To do this, explicit preprocessing
   of the clauses is required (e.g. using expand_goal/2). This may
   change in a future release.
<P>
   The difference between compile_term/1 and assert/1 is that
   the predicates for which clauses are compiled are not necessarily
   dynamic with compile_term/1, unless explicitly declared as such.
   Therefore clauses compiled with compile_term/1 usually replace the
   existing ones for the same predicate, moreover their source form is not
   available.  Therefore, it can be used instead of assert/1 if the
   properties of dynamic procedures are not required.
<P>
   Unlike compiling a file, when an event occurs which is not just a
   warning, the following clauses are not compiled, the compilation is
   aborted.
<P>
   See compile/1 for a more complete list of exceptions that can occur
   during compilation.
"),
	args:["+Clause" : "A valid Prolog clause, or list of clauses."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "Clause is a partial list.",
	    5 : "Clause is a list whose tail is neither nil nor a variable.",
	    82 : "The module in which the clauses should be compiled is locked.",
	    94 : "There is already am imported predicate of the same name.",
	    130 : "The head of a clause is not an atom or a compound term.",
	    131 : "A subgoal in the body of a clause is not an atom, a compound term or a variable.",
	    134 : "The clauses of a procedure are not consecutive.",
	    136 : "Trying to redefine a built-in predicate without having declared it.",
	    137 : "A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.",
	    143 : "One of the clauses was a query and it failed."],

	eg:"
Success:
   % several facts for different predicates
   ?- compile_term([p(a), p(b), q(1), r(\"abc\")]).

   % a single clause
   ?- compile_term(p(X) :- q(X)).

   % two clauses for the same predicate
   ?- compile_term([p([]), (p([X|Xs]) :- writeln(X), p(Xs))]).

   % a declaration and two clauses
   ?- compile_term([(:- export p/1), p(a), p(b)]).



   % Compile_term/1 can be used for conditional compilation:
   :- (exists('/usr/ucb') -> S = bsd; S = sysV),
      compile_term(os(S)).

   % Even a whole procedure can be conditionally compiled:
   :- os(bsd) ->
    compile_term([
        (pred1(X) :- pred2(X), pred3(X)),
        (pred1(Y) :- ...           )]).


Error:

   compile_term([p|X]).          (Error 4).
   compile_term([a|b]).          (Error 5).
   compile_term([[a]]).          (Error 94).
   compile_term([(p :- write(a)), write(b)]).      (Error 94).
   compile_term(\"a\").          (Error 130).
   compile_term([\"a\" :- b]).   (Error 130).
   compile_term([p(X) :- 1]).    (Error 131).
   compile_term([a, b, a]).      (Error 134).
   compile_term(!).              (Error 135).
   compile_term(:- var(a)).      (Error 143).
",
	see_also:[compile / 1, compile / 2, '.' / 2, compile_stream / 1,
	assert / 1, expand_goal/2, set_flag / 2, pragma/1]]).

:- comment(current_built_in / 1, [
	summary:"Succeeds if the predicate defined by PredSpec is a visible built-in
predicate.

",
	template:"current_built_in(?PredSpec)",
	desc:html("   Used to check that PredSpec is a built-in predicate visible from the
   caller module, or else to return on backtracking all the visible
   built-in predicates.

<P>
"),
	args:["?PredSpec" : "Expression of the form Atom/Integer or variable."],
	resat:"   Yes.",
	fail_if:"   Fails if the predicate defined by PredSpec is not a visible built-in\n   predicate.\n\n",
	exceptions:[5 : "PredSpec is instantiated, but not to the form Atom/Integer."],
	eg:"
Success:
     [eclipse]: current_built_in(X/Y),!.
     X = findall
     Y = 3
     yes.

     [eclipse]: current_built_in(X).
     X = findall / 3     More? (;)
     X = ! / 0     More? (;)
     X = delayed_goals / 1     More? (;)
     X = delayed_goals / 2     More? (;)   % type <cr>
     yes.
Fail:
     current_built_in(assertz/1).
     current_built_in(reverse/2).

     [eclipse]: [user].
      p.
      user compiled 28 bytes in 0.00 seconds
     yes.
     [eclipse]: get_flag(p/0, type, T).
     T = user
     yes.
     [eclipse]: current_built_in(p/0).
     no.
Error:
     current_built_in(a/a).         (Error 5).



",
	see_also:[current_predicate / 1, current_module_predicate/2, is_predicate / 1]]).

:- comment(current_predicate / 1, [
	summary:"Succeeds if PredSpec is a visible predicate defined by the user, or a
visible library predicate.

",
	template:"current_predicate(?PredSpec)",
	desc:html("   Used to check that PredSpec is a user or library predicate visible from
   the caller module, or else to return on backtracking all the current
   visible predicates.

<P>
"),
	args:["?PredSpec" : "Expression of the form Atom/Integer or variable."],
	resat:"   Yes.",
	fail_if:"   Fails if PredSpec is not a visible (user or library) predicate.\n\n",
	exceptions:[5 : "PredSpec is instantiated, but not to the form Atom/Integer."],
	eg:"
Success:
     [eclipse]: current_predicate(X/Y).
     X = intersection
     Y = 3     More? (;)
     yes.
     [eclipse]: current_predicate(X).
     X = (^) / 2     More? (;)
     X = intersection / 3     More? (;)
     X = subtract / 3     More? (;)
     X = append / 3     More? (;)
     yes.

     [eclipse]: [user].
      p.
      user compiled 28 bytes in 0.00 seconds
     yes.
     [eclipse]: current_predicate(p/0).
     yes.
Fail:
     current_predicate(assert/1).
Error:
     current_predicate(a/a).         (Error 5).



",
	see_also:[current_module_predicate/2, current_built_in / 1, is_predicate / 1, get_flag / 3]]).


:- comment(current_module_predicate / 2, [
	summary:"Used to enumerate all predicates with given property in the caller module",
	template:"current_module_predicate(+Property, ?PredSpec)",
	desc:html("\
    This predicate is mainly used to enumerate all predicates in the caller
    module with one of the following properties (for testing, use get_flag/3):
<DL>
<DT><STRONG>undeclared</STRONG><DD>
    predicates that have been referenced but are neither
    declared nor defined in this module.
<DT><STRONG>no_module</STRONG><DD>
    predicates whose module of origin is known (through import or qualified
    reference), but that module does not exist.
<DT><STRONG>no_export</STRONG><DD>
    predicates whose module of origin exists, but the predicate is not
    exported from there.
<DT><STRONG>local</STRONG><DD>
    defined predicates that are local
<DT><STRONG>exported</STRONG><DD>
    defined predicates that are exported
<DT><STRONG>reexported</STRONG><DD>
    defined predicates that are reexported
<DT><STRONG>exported_reexported</STRONG><DD>
    defined predicates that are exported or reexported
<DT><STRONG>defined</STRONG><DD>
    predicates defined in this module (local or exported)
<DT><STRONG>undefined</STRONG><DD>
    local or exported predicates that have not been defined (no clauses)
<DT><STRONG>deprecated</STRONG><DD>
    predicates that are imported or referenced via qualification, but have
    their deprecated-flag set.
</DL>
    This predicate is more efficient than current_predicate/1 and
    current_built_in/1 when one is not interested in imported predicates.
    In particular, it does not complain about ambiguous imports.
"),
	args:[
	    "+Property" : "An atom.",
	    "?PredSpec" : "A variable or an expression of the form Atom/Integer."],
	resat:"Yes.",
	fail_if:"Fails if there is no (further) predicate with the given property",
	exceptions:[
	    4 : "Property is not instantiated",
	    5 : "Property is not an atom",
	    5 : "PredSpec is instantiated, but not to the form Atom/Integer."],
	eg:"
    [eclipse 1]: [user].
     :- local r/0.
     p :- q, r.
    yes.

    [eclipse 2]: current_module_predicate(defined,P).
    P = p / 0
    yes.

    [eclipse 3]: current_module_predicate(undefined,P).
    P = r / 0
    yes.

    [eclipse 4]: current_module_predicate(undeclared,P).
    P = q / 0
    yes.
",
	see_also:[current_built_in / 1, current_predicate / 1, get_flag / 3]]).


:- comment(get_flag / 3, [
	summary:"Succeeds if the flag Flag of the procedure specified by PredSpec has the
value Value.

",
	template:"get_flag(+PredSpec, ?Flag, ?Value)",
	desc:html("   Used to get the value Value of the flag Flag of the procedure specified
   by PredSpec.  The values of certain flags may be set using set_flag/3.
   It can also be used to test if a procedure with a given functor exists
   or has certain properties.

<P>
   The possible flags, their values and their meanings are:

<P>
<PRE>
    Flags             Values        Description
   ------------------------------------------------------
    call_type         prolog,       predicate source
                      external      language
    debugged          on, off       compiled in
                                    debugging mode
    declared          on, off       predicate was
                                    declared
    defined           on, off       predicate code
                                    exists
    definition_module an atom       where the procedure
                                    is defined
    deprecated        on, off       predicate is deprecated,
                                    warning on use
    leash             stop,         see below
                      print,
                      notrace
    mode              pred(Mode1,   the mode of the
                      ...)          predicate
    parallel          on, off       clauses may be exe-
                                    cuted in parallel
    priority          1..12         waking priority
    skip              on, off       procedure will be
                                    traced, but its
                                    children will not
    spy               on, off       procedure has a
                                    spypoint
    stability         static,       is the procedure
                      dynamic       dynamic?
    tool              on, off       tool property
    type              built-in,     type of predicate
                      user
    visibility        local,        module scope
                      exported,
                      reexported,
                      imported
    source_file       an atom       the file where
                                    defined
    source_line       an integer    starting line
                                    number in the file
    source_offset     an integer    byte offset at
                                    which the procedure
                                    definition starts
                                    in its source file
</PRE>
   The possible values of leash and their meanings are:

<P>
<PRE>
   -----------------------------------------------------
   | Values   Description                               |
   |--------------------------------------------------  |
   | stop     procedure ports are printed and the       |
   |          debugger stops on them                    |
   | print    procedure ports are printed and the       |
   |          debugger does not stop on them            |
   | notrace  procedure ports will not be shown, but    |
   |          its childrens's ports will                |
   -----------------------------------------------------|
</PRE>
"),
	args:["+PredSpec" : "Expression of the form Atom/Integer.", "?Flag" : "Atom or variable.", "?Value" : "Atom, integer, compound_term or variable."],
	resat:"   Yes.",
	fail_if:"   Fails if the flag Flag of the procedure specified by PredSpec does not\n   have the value Value, if its value is unknown or if the procedure does\n   not exist.\n\n",
	exceptions:[4 : "PredSpec is not instantiated", 5 : "PredSpec is not an expression of the form Atom/Integer.", 5 : "Flag is instantiated but not to an atom.", 5 : "Value is not an atom."],
	eg:"
Success:
    [eclipse]: get_flag(member/2, F, V),
            printf(\"%-20s%w\\n\", [F, V]), fail.

    mode                member(?, ?)
    call_type           prolog
    debugged            off
    declared            on
    autoload            off
    auxiliary           off
    defined             on
    leash               stop
    skip                off
    spy                 off
    start_tracing       off
    stability           static
    tool                off
    type                built_in
    visibility          imported
    priority            2
    demon               off
    parallel            off
    definition_module   sepia_kernel

Fail:
    get_flag(true/0, defined, off).
    get_flag(undef/0, F, V).
Error:
    get_flag(X, spy, on).           (Error 4).
    get_flag(\"a\", spy, on).         (Error 5).



",
	see_also:[pred / 1, set_flag / 3, current_module_predicate/2]]).

:- comment((mode) / 1, [
	summary:"Specifies the mode (calling pattern) for the given predicates.

",
	template:"mode +PredModes",
	desc:html("   The call of the predicate informs the compiler that the arguments of the
   specified predicate will always have the corresponding form when the
   predicate is called.  The compiler takes this information into account
   when the predicate is compiled and generates more compact and/or faster
   code.  Specifying the mode of a predicate that has been already compiled
   has no effect, unless it is recompiled.  If the specified procedure does
   not exist, a local undefined procedure is created.

<P>
   The possible argument modes are:

<P>
<PRE>
+   The argument is instantiated, i.e.  it is not a variable.

++  The argument is ground.

-   The argument is not instantiated, it must be a free variable without
    any constraints, especially it must not occur in any other argument and
    it cannot be a suspending variable.

?   The mode is not known or it is neither of the above ones.
</PRE>
   mode/1 is an operator and accepts also comma-separated list of mode
   specifications in the form

<P>
<PRE>
   mode p(+), q(-), r(++, ?).
</PRE>
   This operator binds less than comma, so the argument of mode/1 might
   have to be parenthesised when it is followed by other goals.  Modes for
   built-in and external predicates are ignored.  Modes are significant
   only for the first 15 arguments, for higher arguments the mode is always
   taken as ?.

<P>
   NOTE: If the instantiation of the predicate call violates its mode
   declaration, no exception is raised and its behaviour is undefined.

<P>
"),
	args:["+PredModes" : "Compound term whose arguments are +, ++, - or ?  or a comma-separated list of such compound terms."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "PredModes is not instantiated", 5 : "PredModes is not a compound term or a comma list or its    arguments are not the above specified atoms."],
	eg:"
Success:
    % code size:
    % no mode declarations
    [eclipse]: [append].
    /home/eclipse/src/append.pl compiled 212 bytes in 0.03 seconds

    % mode for one argument decreases the code size
    [eclipse]: mode(append(++, ?, ?)), [append].
    /home/eclipse/src/append.pl compiled 120 bytes in 0.00 seconds

    % modes for other arguments further decreases the size
    [eclipse]: mode(append(++, ++, -)), [append].
    /home/eclipse/src/append.pl compiled 92 bytes in 0.00 seconds

    % size of the trail stack
    cygnus% cat p.pl
    p(f(1), [output]) :- !.
    p(f(2), [another_one]).

    test :-
        p(f(1), X),
        statistics(trail_stack_used, T1),
        writeln(T1).
    :- test.
    cygnus% eclipse
    [eclipse]: [p].
    16
    /home/eclipse/p.pl    compiled 540 bytes in 0.02 seconds

    % With modes the code is shorter and does less trailing
    [eclipse]: mode(p(++, -)), [p].
    12
    /home/eclipse/p.pl    compiled 408 bytes in 0.02 seconds

    % bad mode declaration:
    [eclipse]: mode(p(+)), [user].
     p(a).
     user   compiled 40 bytes in 0.00 seconds

    yes.
    [eclipse]: p(X).    % call violates the mode declaration

    no (more) solution.
Error:
    mode p(X).                         (Error 4).
    mode p(+), get_flag(p/1, mode, X). (Error 5).
    % equivalent to mode((p(+), get_flag(p/1, mode, X)))



",
	see_also:[compile / 1, get_flag / 3, set_flag / 3]]).

:- comment(set_flag / 3, [
	summary:"Sets the flag Flag of the procedure specified by PredSpec to the value
Value.

",
	index:[priority,leash,skip,spy],
	template:"set_flag(+PredSpec, +Flag, +Value)",
	desc:html("   Used to set the value Value of the flag Flag of the procedure(s)
   specified by PredSpec.  The value of a flag may be returned using
   get_flag/3.

<P>
   The settable flags, their values and their meanings are:

<P>
<PRE>
   ---------------------------------------------------------------------
   | Flags          Values     Description                             |
   |-------------------------------------------------------------------|
   | deprecated     on, off    predicate is deprecated, warn on use    |
   |                                                                   |
   | leash                     debugger behaviour for this procedure:  |
   |                stop,        trace procedure's ports and stop      |
   |                print,       trace procedure's ports and continue  |
   |                notrace      hide procedure's ports                |
   |                                                                   |
   | skip           on, off    procedure will be traced,               |
   |                           but its children will not               |
   |                                                                   |
   | spy            on, off    procedure has a spypoint                |
   |                                                                   |
   | start_tracing  on, off    procedure starts the tracer             |
   |                                                                   |
   | priority       1..12      default waking priority                 |
   ---------------------------------------------------------------------
</PRE>
"),
	args:["+PredSpec" : "Expression of the form Atom/Integer or a list of those.", "+Flag" : "Atom.", "+Value" : "Atom."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "At least one of PredSpec, Flag or Value are not instantiated", 5 : "PredSpec is not an expression of the form Atom/Integer.", 5 : "Flag is not an atom.", 5 : "Value is not an atom.", 6 : "Flag is no flag.", 6 : "Value is no value of the flag Flag.", 30 : "Flag is a read only flag.", 60 : "PredSpec is not defined."],
	eg:"
Success:
    [eclipse]: [user].
     pr([]).  % prints the elements of a list
     pr([ S | T ]) :-
            writeln(S),
            pr(T).
     user compiled 484 bytes in 0.00 seconds
    yes.
    [eclipse]: pr([tom, dick]).
    tom
    dick
    yes.
    [eclipse]: set_flag(pr/1, spy, on).
    yes.
    [eclipse]: trace.
    Debugger switched on - creep mode
    yes.
    [eclipse]: pr([tom, dick]).
     +(1) 0  CALL   pr([tom, dick]) (dbg)?- leap
    tom
     +(3) 1  CALL   pr([dick]) (dbg)?- leap
    dick
     +(5) 2  CALL   pr([]) (dbg)?- leap
     +(5) 2  EXIT   pr([]) (dbg)?- leap
     +(3) 1  EXIT   pr([dick]) (dbg)?- leap
     +(1) 0  EXIT   pr([tom, dick]) (dbg)?- leap
    yes.

Error:
    set_flag(X, skip, on).                 (Error 4).
    set_flag(\"a\", spy, on).                (Error 5).
    set_flag(is/2, spy, yes).              (Error 6).
    set_flag(p/2, leash, on).              (Error 60).



",
	see_also:[debug / 0, get_flag / 3, (nospy) / 1, (parallel) / 1, pred / 1, (skipped) / 1, (spy) / 1, trace / 0, (traceable) / 1, (unskipped) / 1, (untraceable) / 1]]).

:- comment(inline / 2, [
	summary:"Declares TransPred as the predicate to be used to do compile-time
transformation (e.g. inlining) of calls to Pred.

",
	template:"inline(+Pred, +TransPred)",
	desc:html("\
   To improve efficiency, calls to user-defined predicates can be
   preprocessed and transformed at compile time.  The directive

<P>
<PRE>
    :- inline(mypred/1, mytranspred/2).
</PRE>
   arranges for mytranspred/2 to be invoked at compile time for each 
   call to the predicate mypred/1 before it is being compiled.

<P>
   The transformation predicate receives the original call to mypred/1
   as its first argument, and is expected to return a replacement goal
   in its second argument. This replacement goal replaces the original
   call in the compiled code. Usually, the replacement goal would be
   semantically equivalent, but more efficient than the original goal.
   When the transformation predicate fails, the original goal is not
   replaced.

<P>
   If inlining is applied to an exported predicate, one must be aware that
   the replacement goal will be textually substituted for the original
   goal in an unknown module context.  That means that the replacement goal
   should only contain calls to builtins or explicitly qualified calls to
   other exported predicates, since the visibility of predicates generally
   cannot be guaranteed in the module where the substitution takes place.

<P>
   A transformation predicate can have an optional third argument which
   supplies the module in which the substitution takes place.

<P>
   The inline/2 directive must be issued from the definition module
   of Pred, and TransPred must be visible from (and is usually defined
   in) this same module.

<P>
   The transformation predicate for a predicate can be queried by
   calling get_flag(Pred, inline, TransPred).

<P>
   Setting TransPred to =/2 will erase any previously attached
   transformation predicate.

<P>
   Transformation can be disabled for debugging purposes by adding

<P>
<PRE>
    :- pragma(noexpand).
</PRE>
   to the compiled file, or by setting the global flag

<P>
<PRE>
    :- set_flag(goal_expansion, off).
</PRE>
    The global flag also controls whether transformations are applied
    to goals entered at the interactive toplevel prompt.

<P>
"),
	args:["+Pred" : "Expression of the form Atom/Integer.", "+TransPred" : "Expression of the form Atom/Integer, Integer is 2 or 3."],
	resat:"   No.",
	fail_if:"   None.\n\n",
	exceptions:[4 : "Pred or TransPred are not fully instantiated.", 5 : "Pred or TransPred are not of the form Atom/Integer.", 6 : "The arity of TransPred is not 2 or 3.", 100 : "Pred is not defined is this module."],
	eg:"
    :- inline(double/2, trans_double/2).

    double(X, Y) :-
        Y is 2*X.

    trans_double(double(X, Y), Y=Result) :-
        ground(X),           % if X already known at compile time:
        Result is 2*X.       % do calculation at compile time!


    % If we now compile the following predicate involving double/2:

    sample :-
        double(12,Y),        % will be transformed into: Y=24
        ...
        double(Y,Z).         % will be compiled as is




",
	see_also:[macro / 3, get_flag / 2, set_flag / 2, pragma / 1, compile / 1]]).


:- comment(expand_goal / 2, [
	summary:"Apply goal inline expansion to Term",
	template:"expand_goal(+Term, ?TransTerm)",
	desc:html("\
    Applies a goal inline expansion to Term, if any is visible in the
    caller module. If no inline declaration is visible, TransTerm is
    identical to Term.
    <P>
    Normally, goal inline expansion is performed implicitly by the compiler.
    For certain meta-programming applications (e.g. for writing other
    compilers) it can be performed explicitly using expand_goal/2.
"),
	args:["+Term" : "A callable term.",
		"?TransTerm" : "A variable or callable term."],
	resat:"No.",
	fail_if:"None.",
	eg:"
    [eclipse 1]: lib(fd).
    yes.

    [eclipse 5]: expand_goal(X#>Y, G).
    X = X
    Y = Y
    G = fd_arith : fd_gec(X, -1, Y, -1, 0)
    yes.
",
	see_also:[inline/2, portray/3]]).

:- comment(expand_clause / 2, [
	summary:"Apply clause transformation to Term",
	template:"expand_clause(+Term, ?TransTerm)",
	desc:html("\
    Applies a clause-transformation (clause macro) to Term, if any is
    visible in the caller module (see macro/3). If no transformation
    is visible, TransTerm is identical to Term.
    <P>
    Normally, clause expansion is performed implicitly by the compiler.
    For certain meta-programming applications (e.g. for writing other
    compilers) it can be performed explicitly using expand_clause/2.
"),
	args:["+Term" : "A clause term.",
		"?TransTerm" : "A variable or term."],
	resat:"No.",
	fail_if:"None.",
	eg:"
    % A grammar rule is an example of a predefined clause transformation:
    ?- expand_clause((p --> q, [tok]), C).

    C = p(_263, _258) :- q(_263, _278), 'C'(_278, tok, _258)
    yes.
",
	see_also:[macro/3, library(source_processor)]]).



:- comment((discontiguous) / 1, [
	summary:"Declares the procedure(s) specified by SpecList as discontiguous",
	amode:discontiguous(++),
	desc:html("\
   The discontiguous declaration specifies that clauses for the declared
   predicate need not be together (contiguous) in the source file which contains
   them, but can be interleaved with clauses for other predicates. All clauses
   must be in a single file, though.
<P>
   A discontiguous declaration must textually occur in the same file and before
   any clauses for the predicate. Multiple discontiguous declarations for the
   same predicate are silently accepted.
"),
	args:["SpecList" : "term of the form Atom/Integer, or a comma-separated sequence of such terms, or a list of such terms"],
	exceptions:[4 : "SpecList or a component of it is not instantiated.",
		5 : "SpecList is instantiated, but not to a sequence or list of expressions of the form Atom/Integer.",
		65 : "SpecList specifies a predicate which is already defined"],
	eg:"
  [eclipse 1]: [user].
   :- discontiguous(p/1).
   p(a).
   q(1).
   p(b).
  user       compiled traceable 220 bytes in 0.02 seconds
  yes.
",
	see_also:[compile / 1]]).

