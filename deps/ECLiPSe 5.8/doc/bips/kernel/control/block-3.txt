
block(+Goal, ?Tag, +Recovery)

   Similar to call(Goal) if Goal succeeds or fails.  If an exit_block/1 is
executed inside Goal, whose argument unifies with Tag, then Recovery is
executed.



Arguments
   Goal                An atom or a compound term.
   Tag                 An atom, integer, handle or variable.
   Recovery            An atom or a compound term.

Type
   Control

Description
   First Goal is called from the current module and if this succeeds then
   block/3 succeeds.  If Goal fails then so does the call of block/3.  If,
   however, during the execution of Goal there is a call of
   exit_block(TagExit) such that Tag unifies with TagExit, then block/3
   calls the goal Recovery, and succeeds or fails according to whether
   Recovery succeeds or fails.  If Tag does not unify with TagExit, the
   system continues looking for an earlier invocation of block/3.




Resatisfiable
      No.

Fail Conditions
      Fails if Goal fails, or if Recovery fails.



Exceptions
     4 --- Either Goal or Recovery is not instantiated.
     5 --- Goal or Recovery is neither an atom nor a compound term.
     5 --- Tag is instantiated but not to an atom, integer or handle.
    68 --- Either Goal or Recovery is an undefined predicate.

Examples
   
      % success or failure are not affected by the block:
      ?- block(X is 3 + 4, T, writeln(recover(T))).
      X = 7
      T = T
      Yes (0.00s cpu)

      ?- block(8 is 3 + 4, T, writeln(recover(T))).
      No (0.00s cpu)

      % A variable Tag catches all exit_blocks
      ?- block(exit_block(hello), T, writeln(recover(T))).
      recover(hello)
      T = hello
      Yes (0.00s cpu)

      % An instantiated Tag catches only matching exit_blocks
      ?- block(exit_block(hello), hello, writeln(recovered)).
      recovered
      Yes (0.00s cpu)

      ?- block(exit_block(hello), world, writeln(recovered)).
      uncaught exception in exit_block(hello)
      Abort

      % ECLiPSe's error handlers usually execute exit_block(abort)
      % and therefore can be caught with a block:
      ?- block(X is 1//0, T, writeln(recover(T))).
      arithmetic exception in //(1, 0, X)
      recover(abort)
      X = X
      T = abort
      Yes (0.01s cpu)


Error:
      block(go, hello, Recovery).      (Error 4).
      block(Goal, any, thing).         (Error 4).
      block(go, hello(X), problem).    (Error 5).
      block(go, hello, "a").           (Error 5).
      block(nonex, t, write(bye)).     (Error 68).


See Also
   exit_block / 1, abort / 0
