<HTML><HEAD><TITLE>-?-> ?Body</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Control</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>-?-> ?Body</H1>
The matching operator.  The head of the clause which contains it will not
be unified with the caller, one-way matching will be used instead.


<DL>
<DT><EM>?Body</EM></DT>
<DD>Callable term or a variable.
</DD>
</DL>
<H2>Description</H2>
   This operator is used to produce matching clauses, i.e.  clauses whose
   head is unified with the caller only in one direction, namely without
   binding any variables in the caller.  Therefore, only those clause will
   be selected, which are more general than the call, i.e.  the call must
   be an instance of the head.  If the clause head is unifiable with the
   call, but this unification would bind any of the variables in the call,
   the unification fails.

<P>
   -?-&gt; must occur at the beginning of the clause body, directly behind the
   :- symbol, and it must be followed by a non-empty body.  Matching
   clauses with no body must use true/0 after the matching operator.

<P>
   The matching operator can be also used to decompose attributed
   variables.  When an attributed variable occurs in the head of a matching
   clause, it is not unified with the call argument (which would trigger
   the unification handlers) but instead, the call argument is decomposed
   into the variable and its attribute(s):

<P>
<PRE>
    get_attr(X{A}, Attr) :-
	-?-&gt;
	A = Attr.
</PRE>
   This predicate can be used to return the attribute of its argument if it
   is an attributed variable and to fail if it is not.

<P>

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.

</BODY></HTML>
