<HTML><HEAD><TITLE>mutex(+MutexId, +Goal)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Control</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>mutex(+MutexId, +Goal)</H1>
Equivalent to once(Goal) but with mutual exclusion among parallel workers.


<DL>
<DT><EM>+MutexId</EM></DT>
<DD>Atom.
</DD>
<DT><EM>+Goal</EM></DT>
<DD>Atom or compound term.
</DD>
</DL>
<H2>Description</H2>
   This built-in can be used in parallel programs to implement mutual
   exclusion between parallel workers.  A Goal that is called via mutex/2
   can be sure that no parallel worker is executing at the same time any
   goal that is protected by a mutex/2 with the same MutexId.

<P>
   Note that in a side effect free program there is no need ever to worry
   about mutual exclusion.  Only when side effects are involved (e.g.
   read/1,2 and write/1,2, assert/1, setval/2, record/2 etc.)  it may be
   necessary to acquire exclusive access to the common resource by using
   mutex/2.

<P>

<H3>Fail Conditions</H3>
   Fails if Goal fails.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Goal is not instantiated.
<DT><EM>(5) type error </EM>
<DD>Goal is not an atom or a compound term.
</DL>
<H2>Examples</H2>
<PRE>
    :- mutex_init(my_lock).

    atomic_write_list(List) :-
        % make sure the list is printed in one chunk
        mutex(my_lock, write_list(List)).

    write_list([]) :- nl.
    write_list([X|Xs]) :- writeln(X), write_list(Xs).

    [eclipse]: generate_lists_in_parallel(L),
               atomic_write_list(L), fail.



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/control/mutex_init-1.html">mutex_init / 1</A>, <A HREF="../../kernel/control/once-1.html">once / 1</A>
</BODY></HTML>
