<HTML><HEAD><TITLE>fork(+Max, ?I)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Control</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>fork(+Max, ?I)</H1>
Succeeds for all integers I between 1 and Max.  The solutions are generated
in parallel.


<DL>
<DT><EM>Max</EM></DT>
<DD>Integer
</DD>
<DT><EM>I</EM></DT>
<DD>Variable or Integer
</DD>
</DL>
<H2>Description</H2>
   Generates in parallel the integers between 1 and a given maximum Max.
   The order of solutions is unspecified.  For every value of Max, this
   predicate behaves as if defined by

<P>
<PRE>
   :- parallel fork/2.
   fork(Max, Max).
   ...
   fork(Max, 2).
   fork(Max, 1).
</PRE>
   Operationally, the advantage of fork/2 compared to a recursive
   definition like

<P>
<PRE>
   :- parallel bfork/2.
   bfork(Max, Max).
   bfork(Max, I) :- Max&gt;1, Max1 is Max-1, bfork(Max1, I).
</PRE>
   is that fork/2 creates only a single wide choice point instead of Max
   binary ones.  This improves efficiency, especially for parallel
   execution.

<P>

<H3>Fail Conditions</H3>
   Fails if Max is less than 1.


<H3>Resatisfiable</H3>
   Yes.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Max is not instantiated.
<DT><EM>(5) type error </EM>
<DD>Max is not an integer.
</DL>
<H2>Examples</H2>
<PRE>
% peclipse -w 3
[eclipse 1]: fork(5,X), get_flag(worker, W).
X = 5
W = 1     More? (;)
X = 3
W = 3     More? (;)
X = 4
W = 2     More? (;)
X = 2
W = 1     More? (;)
X = 1
W = 3     More? (;)
no (more) solution.



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/arithmetic/between-4.html">between / 4</A>, <A HREF="../../kernel/database/parallel-1.html">parallel / 1</A>, <A HREF="../../kernel/control/repeat-0.html">repeat / 0</A>, <A HREF="../../kernel/env/get_flag-2.html">get_flag / 2</A>
</BODY></HTML>
