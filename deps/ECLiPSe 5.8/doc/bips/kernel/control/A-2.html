<HTML><HEAD><TITLE>Goal @ ContextModule</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Control</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>Goal @ ContextModule</H1>
Goal is executed in the calling context of ContextModule.


<DL>
<DT><EM>+Goal</EM></DT>
<DD>Callable term (atom or compound).
</DD>
<DT><EM>+ContextModule</EM></DT>
<DD>Atom.
</DD>
</DL>
<H2>Description</H2>
   The calling context of a goal is normally the module where the goal is
   called.  @/2 allows to specify this context module explicitly.  This is
   needed when writing meta-predicates (i.e. predicates which have goals or
   predicates as their arguments) or predicates which depend otherwise on
   the module system's visibility rules.
<P>
   @/2 changes only the context module, not the lookup module. I.e. the
   way the definition of Goal is found is not affected at all. To specify
   the lookup module, use :/2. The following table summarises:
<PRE>
	Call within module(m)         lookup module    caller module

	..., twice(X), ...               m               m
	..., lm : twice(X), ...         lm               m
	..., twice(X) @ cm, ...          m              cm
	..., lm : twice(X) @ cm, ...    lm              cm
	..., call(twice(X)) @ cm, ...   cm              cm
</PRE>
   If Goal is not a tool-predicate, then Goal@ContextModule is completely
   equivalent to Goal.

<H3>Fail Conditions</H3>
   Fails if Goal fails.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Goal is not instantiated.
<DT><EM>(5) type error </EM>
<DD>Goal is neither an atom nor a compound term.
<DT><EM>(68) calling an undefined procedure </EM>
<DD>Goal is an undefined procedure in the caller module.
</DL>
<H2>Examples</H2>
<PRE>
    [eclipse 1]: [user].
     :- tool(where/0, where/1).
     where(Module) :-
        printf("where/0 was called from module %w\n",
         [Module]).
    ^D
    [eclipse 2]: where.
    where/0 was called from module eclipse
    yes.
    [eclipse 3]: where @ m.
    where/0 was called from module m
    yes.
    [eclipse 4]: call(where) @ m.
    calling an undefined procedure where in module m
    [eclipse 1]: [user].
     :- tool(print_local_preds/0, print_local_preds/1).
     print_local_preds(Module) :-
            current_predicate(P) @ Module,
            get_flag(P, visibility, local) @ Module,
            writeln(P),
            fail.
    ^D
    [eclipse 2]: print_local_preds.
    print_local_preds / 0
    print_local_preds / 1



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/control/N-2.html">: / 2</A>, <A HREF="../../kernel/control/call-1.html">call / 1</A>, <A HREF="../../kernel/modules/tool-2.html">tool / 2</A>
</BODY></HTML>
