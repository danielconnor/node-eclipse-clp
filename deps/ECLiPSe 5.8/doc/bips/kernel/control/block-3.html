<HTML><HEAD><TITLE>block(+Goal, ?Tag, +Recovery)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Control</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>block(+Goal, ?Tag, +Recovery)</H1>
Similar to call(Goal) if Goal succeeds or fails.  If an exit_block/1 is
executed inside Goal, whose argument unifies with Tag, then Recovery is
executed.


<DL>
<DT><EM>Goal</EM></DT>
<DD>An atom or a compound term.
</DD>
<DT><EM>Tag</EM></DT>
<DD>An atom, integer, handle or variable.
</DD>
<DT><EM>Recovery</EM></DT>
<DD>An atom or a compound term.
</DD>
</DL>
<H3>Calling Modes</H3><UL>
<LI>block(+, +, +)
<LI>block(+, -, +)
</UL>
<H2>Description</H2>
   First Goal is called from the current module and if this succeeds then
   block/3 succeeds.  If Goal fails then so does the call of block/3.  If,
   however, during the execution of Goal there is a call of
   exit_block(TagExit) such that Tag unifies with TagExit, then block/3
   calls the goal Recovery, and succeeds or fails according to whether
   Recovery succeeds or fails.  If Tag does not unify with TagExit, the
   system continues looking for an earlier invocation of block/3.

<P>

<H3>Fail Conditions</H3>
   Fails if Goal fails, or if Recovery fails.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Either Goal or Recovery is not instantiated.
<DT><EM>(5) type error </EM>
<DD>Goal or Recovery is neither an atom nor a compound term.
<DT><EM>(5) type error </EM>
<DD>Tag is instantiated but not to an atom, integer or handle.
<DT><EM>(68) calling an undefined procedure </EM>
<DD>Either Goal or Recovery is an undefined predicate.
</DL>
<H2>Examples</H2>
<PRE>
      % success or failure are not affected by the block:
      ?- block(X is 3 + 4, T, writeln(recover(T))).
      X = 7
      T = T
      Yes (0.00s cpu)

      ?- block(8 is 3 + 4, T, writeln(recover(T))).
      No (0.00s cpu)

      % A variable Tag catches all exit_blocks
      ?- block(exit_block(hello), T, writeln(recover(T))).
      recover(hello)
      T = hello
      Yes (0.00s cpu)

      % An instantiated Tag catches only matching exit_blocks
      ?- block(exit_block(hello), hello, writeln(recovered)).
      recovered
      Yes (0.00s cpu)

      ?- block(exit_block(hello), world, writeln(recovered)).
      uncaught exception in exit_block(hello)
      Abort

      % ECLiPSe's error handlers usually execute exit_block(abort)
      % and therefore can be caught with a block:
      ?- block(X is 1//0, T, writeln(recover(T))).
      arithmetic exception in //(1, 0, X)
      recover(abort)
      X = X
      T = abort
      Yes (0.01s cpu)


Error:
      block(go, hello, Recovery).      (Error 4).
      block(Goal, any, thing).         (Error 4).
      block(go, hello(X), problem).    (Error 5).
      block(go, hello, "a").           (Error 5).
      block(nonex, t, write(bye)).     (Error 68).
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/control/exit_block-1.html">exit_block / 1</A>, <A HREF="../../kernel/control/abort-0.html">abort / 0</A>
</BODY></HTML>
