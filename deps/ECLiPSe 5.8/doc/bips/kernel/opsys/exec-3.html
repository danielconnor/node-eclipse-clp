<HTML><HEAD><TITLE>exec(++Command, +Streams, ?Pid)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Operating System</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>exec(++Command, +Streams, ?Pid)</H1>
A child process Command is forked, its standard streams are connected to
Streams and its process ID is Pid.


<DL>
<DT><EM>Command</EM></DT>
<DD>String, atom or list of atomic terms.
</DD>
<DT><EM>Streams</EM></DT>
<DD>List of stream ids.
</DD>
<DT><EM>Pid</EM></DT>
<DD>Integer or a variable.
</DD>
</DL>
<H2>Description</H2>
   This predicate is used to fork a child process and to set up pipes
   to its standard streams.  After the process is forked, ECLiPSe
   continues normally, without waiting for the child to terminate.

<P>
   Command should be a list with at least one element: The first list element
   (a path name in ECLiPSe path name syntax, atom or string) specifies the
   program to be executed, and the subsequent list elements are its arguments.
   The arguments can be atoms, strings or numbers.  They are passed to the
   executed program literally (in particular, no path name syntax conversion
   is applied).

<P>
   For backward compatibility, Command can be a simple atom or string, in
   which case the first word in Command specifies the program to be executed,
   and the following words (separated by blank space) are its command-line
   arguments.  This form is deprecated since it creates problems with argument
   quoting and operating system dependent path name syntax.

<P>
   By specifying the Streams argument it is possible to control which of
   the process' standard streams are connected to ECLiPSe streams.  The
   form of Streams is [Stdin, Stdout, Stderr].  If some of these streams
   are specified and not null, a pipe is opened which connects the standard
   stream of the child process with the specified ECLiPSe stream, e.g.
   Stdin must be an output stream because it is connected to the standard
   input of the child process.  If the list Streams is shorter, only the
   specified streams are connected with a pipe.  The streams can be
   specified like for open/3.  If the stream is a variable, it is bound to
   the physical stream number, if it is an atom different from null, that
   symbolic stream is used.  Specifying a null stream means that no pipe is
   set up for this stream.

<P>
   Each stream can also be specified as sigio(Stream) (UNIX systems only).
   In this case a pipe is set up to the stream Stream and in addition the
   pipe is instructed to send the signal io each time new data appears in
   it.  In this way the two processes can communicate in a truly
   asynchronous way.  When one process sends data to the other one, the
   interrupt handler is invoked and it can read and process the data.  When
   it finishes, it can continue where it was interrupted.

<P>
   After forking the process, Pid is unified with its process ID, which can
   be used e.g.  in wait/2 or kill/2.  If the exec system call in the child
   process failed, the child exits with status 128 + errno.

<P>

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Command is not instantiated.
<DT><EM>(5) type error </EM>
<DD>Command is instantiated, but not to a string or an atom.
<DT><EM>(5) type error </EM>
<DD>Streams is instantiated, but not to a list.
<DT><EM>(5) type error </EM>
<DD>A stream in Streams is instantiated, but not to an atom or a    sigio structure.
<DT><EM>(5) type error </EM>
<DD>Pid is instantiated.
<DT><EM>(170) system interface error </EM>
<DD>System error, it was not possible to fork the child.
<DT><EM>(192) illegal stream mode </EM>
<DD>The specified stream is not open in the appropriate mode.
</DL>
<H2>Examples</H2>
<PRE>
% execute an ls-command

    ?- exec([ls,"-C"], [null, out], Pid).
    Pid = 10885
    yes.

    ?- read_string(out, end_of_file, _, S), write(S).
    aux.o           coroutine.pl    kegi.pl         sepia.o
    bsi.pl          cprolog.pl      lint.pl         sorts.pl
    cio.pl          history.pl      lists.pl        strings.pl
    cn.pl           k_env.pl        quintus.pl      t_all.pl

    S = "..."

    ?- close(out), wait(Pid, S).
    Pid = 10885
    S = 0
    yes.


% execute another eclipse

    ?- argv(0,Ecl),	% get name of the eclipse executable
       exec([Ecl,"-e","read(X),Y is X*X,printf('%w. %b',[Y])"], [in,out], P).

    E = "/usr/local/eclipse/bin/sparc_sunos5/eclipse.exe"
    P = 10741
    yes.

    [eclipse 2]: printf(in, '%w. %b', [12]), read(out, Result).
    Result = 144
    yes.

    [eclipse 3]: close(in), close(out), wait(10741, S).
    S = 0
    yes.


Error:
      exec(S, [], Pid).          (Error 4).
      exec([ls], null, Pid).       (Error 5).
      exec([chipc], [1], P).       (Error 5).
      exec([date], [input], P).    (Error 192).
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/opsys/exec-2.html">exec / 2</A>, <A HREF="../../kernel/opsys/exec_group-3.html">exec_group / 3</A>, <A HREF="../../kernel/opsys/wait-2.html">wait / 2</A>, <A HREF="../../kernel/opsys/kill-2.html">kill / 2</A>, <A HREF="../../kernel/opsys/sh-1.html">sh / 1</A>, <A HREF="../../kernel/opsys/system-1.html">system / 1</A>, <A HREF="../../kernel/iostream/open-3.html">open / 3</A>
</BODY></HTML>
