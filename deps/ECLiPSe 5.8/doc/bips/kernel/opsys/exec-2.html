<HTML><HEAD><TITLE>exec(++Command, +Streams)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Operating System</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>exec(++Command, +Streams)</H1>
A child process Command is forked, its standard streams are connected to
Streams and the ECLiPSe process waits until it terminates.


<DL>
<DT><EM>Command</EM></DT>
<DD>String, atom or list of atomic terms.
</DD>
<DT><EM>Streams</EM></DT>
<DD>List of stream ids.
</DD>
</DL>
<H2>Description</H2>
   This predicate is used to fork a child process and to set up pipes to
   its standard streams.  After the process is forked, ECLiPSe blocks, i.e.
   it waits until the child process terminates.

<P>
   Command should be a list with at least one element: The first list element
   (a path name in ECLiPSe path name syntax, atom or string) specifies the
   program to be executed, and the subsequent list elements are its arguments.
   The arguments can be atoms, strings or numbers.  They are passed to the
   executed program literally (in particular, no path name syntax conversion
   is applied).

<P>
   For backward compatibility, Command can be a simple atom or string, in
   which case the first word in Command specifies the program to be executed,
   and the following words are its command-line arguments.
   This form is deprecated since it creates problems with argument quoting
   and operating system dependent path name syntax.

<P>
   By specifying the Streams argument it is possible to control which of
   the process' standard streams are connected to ECLiPSe streams.  The
   form of Streams is [Stdin, Stdout, Stderr].  If some of these streams
   are specified and not null, a pipe is opened which connects the standard
   stream of the child process with the specified ECLiPSe stream, e.g.
   Stdin must be an output stream because it is connected to the standard
   input of the child process.  If the list Streams is shorter, only the
   specified streams are connected with a pipe.  The streams can be
   specified like for open/3.  If the stream is a variable, it is bound to
   the physical stream number, if it is an atom different from null, that
   symbolic stream is used.  Specifying a null stream means that no pipe is
   set up for this stream.

<P>
   Each stream can also be specified as sigio(Stream) (UNIX systems only).
   In this case a pipe is set up to the stream Stream and in addition the
   pipe is instructed to send the signal io each time new data appears in
   it.  In this way the two processes can communicate in a truly
   asynchronous way.  When one process sends data to the other one, the
   interrupt handler is invoked and it can read and process the data.  When
   it finishes, it can continue where it was interrupted.

<P>
   exec(Command, Streams) is equivalent to

<P>
   exec(Command, Streams, Pid), wait(Pid, _)

<P>
   exec(Command, []) is very similar to system(Command).

<P>

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Command is not instantiated.
<DT><EM>(5) type error </EM>
<DD>Command is instantiated, but not to a string or an atom.
<DT><EM>(5) type error </EM>
<DD>Streams is instantiated, but not to a list.
<DT><EM>(5) type error </EM>
<DD>A stream in Streams is instantiated, but not to an atom.
<DT><EM>(170) system interface error </EM>
<DD>System error, it was not possible to fork the child or the    exec system call in the child failed.
<DT><EM>(192) illegal stream mode </EM>
<DD>The specified stream is not open in the appropriate mode.
</DL>
<H2>Examples</H2>
<PRE>
Success:
      % exec/2 wait for the child process
      [eclipse]: exec(ls, []), write(end_exec).
      aux.o           coroutine.pl    kegi.pl         sepia.o
      bsi.pl          cprolog.pl      lint.pl         sorts.pl
      cio.pl          history.pl      lists.pl        strings.pl
      cn.pl           k_env.pl        quintus.pl      t_all.pl
      end_exec
      yes.

      % exec/3 return immediately
      [eclipse]: exec(ls, [], Pid), write(end_exec).
      end_exec
      Pid = 16054
      yes.
      [eclipse]: aux.o  coroutine.pl    kegi.pl         sepia.o
      bsi.pl          cprolog.pl      lint.pl         sorts.pl
      cio.pl          history.pl      lists.pl        strings.pl
      cn.pl           k_env.pl        quintus.pl      t_all.pl

Error:
      exec(S, [output]).         (Error 4).
      exec(ls, null).            (Error 5).
      exec(chipc, [f(output)]).  (Error 5).
      exec(date, [input]).       (Error 192).
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/externals/call_c-2.html">call_c / 2</A>, <A HREF="../../kernel/opsys/exec-3.html">exec / 3</A>, <A HREF="../../kernel/opsys/exec_group-3.html">exec_group / 3</A>, <A HREF="../../kernel/opsys/wait-2.html">wait / 2</A>, <A HREF="../../kernel/opsys/kill-2.html">kill / 2</A>, <A HREF="../../kernel/opsys/sh-1.html">sh / 1</A>, <A HREF="../../kernel/opsys/system-1.html">system / 1</A>, <A HREF="../../kernel/iostream/open-3.html">open / 3</A>
</BODY></HTML>
