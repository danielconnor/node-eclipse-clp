<HTML><HEAD><TITLE>[local struct(++Prototype), export struct(++Prototype)]</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Syntax Settings</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>local struct(++Prototype)</H1>
<H1>export struct(++Prototype)</H1>
Declare a structure according to Prototype.
<DL>
<DT><EM>++Prototype</EM></DT>
<DD>A structure with ground arguments.
</DD>
</DL>
<H2>Description</H2>
   ECLiPSe structure notation provides a way to use structures with
   field names rather than positional arguments.  Note that this is
   not a new data type, just a new syntax for normal compound terms. 
   It is intended to make programs more readable and easier to modify,
   without compromising efficiency (it is implemented by macro
   expansion). 
<P>
   E.g. if a structure is declared by specifying the prototype
<PRE>
	book(author, title, year, publisher)
</PRE>
    then subsequently book/4-terms can be written as follows:
<PRE>
	book{}
	book{title:'tom sawyer'}
	book{year:1886, title:'tom sawyer'}
</PRE>
    which will be completely equivalent to the usual
<PRE>
	book(_, _, _, _)
	book(_, 'tom sawyer', _, _)
	book(_, 'tom sawyer', 1886, _)
</PRE>
    The advantage is that the order and position of the fields or the
    arity of the whole structure do not have to be known and can be
    changed by just changing the initial declaration.
<P>
    The argument index of a field in a structure can be obtained using
    a term of the form
<PRE>
	FieldName of StructName
</PRE>
    so instead of arg(3,B,Y) one can write
<PRE>
	arg(year of book, B, Y)
</PRE>
<P>
    The arity of the structure can be obtained using a term of the
    following form
<PRE>
        property(arity) of StructName
</PRE>
    instead of having to explicitly give the arity of the structure.  So, 
<PRE>
        property(arity) of book
</PRE>
    would be equivalent to the integer 4.  Similarly, a Name/Arity
    specification can be obtained by writing
<PRE>
        property(functor) of StructName
</PRE>
    so book/4 can alternatively be written as
<PRE>
        property(functor) of book
</PRE>

<P>
    Structures can also be declared to contain other structures, e.g.
<PRE>
	:- local struct(film(based_on:book,director,year)).
</PRE>
    This allows the fields of book to be accessed as if they were
    fields of film. Note that the declaration of the year-field in
    the film-structure hides the year-field in the book structure.

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Struct is not ground.
<DT><EM>(5) type error </EM>
<DD>Struct is neither variable nor structure.
</DL>
<H2>Examples</H2>
<PRE>
% A simple structure:

    [eclipse 1]: local struct(person(name,address,age)).

    yes.
    [eclipse 2]: John = person{age:30, name:john},
            John = person{age:A},
            arg(name of person, John, N).

    John = person(john, _146, 30)
    A = 30
    N = john
    yes.

    [eclipse 3]: N is (property(arity) of person) + 1.
    N = 4
    yes.

    [eclipse 4]: PersonStructure = (property(functor) of person).
    PersonStructure = person / 3
    yes.

% Example for structure inheritance:

    [eclipse 4]: local struct(employee(p:person,salary)).

    yes.
    [eclipse 5]: Emp = employee{name:john,salary:2000}.

    Emp = employee(person(john, _105, _106), 2000)
    yes.
    
    [eclipse 6]: Emp = employee{name:john, salary:2000},
            Emp = employee{p:Person, salary:S},
            arg(name of employee, Emp, N).

    Person = person(john, _169, _170)
    S = 2000
    Emp = employee(person(john, _169, _170), 2000)
    N = john
    yes.


% Subscript syntax can be used with structures:

    [eclipse 7]: Emp = employee{name:john, salary:2000},
             Cost is 5 * Emp[salary of employee].

     Cost = 10000
     Emp = employee(person(john, _137, _138), 2000)
     yes.
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/modules/local-1.html">local / 1</A>, <A HREF="../../kernel/modules/export-1.html">export / 1</A>, <A HREF="../../kernel/syntax/current_struct-2.html">current_struct / 2</A>, <A HREF="../../kernel/termmanip/arg-3.html">arg / 3</A>, <A HREF="../../kernel/termmanip/subscript-3.html">subscript / 3</A>, <A HREF="../../kernel/termmanip/update_struct-4.html">update_struct / 4</A>
</BODY></HTML>
