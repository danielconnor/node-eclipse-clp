<HTML><HEAD><TITLE>compile_term(+Clause)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Predicate Database and Compiler</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>compile_term(+Clause)</H1>
Compile specified clause or list of clauses Clause.


<DL>
<DT><EM>+Clause</EM></DT>
<DD>A valid Prolog clause, or list of clauses.
</DD>
</DL>
<H2>Description</H2>
   Compiles the specified clause, or list of clauses, similar to
   compilation from a file.  If the clauses are for a predicate that
   was undefined so far, a new static predicate will be created.  If
   the clauses are for an existing static predicate, the new clauses
   will replace the old definition of the predicate.  If the clauses
   are for an existing dynamic predicate, the new clauses will be
   added to the exiting ones for the dynamic predicate.
<P>
   If Clause is a list, the list elements are interpreted as consecutive
   clauses.  Otherwise, Clause will be taken as a single clause.
   Each clause may be a fact or a rule.
<P>
   This predicate works almost as if all the clauses in the list
   were written into a file and this file was then compiled using
   compile/1. It does however not perform any inline expansion on
   the goals in the clause bodies. To do this, explicit preprocessing
   of the clauses is required (e.g. using expand_goal/2). This may
   change in a future release.
<P>
   The difference between compile_term/1 and assert/1 is that
   the predicates for which clauses are compiled are not necessarily
   dynamic with compile_term/1, unless explicitly declared as such.
   Therefore clauses compiled with compile_term/1 usually replace the
   existing ones for the same predicate, moreover their source form is not
   available.  Therefore, it can be used instead of assert/1 if the
   properties of dynamic procedures are not required.
<P>
   Unlike compiling a file, when an event occurs which is not just a
   warning, the following clauses are not compiled, the compilation is
   aborted.
<P>
   See compile/1 for a more complete list of exceptions that can occur
   during compilation.

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Clause is a partial list.
<DT><EM>(5) type error </EM>
<DD>Clause is a list whose tail is neither nil nor a variable.
<DT><EM>(82) trying to access a locked module </EM>
<DD>The module in which the clauses should be compiled is locked.
<DT><EM>(94) trying to redefine an existing imported procedure </EM>
<DD>There is already am imported predicate of the same name.
<DT><EM>(130) syntax error: illegal head </EM>
<DD>The head of a clause is not an atom or a compound term.
<DT><EM>(131) syntax error: illegal goal </EM>
<DD>A subgoal in the body of a clause is not an atom, a compound term or a variable.
<DT><EM>(134) procedure clauses are not consecutive </EM>
<DD>The clauses of a procedure are not consecutive.
<DT><EM>(136) trying to redefine a built-in predicate </EM>
<DD>Trying to redefine a built-in predicate without having declared it.
<DT><EM>(137) trying to redefine a procedure with another type </EM>
<DD>A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.
<DT><EM>(143) compiled query failed </EM>
<DD>One of the clauses was a query and it failed.
</DL>
<H2>Examples</H2>
<PRE>
Success:
   % several facts for different predicates
   ?- compile_term([p(a), p(b), q(1), r("abc")]).

   % a single clause
   ?- compile_term(p(X) :- q(X)).

   % two clauses for the same predicate
   ?- compile_term([p([]), (p([X|Xs]) :- writeln(X), p(Xs))]).

   % a declaration and two clauses
   ?- compile_term([(:- export p/1), p(a), p(b)]).



   % Compile_term/1 can be used for conditional compilation:
   :- (exists('/usr/ucb') -&gt; S = bsd; S = sysV),
      compile_term(os(S)).

   % Even a whole procedure can be conditionally compiled:
   :- os(bsd) -&gt;
    compile_term([
        (pred1(X) :- pred2(X), pred3(X)),
        (pred1(Y) :- ...           )]).


Error:

   compile_term([p|X]).          (Error 4).
   compile_term([a|b]).          (Error 5).
   compile_term([[a]]).          (Error 94).
   compile_term([(p :- write(a)), write(b)]).      (Error 94).
   compile_term("a").          (Error 130).
   compile_term(["a" :- b]).   (Error 130).
   compile_term([p(X) :- 1]).    (Error 131).
   compile_term([a, b, a]).      (Error 134).
   compile_term(!).              (Error 135).
   compile_term(:- var(a)).      (Error 143).
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/database/compile-1.html">compile / 1</A>, <A HREF="../../kernel/database/compile-2.html">compile / 2</A>, <A HREF="../../kernel/database/D-2.html">. / 2</A>, <A HREF="../../kernel/database/compile_stream-1.html">compile_stream / 1</A>, <A HREF="../../kernel/dynamic/assert-1.html">assert / 1</A>, <A HREF="../../kernel/database/expand_goal-2.html">expand_goal / 2</A>, <A HREF="../../kernel/env/set_flag-2.html">set_flag / 2</A>, <A HREF="../../kernel/directives/pragma-1.html">pragma / 1</A>
</BODY></HTML>
