<HTML><HEAD><TITLE>inline(+Pred, +TransPred)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Predicate Database and Compiler</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>inline(+Pred, +TransPred)</H1>
Declares TransPred as the predicate to be used to do compile-time
transformation (e.g. inlining) of calls to Pred.


<DL>
<DT><EM>+Pred</EM></DT>
<DD>Expression of the form Atom/Integer.
</DD>
<DT><EM>+TransPred</EM></DT>
<DD>Expression of the form Atom/Integer, Integer is 2 or 3.
</DD>
</DL>
<H2>Description</H2>
   To improve efficiency, calls to user-defined predicates can be
   preprocessed and transformed at compile time.  The directive

<P>
<PRE>
    :- inline(mypred/1, mytranspred/2).
</PRE>
   arranges for mytranspred/2 to be invoked at compile time for each 
   call to the predicate mypred/1 before it is being compiled.

<P>
   The transformation predicate receives the original call to mypred/1
   as its first argument, and is expected to return a replacement goal
   in its second argument. This replacement goal replaces the original
   call in the compiled code. Usually, the replacement goal would be
   semantically equivalent, but more efficient than the original goal.
   When the transformation predicate fails, the original goal is not
   replaced.

<P>
   If inlining is applied to an exported predicate, one must be aware that
   the replacement goal will be textually substituted for the original
   goal in an unknown module context.  That means that the replacement goal
   should only contain calls to builtins or explicitly qualified calls to
   other exported predicates, since the visibility of predicates generally
   cannot be guaranteed in the module where the substitution takes place.

<P>
   A transformation predicate can have an optional third argument which
   supplies the module in which the substitution takes place.

<P>
   The inline/2 directive must be issued from the definition module
   of Pred, and TransPred must be visible from (and is usually defined
   in) this same module.

<P>
   The transformation predicate for a predicate can be queried by
   calling get_flag(Pred, inline, TransPred).

<P>
   Setting TransPred to =/2 will erase any previously attached
   transformation predicate.

<P>
   Transformation can be disabled for debugging purposes by adding

<P>
<PRE>
    :- pragma(noexpand).
</PRE>
   to the compiled file, or by setting the global flag

<P>
<PRE>
    :- set_flag(goal_expansion, off).
</PRE>
    The global flag also controls whether transformations are applied
    to goals entered at the interactive toplevel prompt.

<P>

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Pred or TransPred are not fully instantiated.
<DT><EM>(5) type error </EM>
<DD>Pred or TransPred are not of the form Atom/Integer.
<DT><EM>(6) out of range </EM>
<DD>The arity of TransPred is not 2 or 3.
<DT><EM>(100) accessing a procedure defined in another module </EM>
<DD>Pred is not defined is this module.
</DL>
<H2>Examples</H2>
<PRE>
    :- inline(double/2, trans_double/2).

    double(X, Y) :-
        Y is 2*X.

    trans_double(double(X, Y), Y=Result) :-
        ground(X),           % if X already known at compile time:
        Result is 2*X.       % do calculation at compile time!


    % If we now compile the following predicate involving double/2:

    sample :-
        double(12,Y),        % will be transformed into: Y=24
        ...
        double(Y,Z).         % will be compiled as is




</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/syntax/macro-3.html">macro / 3</A>, <A HREF="../../kernel/env/get_flag-2.html">get_flag / 2</A>, <A HREF="../../kernel/env/set_flag-2.html">set_flag / 2</A>, <A HREF="../../kernel/directives/pragma-1.html">pragma / 1</A>, <A HREF="../../kernel/database/compile-1.html">compile / 1</A>
</BODY></HTML>
