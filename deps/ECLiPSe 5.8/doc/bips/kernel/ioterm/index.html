<HTML><HEAD><TITLE>Term I/O</TITLE></HEAD><BODY>
[ <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]<H1>Term I/O</H1>
Built-ins for input/output of complex terms
<H2>Predicates</H2>
<BLOCKQUOTE>
<DL>
<DT><A HREF="display-1.html"><STRONG>display(+Term)</STRONG></A></DT>
<DD>Term is displayed on the current output --- without considering operator
definitions.

</DD>
<DT><A HREF="display-2.html"><STRONG>display(+Stream, +Term)</STRONG></A></DT>
<DD>Term is displayed on the output stream Stream --- without considering
operator definitions.

</DD>
<DT><A HREF="expand_macros-2.html"><STRONG>expand_macros(?Term, -TransTerm)</STRONG></A></DT>
<DD>Apply macro transformations to Term</DD>
<DT><A HREF="portray_term-3.html"><STRONG>portray_term(?Term, -TransTerm, +As)</STRONG></A></DT>
<DD>Apply portray (write) transformations to Term</DD>
<DT><A HREF="print-1.html"><STRONG>print(?Term)</STRONG></A></DT>
<DD>The term Term is written on the output stream according to the current
operator declarations, using the predicate portray/2 or portray/1 if it
exists.

</DD>
<DT><A HREF="print-2.html"><STRONG>print(+Stream, ?Term)</STRONG></A></DT>
<DD>The term Term is written on the output stream Stream according to the
current operator declarations, using the predicate portray/2 or portray/1
if it exists.

</DD>
<DT><A HREF="printf-2.html"><STRONG>printf(+Format, ?ArgList)</STRONG></A></DT>
<DD>The arguments in the argument list ArgList are interpreted according to the
Format string and the result is printed to the output stream.

</DD>
<DT><A HREF="printf-3.html"><STRONG>printf(+Stream, +Format, ?ArgList)</STRONG></A></DT>
<DD>The arguments in the argument list ArgList are interpreted according to the
Format string and the result is printed on the output Stream.

</DD>
<DT><A HREF="read-1.html"><STRONG>read(?Term)</STRONG></A></DT>
<DD>Succeeds if the next term from the input stream is successfully read and
unified with Term.

</DD>
<DT><A HREF="read-2.html"><STRONG>read(+Stream, ?Term)</STRONG></A></DT>
<DD>Succeeds if the next term from the input stream Stream is successfully read
and unified with Term.

</DD>
<DT><A HREF="read_exdr-2.html"><STRONG>read_exdr(+Stream, -Term)</STRONG></A></DT>
<DD>A term in EXDR-format is read from the input stream Stream and
converted to the corresponding ECLiPSe term Term.

</DD>
<DT><A HREF="read_term-2.html"><STRONG>read_term(?Term, +Options)</STRONG></A></DT>
<DD>Read a whole term in ECLiPSe syntax from the current input stream, according to Options</DD>
<DT><A HREF="read_term-3.html"><STRONG>read_term(+Stream, ?Term, +Options)</STRONG></A></DT>
<DD>Read a whole term in ECLiPSe syntax from the input stream Stream, according to Options</DD>
<DT><A HREF="readvar-3.html"><STRONG>readvar(+Stream, ?Term, -VarList)</STRONG></A></DT>
<DD>Succeeds if the next Prolog term from the input stream Stream is
successfully read and unified with Term, and any variables in Term are
collected in the list VarList, together with their names.

</DD>
<DT><A HREF="write-1.html"><STRONG>write(?Term)</STRONG></A></DT>
<DD>The term Term is written on output stream according to the current operator
declarations.

</DD>
<DT><A HREF="write-2.html"><STRONG>write(+Stream, ?Term)</STRONG></A></DT>
<DD>The term Term is written on the output stream Stream according to the
current operator declarations.

</DD>
<DT><A HREF="write_canonical-1.html"><STRONG>write_canonical(?Term)</STRONG></A></DT>
<DD>The term Term is written on the stream output in a form that ignores
operator declarations and can be read in.

</DD>
<DT><A HREF="write_canonical-2.html"><STRONG>write_canonical(+Stream, ?Term)</STRONG></A></DT>
<DD>The term Term is written on the output stream Stream in a form that ignores
operator declarations and can be read in.

</DD>
<DT><A HREF="write_exdr-2.html"><STRONG>write_exdr(+Stream, +Term)</STRONG></A></DT>
<DD>The term Term is written onto the output stream Stream in EXDR-format
(a format for communication with agents in other programming languages).

</DD>
<DT><A HREF="write_term-2.html"><STRONG>write_term(?Term, +Options)</STRONG></A></DT>
<DD>The term Term is written to the current output in a format specified by Options</DD>
<DT><A HREF="write_term-3.html"><STRONG>write_term(+Stream, ?Term, +Options)</STRONG></A></DT>
<DD>The term Term is written to the output stream Stream in a format specified by Options</DD>
<DT><A HREF="writeclause-1.html"><STRONG>writeclause(+Clause)</STRONG></A></DT>
<DD>The clause Clause is pretty printed on the current output .

</DD>
<DT><A HREF="writeclause-2.html"><STRONG>writeclause(+Stream, +Clause)</STRONG></A></DT>
<DD>The clause Clause is pretty printed on the output stream Stream .

</DD>
<DT><A HREF="writeln-1.html"><STRONG>writeln(?Term)</STRONG></A></DT>
<DD>The term Term is written on the current output according to the current
operator declarations.  Equivalent to write(Term),nl.

</DD>
<DT><A HREF="writeln-2.html"><STRONG>writeln(+Stream, ?Term)</STRONG></A></DT>
<DD>The term Term is written on the output stream Stream according to the
current operator declarations.  Equivalent to write(Stream,Term),
nl(Stream).

</DD>
<DT><A HREF="writeq-1.html"><STRONG>writeq(?Term)</STRONG></A></DT>
<DD>The term Term is written on the current output in a form that can be read
in.

</DD>
<DT><A HREF="writeq-2.html"><STRONG>writeq(+Stream, ?Term)</STRONG></A></DT>
<DD>The term Term is written on the output stream Stream in a form that can be
read in.

</DD>
</DL>
</BLOCKQUOTE>
<HR>Generated from ioterm.eci on Tue Jan 25 01:58:26 2005

</BODY></HTML>
