<HTML><HEAD><TITLE>bag_enter(+BagHandle, +Term)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Non-logical Variables, Arrays, Bags, Shelves and Stores</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>bag_enter(+BagHandle, +Term)</H1>
Enter a term into an existing bag object
<DL>
<DT><EM>BagHandle</EM></DT>
<DD>A bag
</DD>
<DT><EM>Term</EM></DT>
<DD>An arbitrary term
</DD>
</DL>
<H2>Description</H2>
    	This enters an arbitrary term into a bag object that has previously
	been created with bag_create/1. The order in which terms are entered
	into a bag should not be considered relevant, a bag is conceptually
	unordered. Entering and retrieving terms from a bag involves
	copying the term each time, similar to what happens in setval/getval
	and record/recorded. In particular, if the term contains variables,
	they lose their identity and are replaced with fresh ones.
    
<H3>Fail Conditions</H3>
None
<H3>Resatisfiable</H3>
No
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>BagHandle is not instantiated
<DT><EM>(5) type error </EM>
<DD>BagHandle is not a bag
<DT><EM>(40) stale object handle </EM>
<DD>BagHandle refers to an already destroyed bag
</DL>
<H2>Examples</H2>
<PRE>
    simple_findall(Goal, Solutions) :-
    	bag_create(Bag),
	(
	    call(Goal),
	    bag_enter(Bag, Goal),
	    fail
	;
	    true
	),
	bag_dissolve(Bag, Solutions).
    </PRE>
<H2>See Also</H2>
<A HREF="../../kernel/arrays/bag_create-1.html">bag_create / 1</A>, <A HREF="../../kernel/arrays/bag_count-2.html">bag_count / 2</A>, <A HREF="../../kernel/arrays/bag_abolish-1.html">bag_abolish / 1</A>, <A HREF="../../kernel/arrays/bag_erase-1.html">bag_erase / 1</A>, <A HREF="../../kernel/arrays/bag_retrieve-2.html">bag_retrieve / 2</A>, <A HREF="../../kernel/arrays/bag_dissolve-2.html">bag_dissolve / 2</A>
</BODY></HTML>
