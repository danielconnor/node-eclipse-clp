<HTML><HEAD><TITLE>local store(++Name)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Non-logical Variables, Arrays, Bags, Shelves and Stores</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>local store(++Name)</H1>
Create a named store object which can store indexed data across failures
<DL>
<DT><EM>Name</EM></DT>
<DD>An atom, or an atom/integer structure
</DD>
</DL>
<H2>Description</H2>
    	This creates a 'store' object which provides indexed access to
	key-value pairs, and whose contents are unaffected by backtracking.
<P>
	A store is a persistent (w.r.t. backtracking) hash table. It can
	store arbitrary ECLiPSe terms under arbitrary ground keys.
<P>
	Stores can be referred to either by handle or by name. Whenever
	possible, handles should be used, because this naturally leads to
	robust, reentrant code, and avoids the danger of memory leaks.
	See store_create/1 for how to create stores with a handle.
<P>
	Named stores are identified by a functor. This is usually simply
	an atom, but in general it can be name/arity pair.
<P>
	When named stores are used, the visibility of the store name is
	local to the module where it was created. A named store never
	disappears, therefore, in order to free the associated memory,
	its contents should be erased when no longer needed.
<P>
	Duplicate store declarations are silently ignored.
    
<H3>Fail Conditions</H3>
None
<H3>Resatisfiable</H3>
No
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Name is uninstantiated
<DT><EM>(5) type error </EM>
<DD>Name is neither an atom nor an atom/integer structure
</DL>
<H2>Examples</H2>
<PRE>

    % A store with the simple, atomic name 'phone_numbers'

    :- local store(phone_numbers).

    main1 :-
	store_set(phone_numbers, name(peter,panther), data(1234,mobile)),
	store_set(phone_numbers, name(tom,tiger), data(4567,home)),
	stored_keys_and_values(phone_numbers, Contents),
	writeln(Contents).


    % A store identified by the functor foo/3

    :- local store(foo/3).

    main2 :-
	store_set(foo(_,_,_), key_1, value_1),
	store_set(foo(_,_,_), key_2, value_2),
	stored_keys_and_values(foo(_,_,_), Contents),
	writeln(Contents).
    </PRE>
<H2>See Also</H2>
<A HREF="../../kernel/arrays/current_store-1.html">current_store / 1</A>, <A HREF="../../kernel/arrays/store_create-1.html">store_create / 1</A>, <A HREF="../../kernel/modules/local-1.html">local / 1</A>, <A HREF="../../kernel/arrays/store_set-3.html">store_set / 3</A>, <A HREF="../../kernel/arrays/store_get-3.html">store_get / 3</A>, <A HREF="../../kernel/arrays/store_delete-2.html">store_delete / 2</A>, <A HREF="../../kernel/arrays/store_contains-2.html">store_contains / 2</A>, <A HREF="../../kernel/arrays/stored_keys-2.html">stored_keys / 2</A>, <A HREF="../../kernel/arrays/stored_keys_and_values-2.html">stored_keys_and_values / 2</A>, <A HREF="../../kernel/arrays/store_erase-1.html">store_erase / 1</A>, <A HREF="../../kernel/arrays/store_count-2.html">store_count / 2</A>
</BODY></HTML>
