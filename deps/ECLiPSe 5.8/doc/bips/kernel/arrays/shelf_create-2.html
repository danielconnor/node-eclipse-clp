<HTML><HEAD><TITLE>shelf_create(+InitTerm, -ShelfHandle)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Non-logical Variables, Arrays, Bags, Shelves and Stores</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>shelf_create(+InitTerm, -ShelfHandle)</H1>
Create a shelf object which can store data across failures
<DL>
<DT><EM>InitTerm</EM></DT>
<DD>A compound term
</DD>
<DT><EM>ShelfHandle</EM></DT>
<DD>A free variable
</DD>
</DL>
<H2>Description</H2>
    	This creates a 'shelf' object which can be used to store
	information across failures.  A typical application is counting
	of solutions, keeping track of the best solution, aggregating
	information across multiple solutions etc.
<P>
	A shelf is an object with multiple slots whose contents survive
	backtracking. The content of each slot can be set and retrieved
	individually, or the whole shelf can be retrieved as a term.
<P>
	Shelves are referred to by handle, not by name, so they make
	it easy to write robust, reentrant code. A shelf disappears when
	the system backtracks over its creation, when the shelf handle
	gets garbage collected, or when it is explicitly destroyed.
<P>
	A shelf is initialized from a compound term InitTerm. InitTerm's
	arity determines the number of slots the shelf provides, and
	InitTerm's arguments are used to initialize the corresponding
	shelf slots.
    
<H3>Fail Conditions</H3>
None
<H3>Resatisfiable</H3>
No
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>InitTerm is not instantiated
<DT><EM>(5) type error </EM>
<DD>InitTerm is instantiated but not to a compound term
<DT><EM>(5) type error </EM>
<DD>ShelfHandle is not a variable
</DL>
<H2>Examples</H2>
<PRE>

% a meta-predicate to count the number of solutions to a goal:

    count_solutions(Goal, Total) :-
    	shelf_create(count(0), Shelf),
	(
	    call(Goal),
	    shelf_get(Shelf, 1, Old),
	    New is Old + 1,
	    shelf_set(Shelf, 1, New),
	    fail
	;
	    shelf_get(Shelf, 1, Total)
	),
	shelf_abolish(Shelf).


% finding the sum and maximum of data/1 facts:

    data(2).
    data(9).
    data(3).
    data(5).
    data(7).

    sum_and_max(Sum, Max) :-
    	shelf_create(agg(0,0), Shelf),
	(
	    data(X),
	    shelf_get(Shelf, 1, OldMax),
	    ( X &gt; OldMax -&gt; shelf_set(Shelf, 1, X) ; true ),
	    shelf_get(Shelf, 2, OldSum),
	    NewSum is OldSum + X,
	    shelf_set(Shelf, 2, NewSum),
	    fail
	;
	    shelf_get(Shelf, 0, agg(Max, Sum))
	),
	shelf_abolish(Shelf).


% if-then-else with backtracking over the condition:

    if(Cond, Then, Else) :-
	shelf_create(sol(no), SolFlag),
	(
	    call(Cond),
	    shelf_set(SolFlag, 1, yes),   % remember there was a solution
	    call(Then)
	;
	    shelf_get(SolFlag, 1, no),    % fail if there was a solution
	    call(Else)
	).
    </PRE>
<H2>See Also</H2>
<A HREF="../../kernel/arrays/shelf_create-3.html">shelf_create / 3</A>, <A HREF="../../kernel/arrays/shelf_set-3.html">shelf_set / 3</A>, <A HREF="../../kernel/arrays/shelf_get-3.html">shelf_get / 3</A>, <A HREF="../../kernel/arrays/shelf_abolish-1.html">shelf_abolish / 1</A>, <A HREF="../../kernel/arrays/array-1.html">array / 1</A>, <A HREF="../../kernel/arrays/bag_create-1.html">bag_create / 1</A>
</BODY></HTML>
