<HTML><HEAD><TITLE>bag_create(-BagHandle)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Non-logical Variables, Arrays, Bags, Shelves and Stores</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>bag_create(-BagHandle)</H1>
Create a bag object which can store data across failures
<DL>
<DT><EM>BagHandle</EM></DT>
<DD>A free variable
</DD>
</DL>
<H2>Description</H2>
    	This creates an anonymous bag object which can be used to store
	information across failures.  A typical application is the
	implementation of the findall/3 predicate or similar functionality.
	Bags are similar to records, with two differences: First, a bag
	is considered unordered, so one should not expect the bag content
	to indicate the order in which information was entered.
	Second, bags are referred to by handle, not by name, so they make
	it much easier to write robust, reentrant code.
    
<H3>Fail Conditions</H3>
None
<H3>Resatisfiable</H3>
No
<H3>Exceptions</H3>
<DL>
<DT><EM>(5) type error </EM>
<DD>BagHandle is not a variable
</DL>
<H2>Examples</H2>
<PRE>
    simple_findall(Goal, Solutions) :-
    	bag_create(Bag),
	(
	    call(Goal),
	    bag_enter(Bag, Goal),
	    fail
	;
	    true
	),
	bag_dissolve(Bag, Solutions).
    </PRE>
<H2>See Also</H2>
<A HREF="../../kernel/arrays/bag_erase-1.html">bag_erase / 1</A>, <A HREF="../../kernel/arrays/bag_enter-2.html">bag_enter / 2</A>, <A HREF="../../kernel/arrays/bag_count-2.html">bag_count / 2</A>, <A HREF="../../kernel/arrays/bag_dissolve-2.html">bag_dissolve / 2</A>, <A HREF="../../kernel/arrays/bag_retrieve-2.html">bag_retrieve / 2</A>, <A HREF="../../kernel/arrays/bag_abolish-1.html">bag_abolish / 1</A>
</BODY></HTML>
