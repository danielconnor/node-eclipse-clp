<HTML><HEAD><TITLE>error(+EventId, ?Culprit)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Event Handling</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>error(+EventId, ?Culprit)</H1>
An error or event EventId is raised and the corresponding error handler is executed
<DL>
<DT><EM>+EventId</EM></DT>
<DD>Atom, integer or structure with functor default/1.
</DD>
<DT><EM>?Culprit</EM></DT>
<DD>Prolog term.
</DD>
</DL>
<H2>Description</H2>
   The event or error EventId with Culprit as its culprit goal is raised.
   EventId is either an integer error number, or an atomic event name.
   The error handler which is associated with EventId is invoked,
   with its first argument set to EventId, its second argument to Culprit,
   and its third argument and fourth argument are the context module in
   which error/2 is invoked. If the handler has less than four arguments,
   the extra information is lost.
<P>
   This simulates an occurrence of the error EventId inside a call
   to Culprit.  The valid error numbers are those returned by
   current_error/1.  Event names can be any atom as long as an event handler
   has been defined for them.
<P>
   If EventId is a structure with functor default/1, the structure's argument
   is taken as the error number and the default handler is executed, even
   if the error handler has been redefined using set_event_handler/2.
   This is useful for writing user error handlers.
<P>
   If the event handler succeeds, possibly binding some variables
   inside Culprit, then error/2 succeeds as well. If the handler fails
   or calls exit_block/1, then so does error/2.

<H3>Fail Conditions</H3>
   Fails if the handler fails.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>EventId is not instantiated.
<DT><EM>(5) type error </EM>
<DD>EventId is not an error specification.
<DT><EM>(6) out of range </EM>
<DD>EventId is a number but not a valid error number.
<DT><EM>(32) no handler for event </EM>
<DD>No handler is associated to EventId
</DL>
<H2>Examples</H2>
<PRE>
Success:

   % Writing a predicate with type checking
    ?- [user].
     is_positive(N) :-
            number(N),
            !,
            N &gt;= 0.
     is_positive(N) :-
            error(5, is_positive(N)).
     user compiled 244 bytes in 0.02 seconds
    yes.

    ?- is_positive(a).
    type error in is_positive(a)

   % changing the behaviour of a built-in by redefining a handler
    ?- //(1,0,X).       % change this behaviour
    arithmetic exception in //(1, 0, X)

    ?- [user].        % define the new handler
     my_handler(_, //(_,_,Result)) :-
            !,
            Result = infinity.
     my_handler(Err, Goal) :-
            error(default(Err), Goal).
     user compiled 212 bytes in 0.00 seconds
    yes.

    ?- set_event_handler(20, my_handler/2).
    yes.

    ?- //(1,0,X).      % check if it works
    X = infinity
    yes.

    ?- sqrt(-1,X).   % other culprits: as before
    arithmetic exception in sqrt(-1, _g36)

Error:
      error(N,dummy(1)).    (Error 4).
      error(5.0,dummy(1)).  (Error 5).
      error(-2,dummy(1)).   (Error 6).



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/event/error-3.html">error / 3</A>, <A HREF="../../kernel/event/event-1.html">event / 1</A>, <A HREF="../../kernel/event/current_error-1.html">current_error / 1</A>, <A HREF="../../kernel/event/error_id-2.html">error_id / 2</A>, <A HREF="../../kernel/event/get_event_handler-3.html">get_event_handler / 3</A>, <A HREF="../../kernel/event/reset_event_handler-1.html">reset_event_handler / 1</A>, <A HREF="../../kernel/event/reset_error_handlers-0.html">reset_error_handlers / 0</A>, <A HREF="../../kernel/event/set_event_handler-2.html">set_event_handler / 2</A>
</BODY></HTML>
