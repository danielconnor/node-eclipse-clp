<HTML><HEAD><TITLE>events_defer</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Event Handling</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>events_defer</H1>
Defer event handling
<H2>Description</H2>
<P>    	Defer event handling until a subsequent call to events_nodefer/0.
	The purpose of this feature is to
	<UL>
	    <LI>sequence event handlers so they don't interrupt each other</LI>
	    <LI>protect accesses to global data structures from being interrupted
		or preempted by events.</LI>
	</UL>
	Events whose handling will be deferred are:
	<UL>
	    <LI>events raised by the builtin event/1</LI>
	    <LI>events posted from external code using ec_post_event()</LI>
	    <LI>events raised by interrupts whose handler is event/1</LI>
	</UL>
	Events that are raised while event handling is deferred will be
	queued and handled later.
    </P><P>
	Event handling is also automatically deferred when entering the
	event handlers of events that have the defer-property set (see
	event_create/3 and set_event_handler/2).
    </P><P>
    	The predicate fails (and has no further effect) if event handling
	is already deferred. This feature should be used to make sure that
	event handling is not accidentally reenabled in a nested situation.
	E.g.
	<PRE>
	    ...,
	    ( events_defer ->
	        &lt;manipulate protected data&gt;
		events_nodefer
	    ;
		% events already deferred
	        &lt;manipulate protected data&gt;
	    ),
	    ...
	</PRE>

    </P><P>
	CAUTION: events_defer/0 is a low-level primitive that must be
	used with great care. Part of ECLiPSe's functionality (e.g. timeout,
	branch-and-bound) relies on event handling and will not work
	properly while event handling is deferred. Deferring and undeferring
	events are nonlogical operations which are not undone on backtracking.
	The programmer must therefore make sure that every time event handling
	is deferred, it is eventually reenabled by a call to events_nodefer/0,
	even in case of failure or abort in the deferred code sequence.
    </P>
    
<H3>Fail Conditions</H3>
Fails iff event handling is already deferred
<H2>Examples</H2>
<PRE>    ?- event_create(writeln(hello), [], E),
	    event(E),
	    writeln(deferring),
	    events_defer,
	    event(E),
	    writeln(nodeferring),
	    events_nodefer.
    hello
    deferring
    nodeferring
    hello
    </PRE>
<H2>See Also</H2>
<A HREF="../../kernel/event/event_create-3.html">event_create / 3</A>, <A HREF="../../kernel/event/event-1.html">event / 1</A>, <A HREF="../../kernel/event/events_nodefer-0.html">events_nodefer / 0</A>, <A HREF="../../kernel/event/set_event_handler-2.html">set_event_handler / 2</A>
</BODY></HTML>
