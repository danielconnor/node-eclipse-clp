<HTML><HEAD><TITLE>?Result is +Expression</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Arithmetic</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>?Result is +Expression</H1>
Evaluates the arithmetic expression Expression and unifies the resulting
value with Result.


<DL>
<DT><EM>?Result</EM></DT>
<DD>A variable or a number.
</DD>
<DT><EM>+Expression</EM></DT>
<DD>An arithmetic expression.
</DD>
</DL>
<H2>Description</H2>
   is/2 is used to evaluate arithmetic expressions.  An arithmetic
   expression is a Prolog term that is made up of variables, numbers,
   atoms and compound terms.  If it contains variables, they must be
   bound to numbers at the time the evaluation takes place.
<P>
   ECLiPSe distinguishes four types of numbers:
<DL>
    <DT><STRONG>integers</STRONG> e.g. 12345
	<DD>Integers can be of arbitrary magnitude. Integers that fit
	into the word size of the machine are handled more efficiently.
    <DT><STRONG>rationals</STRONG> e.g. 3_4
    	<DD>Rational numbers represent the corresponding mathematical
	notion (the ratio of two integers). The operations defined on
	rationals give precise (rational) results.
    <DT><STRONG>floats</STRONG> e.g. 3.1415
	<DD>Floats are an imprecise approximation of real numbers. 
	They are represented as IEEE double precision floats.  Floating
	point operations are typically subject to rounding errors. 
	Undefined operations produce infinity results if possible,
	otherwise exceptions (not NaNs).
    <DT><STRONG>bounded reals (breal)</STRONG> e.g. 3.1415__3.1416
    	<DD>Bounded reals are a safe representation of real numbers,
	characterised by a lower and upper bound in floating point format.
	Operations on breals are safe in the sense that the resulting
	bounds always enclose the precise result (interval arithmetic).
</DL>
   Numbers of different types do not unify.  To help bug detection,
   the arithmetic predicates raise events when an attempt is made to
   unify numbers of different types.
<P>
   The system performs automatic type conversions in the direction
<BLOCKQUOTE>
    integer -&gt; rational -&gt; float -&gt; breal.
</BLOCKQUOTE>
   These conversions are done (i) to make the types of two input
   arguments equal and (ii) to lift the type of an input argument to
   the one expected by the function.  The result type is the lifted
   input type, unless otherwise specified.
<P>
   A table of predefined arithmetic functions is given below.  A predefined
   function is evaluated by first evaluating its arguments and then calling
   the corresponding evaluation predicate.  The evaluation predicate
   belonging to a compound term func(a_1,..,a_n) is the predicate
   func/(n+1).  It receives a_1,..,a_n as its first n arguments and returns
   a numeric result as its last argument.  This result is then used in
   the arithmetic computation.
<P>
   This evaluation mechanism outlined above is not restricted to the
   predefined arithmetic functors shown in the table.  In fact it works for
   all atoms and compound terms.  It is therefore possible to define a new
   arithmetic operation by just defining an evaluation predicate.
   Similarly, many ECLiPSe built-ins return numbers in the last argument
   and can thus be used as evaluation predicates (e.g.cputime/1, random/1,
   string_length/2, ...).  Note that recursive evaluation of arguments is
   only done for the predefined arithmetic functions, for the others the
   arguments are simply passed to the evaluation predicate.
<P>
   Most arithmetic errors will not be reported in is/2, but in the
   evaluation predicate where it occurred.
<PRE>
    Function       Description                Argument Types       Result Type
   ----------------------------------------------------------------------------
    + E            unary plus                 number               number
    - E            unary minus                number               number
    abs(E)         absolute value             number               number
    sgn(E)         sign value                 number               integer
    floor(E)       round down                 number               number
    ceiling(E)     round up                   number               number
    round(E)       round to nearest           number               number

    E1 + E2        addition                   number x number      number
    E1 - E2        subtraction                number x number      number
    E1 * E2        multiplication             number x number      number
    E1 / E2        division                   number x number      see below
    E1 // E2       integer division           integer x integer    integer
    E1 mod E2      modulus operation          integer x integer    integer
    gcd(E1,E2)     greatest common divisor    integer x integer    integer
    lcm(E1,E2)     least common multiple      integer x integer    integer
    E1 ^ E2        power operation            number x number      number
    min(E1,E2)     minimum of 2 values        number x number      number
    max(E1,E2)     maximum of 2 values        number x number      number

    \ E            bitwise complement         integer              integer
    E1 /\ E2       bitwise conjunction        integer x integer    integer
    E1 \/ E2       bitwise disjunction        integer x integer    integer
    xor(E1,E2)     bitwise exclusive or       integer x integer    integer
    E1 &gt;&gt; E2       shift E1 right by E2 bits  integer x integer    integer
    E1 &lt;&lt; E2       shift E1 left by E2 bits   integer x integer    integer
    setbit(E1,E2)  set bit E2 in E1           integer x integer    integer
    clrbit(E1,E2)  clear bit E2 in E1         integer x integer    integer
    getbit(E1,E2)  get of bit E2 in E1        integer x integer    integer

    sin(E)         trigonometric function     number               float or breal
    cos(E)         trigonometric function     number               float or breal
    tan(E)         trigonometric function     number               float or breal
    asin(E)        trigonometric function     number               float
    acos(E)        trigonometric function     number               float
    atan(E)        trigonometric function     number               float or breal
    exp(E)         exponential function ex    number               float or breal
    ln(E)          natural logarithm          number               float or breal
    sqrt(E)        square root                number               float or breal
    pi             the constant pi            ---                  float
    e              the constant e             ---                  float

    fix(E)         truncate to integer        number               integer
    float(E)       convert to float           number               float
    rational(E)    convert to rational        number               rational
    rationalize(E) convert to rational        number               rational
    numerator(E)   numerator of rational      integer or rational  integer
    denominator(E) denominator of rational    integer or rational  integer
    breal(E)       convert to bounded real    number               breal
    breal_from_bounds(Lo, Hi)
                   make bounded real from bounds  number x number  breal
    breal_min(E)   lower bound of bounded real    number           float
    breal_max(E)   upper bound of bounded real    number           float

    sum(Es)        sum of list elements       list                 number
    min(Es)        minimum of list elements   list                 number
    max(Es)        maximum of list elements   list                 number
    eval(E)        eval runtime expression    term                 number
</PRE>
   The division operator / yields either a rational or a float result,
   depending on the value of the global flag prefer_rationals.  The same is
   true for the result of ^ if an integer is raised to a negative integral
   power.  The relation between integer division // and modulus operation
   mod is as follows:
<PRE>
    X =:= (X mod Y) + (X // Y) * Y.
</PRE>

<H3>Fail Conditions</H3>
   Fails if the result of the evaluation does not unify with Result or if a
   user-defined evaluation predicate fails.


<H3>Resatisfiable</H3>
   No
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Expression is uninstantiated
<DT><EM>(5) type error </EM>
<DD>Result is neither a number nor a variable.
<DT><EM>(5) type error </EM>
<DD>Evaluation of Expression gives a different type than Result.
<DT><EM>(21) undefined arithmetic expression </EM>
<DD>An evaluation predicate in the expression is not defined.
<DT><EM>(24) number expected </EM>
<DD>Expression is not a valid arithmetic expression.
</DL>
<H2>Examples</H2>
<PRE>
   Success:
     103 is 3 + 4 * 5 ^ 2.
     X is asin(sin(pi/4)).            (gives X = 0.785398).
     Y is 2 * 3, X is 4 + Y.          (gives X = 10, Y = 6).
     X is string_length("four") + 1.  (gives X = 5).

     [eclipse]: [user].
      myconst(4.56).
      user compiled 40 bytes in 0.02 seconds
     yes.
     [eclipse]: 5.56 is myconst + 1.
     yes.
Fail:
     3.14 is pi.                    % different values
Error:
     X is _.                        (Error 4)
     atom is 4.                     (Error 5)
     1 is 1.0.                      (Error 5)
     X is "s".                      (Error 24)

     [eclipse]: X is undef(1).
     calling an undefined procedure undef(1, _g63) in ...

     [eclipse]: X is 3 + Y.
     instantiation fault in +(3, _g45, _g53)



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/env/get_flag-2.html">get_flag / 2</A>, <A HREF="../../kernel/database/set_flag-3.html">set_flag / 3</A>, <A HREF="../../kernel/arithmetic/P-2.html">+ / 2</A>, <A HREF="../../kernel/arithmetic/--2.html">- / 2</A>, <A HREF="../../kernel/arithmetic/abs-2.html">abs / 2</A>, <A HREF="../../kernel/arithmetic/sgn-2.html">sgn / 2</A>, <A HREF="../../kernel/arithmetic/ceiling-2.html">ceiling / 2</A>, <A HREF="../../kernel/arithmetic/floor-2.html">floor / 2</A>, <A HREF="../../kernel/arithmetic/round-2.html">round / 2</A>, <A HREF="../../kernel/arithmetic/P-3.html">+ / 3</A>, <A HREF="../../kernel/arithmetic/--3.html">- / 3</A>, <A HREF="../../kernel/arithmetic/X-3.html">* / 3</A>, <A HREF="../../kernel/arithmetic/F-3.html">/ / 3</A>, <A HREF="../../kernel/arithmetic/FF-3.html">// / 3</A>, <A HREF="../../kernel/arithmetic/mod-3.html">mod / 3</A>, <A HREF="../../kernel/arithmetic/U-3.html">^ / 3</A>, <A HREF="../../kernel/arithmetic/min-3.html">min / 3</A>, <A HREF="../../kernel/arithmetic/max-3.html">max / 3</A>, <A HREF="../../kernel/arithmetic/gcd-3.html">gcd / 3</A>, <A HREF="../../kernel/arithmetic/lcm-3.html">lcm / 3</A>, <A HREF="../../kernel/arithmetic/R-2.html">\ / 2</A>, <A HREF="../../kernel/arithmetic/FR-3.html">/\ / 3</A>, <A HREF="../../kernel/arithmetic/RF-3.html">\/ / 3</A>, <A HREF="../../kernel/arithmetic/xor-3.html">xor / 3</A>, <A HREF="../../kernel/arithmetic/GG-3.html">>> / 3</A>, <A HREF="../../kernel/arithmetic/LL-3.html"><< / 3</A>, <A HREF="../../kernel/arithmetic/clrbit-3.html">clrbit / 3</A>, <A HREF="../../kernel/arithmetic/getbit-3.html">getbit / 3</A>, <A HREF="../../kernel/arithmetic/setbit-3.html">setbit / 3</A>, <A HREF="../../kernel/arithmetic/sin-2.html">sin / 2</A>, <A HREF="../../kernel/arithmetic/cos-2.html">cos / 2</A>, <A HREF="../../kernel/arithmetic/tan-2.html">tan / 2</A>, <A HREF="../../kernel/arithmetic/asin-2.html">asin / 2</A>, <A HREF="../../kernel/arithmetic/acos-2.html">acos / 2</A>, <A HREF="../../kernel/arithmetic/atan-2.html">atan / 2</A>, <A HREF="../../kernel/arithmetic/exp-2.html">exp / 2</A>, <A HREF="../../kernel/arithmetic/ln-2.html">ln / 2</A>, <A HREF="../../kernel/arithmetic/sqrt-2.html">sqrt / 2</A>, <A HREF="../../kernel/arithmetic/fix-2.html">fix / 2</A>, <A HREF="../../kernel/arithmetic/float-2.html">float / 2</A>, <A HREF="../../kernel/arithmetic/rational-2.html">rational / 2</A>, <A HREF="../../kernel/arithmetic/rationalize-2.html">rationalize / 2</A>, <A HREF="../../kernel/arithmetic/numerator-2.html">numerator / 2</A>, <A HREF="../../kernel/arithmetic/denominator-2.html">denominator / 2</A>, <A HREF="../../kernel/arithmetic/breal-2.html">breal / 2</A>, <A HREF="../../kernel/arithmetic/breal_from_bounds-3.html">breal_from_bounds / 3</A>, <A HREF="../../kernel/arithmetic/breal_min-2.html">breal_min / 2</A>, <A HREF="../../kernel/arithmetic/breal_max-2.html">breal_max / 2</A>, <A HREF="../../kernel/arithmetic/sum-2.html">sum / 2</A>, <A HREF="../../kernel/arithmetic/min-2.html">min / 2</A>, <A HREF="../../kernel/arithmetic/max-2.html">max / 2</A>, <A HREF="../../kernel/arithmetic/eval-2.html">eval / 2</A>, <A HREF="../../kernel/typetest/integer-1.html">integer / 1</A>, <A HREF="../../kernel/typetest/float-1.html">float / 1</A>, <A HREF="../../kernel/typetest/rational-1.html">rational / 1</A>, <A HREF="../../kernel/typetest/breal-1.html">breal / 1</A>, <A HREF="../../kernel/typetest/number-1.html">number / 1</A>
</BODY></HTML>
