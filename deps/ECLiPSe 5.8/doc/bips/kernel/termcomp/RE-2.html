<HTML><HEAD><TITLE>?Term1 \= ?Term2</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>?Term1 \= ?Term2</H1>
Succeeds if Term1 and Term2 are not unifiable.


<DL>
<DT><EM>?Term1</EM></DT>
<DD>An arbitrary term.
</DD>
<DT><EM>?Term2</EM></DT>
<DD>An arbitrary term.
</DD>
</DL>
<H2>Description</H2>
   Succeeds if Term1 and Term2 are not unifiable.  It is implemented like

<P>
<PRE>
    X \= X :- true, !, fail.
    _ \= _.
</PRE>
   I.e. the arguments are unified, which may cause delayed goals to be
   woken and constraints to be checked.  Only if all this succeeds, \=/2
   fails.

<P>
   This predicate has a negation-as-failure semantics and so if the
   compared terms are not ground, it may give unexpected results.  Note
   that the original arguments are unchanged after the predicate succeeds.

<P>

<H3>Fail Conditions</H3>
   Fails if Term1 and Term2 can be unified.


<H3>Resatisfiable</H3>
   No.
<H2>Examples</H2>
<PRE>
Success:
   atom \= neutron.
   1.0 \= 1.
   f(1,2) \= f(1,3).
   [1,2] \= [1,3].
   [a,b,c] \= [a,b|c].
   [a,b,c] \= [X].
   [a,X,c,Y] \= [X,b,Y,d].
   coroutine, X &gt; 1, X \= 1.
Fail:
   X \= Y.
   1 \= X.
   [a,b|X] \= X.



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/E-2.html">= / 2</A>, <A HREF="../../kernel/termcomp/REE-2.html">\== / 2</A>, <A HREF="../../kernel/termcomp/not_unify-2.html">not_unify / 2</A>
</BODY></HTML>
