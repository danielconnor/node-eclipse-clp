<HTML><HEAD><TITLE>sort(+List1, ?List2)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>sort(+List1, ?List2)</H1>
Succeeds if List2 is the strictly ordered, no duplicates version of List1.


<DL>
<DT><EM>+List1</EM></DT>
<DD>List.
</DD>
<DT><EM>?List2</EM></DT>
<DD>List or variable.
</DD>
</DL>
<H2>Description</H2>
   List1 is sorted strictly according to standard term ordering
   (removing duplicates in the sense of ==/2), and unified with List2.
<P>
   The sort is done according to the standard ordering of terms.
   See compare/3 for this standard ordering.
   Note in particular that numbers are first ordered by their type (integer,
   float, etc) and only then by their magnitude, i.e. sorting numbers of
   different types may not give the expected result.
<P>
Note
   sort(L1,L2) is equivalent to sort(0,&lt;,L1,L2).
   sort(L1,L2) differs from msort(L1,L2) in that it removes duplicates.

<H3>Fail Conditions</H3>
   Fails if List2 does not unify with the sorted list version of List1.


<H3>Resatisfiable</H3>
   No.
<H2>Examples</H2>
<PRE>
Success:
      sort([3,1,6,7,2],S).     (gives S=[1,2,3,6,7]).
      sort([1,3,2,3,4,1],S).   (gives S=[1,2,3,4]).
      sort([f(1,3),h(2,1)],S). (gives S=[f(1,3),h(2,1)]).
      sort(["b",2.0,a(1),1,a],S).
                            (gives S=[2.0,1,"b",a,a(1)]).
Fail:
      sort([2,1,3,4],[2,1,3,4]).



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/compare-3.html">compare / 3</A>, <A HREF="../../kernel/termcomp/msort-2.html">msort / 2</A>, <A HREF="../../kernel/termcomp/sort-4.html">sort / 4</A>
</BODY></HTML>
