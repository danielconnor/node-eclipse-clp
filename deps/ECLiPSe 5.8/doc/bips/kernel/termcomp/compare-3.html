<HTML><HEAD><TITLE>compare(?Ordering, ?Term1, ?Term2)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>compare(?Ordering, ?Term1, ?Term2)</H1>
Succeeds if Ordering is a special atom which describes the ordering between
Term1 and Term2.


<DL>
<DT><EM>?Ordering</EM></DT>
<DD>Unifiable to a special atom describing the ordering between                Term1 and Term2.
</DD>
<DT><EM>?Term1</EM></DT>
<DD>An arbitrary term.
</DD>
<DT><EM>?Term2</EM></DT>
<DD>An arbitrary term.
</DD>
</DL>
<H2>Description</H2>
   Succeeds if Ordering is one of the special atoms ('&lt;', '&gt;' or '=')
   describing the standard ordering between the terms Term1 and Term2:

<P>
   Ordering is the atom '&lt;' iff Term1 comes before Term2 in the standard
   ordering.

<P>
   Ordering is the atom '&gt;' iff Term1 comes after Term2 in the standard
   ordering.

<P>
   Ordering is the atom '=' iff Term1 is identical to Term2.

<P>
   The standard ordering of ECLiPSe terms is defined as the following
   increasing order:
<DL>
<DT><STRONG>variables</STRONG><DD>
    (comparing two free variables yields an implementation-dependent
    and not necessarily reproducible result).

<DT><STRONG>bounded reals</STRONG><DD>
    in ascending order (if bounds overlap, the order is by increasing lower
    bounds, then increasing upper bounds; if both bounds are the same, the
    two terms are considered equal).

<DT><STRONG>floats</STRONG><DD>
    in ascending order, with negative zeros (-0.0) being different and
    before positive zeros (0.0).

<DT><STRONG>rationals</STRONG><DD>
    in ascending order.

<DT><STRONG>integers</STRONG><DD>
    in ascending order.

<DT><STRONG>strings</STRONG><DD>
    lexicographical (ASCII) order

<DT><STRONG>atoms</STRONG><DD>
    lexicographical (ASCII) order

<DT><STRONG>compound terms</STRONG><DD>
    first by arity, then by functor name, then by the
    arguments in left to right order.
</DL>

   Note in particular that numbers are first ordered by their type (integer,
   float, etc) and only then by their magnitude, i.e. when comparing numbers
   of different types, the result is not necessarily their numerical order.

<H3>Fail Conditions</H3>
   Fails if Ordering does not match the standard ordering between Term1 and
   Term2.


<H3>Resatisfiable</H3>
   No.
<H2>Examples</H2>
<PRE>
   Success:
   compare(X, A, a), X = '&lt;'.
   compare(X, a, A), X = '&gt;'.
   compare('&lt;', a(1,2), b(1,2)).
   compare(X, 1, 1), X = '='.
   compare(X, f(1), f(1)), X = '='.
   compare('&lt;', 3.0, 2).              % not arithmetic order!
   compare('&gt;', [a,b], [a|b]).
   compare('&gt;', [a,b], [a|X]).
   Fail:
   compare('&lt;', atomb, atoma).
   compare('=', 0, 1).
   compare('&gt;',1.0,1).



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/AG-2.html">@> / 2</A>, <A HREF="../../kernel/termcomp/AL-2.html">@< / 2</A>, <A HREF="../../kernel/termcomp/AEL-2.html">@=< / 2</A>, <A HREF="../../kernel/termcomp/AGE-2.html">@>= / 2</A>
</BODY></HTML>
