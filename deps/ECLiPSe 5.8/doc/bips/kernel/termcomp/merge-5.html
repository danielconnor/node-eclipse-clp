<HTML><HEAD><TITLE>merge(+Key, +Order, +List1, +List2, ?List3)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>merge(+Key, +Order, +List1, +List2, ?List3)</H1>
Succeeds if List3 is a merged list of List1 and List2.  If both lists are
sorted, List3 will be sorted.  The sort is done according to the Key and
Order specifications.


<DL>
<DT><EM>+Key</EM></DT>
<DD>A non-negative integer or a list of positive integers.
</DD>
<DT><EM>+Order</EM></DT>
<DD>One of the atoms =&lt;, &gt;=, &lt; or &gt;.
</DD>
<DT><EM>+List1</EM></DT>
<DD>List.
</DD>
<DT><EM>+List2</EM></DT>
<DD>List.
</DD>
<DT><EM>?List3</EM></DT>
<DD>List or variable.
</DD>
</DL>
<H2>Description</H2>
   Used to merge the sorted lists List1 and List2 to give the sorted list
   List3.

<P>
   If List1 and List2 are not lists of compound terms, use Key = 0.

<P>
   If List1 and List2 are lists of compound terms, then the sort will be
   according to the Keyth argument of the lists' elements.  If Key = 0,
   then the sort is on the entire terms.

<P>
   For two lists [e1,e2,e3] and [f1,f2,f3], e1 is compared to f1.  The
   resulting element (dictated by Key, Order and the standard ordering
   below, with ties being resolved in favour of the element from List1)
   is put into List3, and the process continued with the remaining input
   lists.  This process continues until both lists are exhausted.

<P>
   In particular, this will merge two sorted lists into a sorted list.  The
   merge is stable, i.e. the order of elements with the same key is preserved.
   If List1 and List2 contain elements with identical keys, List1's elements
   will occur first in List3.

<P>
   In all cases where List1 and List2 are sorted, Order specifies whether
   the lists are sorted into ascending (&lt;, =&lt;) or descending (&gt;, &gt;=) order
   and whether duplicates are to be retained (=&lt;, &gt;=) or eliminated (&lt;, &gt;).
   The way to remember the Order argument is that it is the relation which
   holds between adjacent elements in the result.

<P>
   The sort is done according to the standard ordering of terms.
   See compare/3 for the definition of this standard ordering.
   Note in particular that numbers are first ordered by their type (integer,
   float, etc) and only then by their magnitude, i.e. sorting numbers of
   different types may not give the expected result.

<P>

<H3>Fail Conditions</H3>
   Fails if List3 does not unify with the merging of the lists List1 and
   List2 outlined above.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(5) type error </EM>
<DD>Key is greater than 0, and one of List1 and List2 does not    have all elements compound terms.
<DT><EM>(5) type error </EM>
<DD>Key is not an integer or a list of integers.
<DT><EM>(6) out of range </EM>
<DD>One of the compound terms in List1 or List2 has not got as    many as Key arguments.
</DL>
<H2>Examples</H2>
<PRE>
Success:
      merge(0,&lt;,[2,4,6],[1,3,5],L).
                      (gives L=[1,2,3,4,5,6]).
      merge(0,&lt;,[f(1),f(7)],[f(8),f(10)],L).
                      (gives L=[f(1),f(7),f(8),f(10)]).
      merge(0,&lt;,[f(2),f(1)],[f(3),f(8)],L).
                      (gives L=[f(2),f(1),f(3),f(8)]).
      merge(0,&lt;,[f(2)],[f(6),f(1)],L).
                      (gives L=[f(2),f(6),f(1)]).
      merge(0,&gt;,[1,e,q],[Q,2,a],L).
                      (gives Q=_g60,L=[_g60,1,2,a,e,q]).
      merge(0,&gt;,[f(8),f(6)],[f(4),f(1)],L).
                      (gives L=[f(8),f(6),f(4),f(1)]).
      merge(2,&lt;,[f(2,1),f(6,4)],[f(6,3),f(8,6)],L).
                      (gives L=[f(2,1),f(6,3),f(6,4),f(8,6)]).
      merge(2,&lt;,[q(2,1),f(6,4)],[a(6,3),i(8,6)],L).
                      (gives L=[q(2,1),a(6,3),f(6,4),i(8,6)]).
      merge(2,&lt;,[f(a,b),f(c,a)],[f(k,a)],L).
                      (gives L=[f(k,a),f(a,b),f(c,a)).
      merge(0,=&lt;,[1,2],[3,4,4,5],L).
                      (gives L=[1,2,3,4,4,5]).
      merge([2,1], =&lt;, [f(1,a(1)), f(0,a(3))], [f(3,a(2)), f(1,a(4))], L).
                      (gives L=[f(1,a(1)), f(3,a(2)), f(0,a(3)), f(1,a(4))]).
Fail:
      merge(0,&lt;,[2,4,6],[1,3,5],[1,2,3,4,5]).
Error:
      merge(1,&lt;,[f(1,2),f],[f(3,4),h(1,2)],L). (Error 5).
      merge(0.0,&lt;,[f(1)],[f(2)],L).            (Error 5).
      merge(2,&lt;,[f(1,2)],[f(8)],L).            (Error 6).



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/merge-3.html">merge / 3</A>, <A HREF="../../kernel/termcomp/compare-3.html">compare / 3</A>
</BODY></HTML>
