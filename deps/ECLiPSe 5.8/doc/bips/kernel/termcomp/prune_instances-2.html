<HTML><HEAD><TITLE>prune_instances(+List, ?PrunedList)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>prune_instances(+List, ?PrunedList)</H1>
Succeeds if PrunedList is the smallest list that subsumes the list List.


<DL>
<DT><EM>+List</EM></DT>
<DD>List of instantiated terms.
</DD>
<DT><EM>?PrunedList</EM></DT>
<DD>List or variable.
</DD>
</DL>
<H2>Description</H2>
   Used to get the smallest list PrunedList whose elements subsume elements
   of the list List.  List must not contain variables.  If List contains
   elements which are variants of each other, then of these, PrunedList
   will only contain the first element found.  If List contains element(s)
   which are instances of another element, then of these, PrunedList will
   only contain the latter.

<P>
   Note that if List contains only ground terms, it cannot contain proper
   instances or variants, but only duplicates.  Therefore, it is faster to
   use a sorting predicate to prune it.

<P>

<H3>Fail Conditions</H3>
   Fails if PrunedList does not unify with List pruned as above.


<H3>Resatisfiable</H3>
   No.
<H2>Examples</H2>
<PRE>
Success:
      prune_instances([5,2,3,5,4,2],L).
          (gives L=[5,2,3,4]).
      prune_instances([f(1,2),f(1,M),1],L).    % instance
          (gives M=_g74,L=[f(1,_g74),1]).
      prune_instances([f(1,2,3),f(1,M,3),f(1,2,N)],L).
          (gives M=_g80,N=_g70, L=[f(1,_g80,3),f(1,2,_g70)]).
      prune_instances([f(1,N),f(1,M),1],L).    % variants
          (gives N=_g72,M=_g76, L=[f(1,_g72),1]).
      prune_instances([f(1,X),f(1,2),g(1)],L).
          (gives X=_g80; L=[f(1,_g80),g(1)]).
Fail:
      prune_instances([1,2,3,1,4,2],[2,3,4]).



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/sort-2.html">sort / 2</A>, <A HREF="../../kernel/termcomp/sort-4.html">sort / 4</A>
</BODY></HTML>
