<HTML><HEAD><TITLE>?Term1 = ?Term2</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>?Term1 = ?Term2</H1>
Succeeds if Term1 and Term2 unify.


<DL>
<DT><EM>?Term1</EM></DT>
<DD>An arbitrary term.
</DD>
<DT><EM>?Term2</EM></DT>
<DD>An arbitrary term.
</DD>
</DL>
<H2>Description</H2>
   Succeeds if the term Term1 unifies with the term Term2,
   otherwise it fails.

<P>
   The unification procedure does not contain an occur check.  Hence,
   cyclic structures can be created during unification.  These cyclic
   structures may cause loops in attempting unification.  eg.  X = f(X,Y),
   Y = f(X,Y).

<P>

<H3>Fail Conditions</H3>
   Fails if Term1 does not unify with Term2.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(11) unify event </EM>
<DD>Term1 or Term2 contain an attributed variable and it is unified with a    nonvariable.
</DL>
<H2>Examples</H2>
<PRE>
   Success:
   atom = atom.
   atom = X.          (gives X = atom)
   X = atom.          (gives X = atom)
   f(1) = X.          (gives X = f(1))
   Y = X.             (gives Y = _g68, X = _g68)
   [1,X] = [Y,2].     (gives X = 2, Y = 1)
   [1,X|Y] = [W,2|Z]. (gives X = 2, Y = _g78,
   W = 1, Z = _g78)
   [1,A,2,B] = [C|D]. (gives A = _g80, B = _g88,
   C = 1, D = [_g80, 2, _g88])
   Fail:
   atom = neutron.
   1.0 = 1.
   [a|b] = [a,b].



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/EE-2.html">== / 2</A>, <A HREF="../../kernel/termcomp/RE-2.html">\= / 2</A>
</BODY></HTML>
