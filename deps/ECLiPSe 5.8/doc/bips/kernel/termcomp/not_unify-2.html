<HTML><HEAD><TITLE>not_unify(?Term1, ?Term2)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>not_unify(?Term1, ?Term2)</H1>
Succeeds if Term1 and Term2 are not unifiable.


<DL>
<DT><EM>?Term1</EM></DT>
<DD>An arbitrary term.
</DD>
<DT><EM>?Term2</EM></DT>
<DD>An arbitrary term.
</DD>
</DL>
<H2>Description</H2>
   Succeeds if Term1 and Term2 are not unifiable.  This predicate differs
   from \=/2 only if attributed variables are involved (e.g. with delayed goals or
   constraints).  While \=/2 does unification, waking of delayed goals and
   full constraint propagation to determine unifiability, not_unify/2 uses
   the test_unify-handler for this purpose.  not_unify/2 is therefore
   likely to be cheaper, but possibly less precise (depending on the
   test_unify-handler) than \=/2.

<P>

<H3>Fail Conditions</H3>
   Fails if Term1 and Term2 can be unified.


<H3>Resatisfiable</H3>
   No.
<H2>Examples</H2>
<PRE>
Success:
   not_unify(atom, neutron).
   not_unify(1.0, 1).
Fail:
   not_unify(X, Y).
   not_unify(X, 1).
Note the difference:
   coroutine, X &gt; 1, X \= 1.
       % succeeds because the delayed goal X&gt;1 is
       % taken into account
   coroutine, X &gt; 1, not_unify(X, 1).
       % fails because the delayed goal X&gt;1 is
       % ignored by the test_unify handler



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/E-2.html">= / 2</A>, <A HREF="../../kernel/termcomp/RE-2.html">\= / 2</A>, <A HREF="../../kernel/termcomp/REE-2.html">\== / 2</A>, <A HREF="../../kernel/termmanip/meta_attribute-2.html">meta_attribute / 2</A>
</BODY></HTML>
