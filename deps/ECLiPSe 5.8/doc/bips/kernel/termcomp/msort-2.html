<HTML><HEAD><TITLE>msort(+List1, ?List2)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Comparing and Sorting</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>msort(+List1, ?List2)</H1>
Succeeds if List2 has the same elements as List1 and is sorted.


<DL>
<DT><EM>+List1</EM></DT>
<DD>List.
</DD>
<DT><EM>?List2</EM></DT>
<DD>List or variable.
</DD>
</DL>
<H2>Description</H2>
   List1 is sorted according to standard term ordering, (without
   removing duplicates in the sense of ==/2) and unified with List2.
<P>
   The sort is done according to the standard ordering of terms.
   Duplicates are not removed.  See compare/3 for this standard ordering.
   Note in particular that numbers are first ordered by their type (integer,
   float, etc) and only then by their magnitude, i.e. sorting numbers of
   different types may not give the expected result.
<P>
Note
   msort(L1,L2) is equivalent to sort(0,=&lt;,L1,L2).
   msort(L1,L2) differs from sort(L1,L2) in that it keeps duplicates.

<P>

<H3>Fail Conditions</H3>
Fails if List2 does not unify with the sorted list version of List1.
<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>List1 is not instantiated.
<DT><EM>(5) type error </EM>
<DD>List1 is not a list.
</DL>
<H2>Examples</H2>
<PRE>
Success:
      msort([3,2,1,2,3],[1,2,2,3,3]).
      msort([2,4,6],L).         (gives L=[2,4,6]).
      msort([2,4,6,1,7,3],L).   (gives L=[1,2,3,4,6,7]).

Fail:
      msort([1,5,3,7],[1,3,7,5]).

Error:
      msort(List1,List2).         (Error 4).
      msort("[1]",L).             (Error 5).



</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/termcomp/compare-3.html">compare / 3</A>, <A HREF="../../kernel/termcomp/sort-2.html">sort / 2</A>, <A HREF="../../kernel/termcomp/sort-4.html">sort / 4</A>
</BODY></HTML>
