<HTML><HEAD><TITLE>export +SpecList</TITLE>
</HEAD><BODY>[ <A HREF="index.html">Modules</A> | <A HREF="../index.html">The ECLiPSe Built-In Predicates</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>export +SpecList</H1>
Exports from the caller module all items specified by SpecList.
<DL>
<DT><EM>+SpecList</EM></DT>
<DD>One or a comma-separated sequence of valid export specifications
</DD>
</DL>
<H2>Description</H2>
    To make definitions from one module accessible in others, they
    have to be exported.  The following type of items can occur in
    SpecList and can thus be exported:
<DL>
<DT><STRONG>Name/Arity</STRONG><DD>
        procedure  specification

<DT><STRONG>domain(Spec)</STRONG><DD>
	domain declaration

<DT><STRONG>struct(Prototype)</STRONG><DD>
	structure declaration

<DT><STRONG>op(Prec,Assoc,Name)</STRONG><DD>
	operator declaration

<DT><STRONG>chtab(Char,Class)</STRONG><DD>
	character class declaration

<DT><STRONG>syntax_option(Option)</STRONG><DD>
	syntax option setting

<DT><STRONG>macro(Functor,Transformation,Options)</STRONG><DD>
	macro (input transformation) declaration

<DT><STRONG>portray(Functor,Transformation,Options)</STRONG><DD>
	portray (output transformation) declaration

<DT><STRONG>initialization(Goal)</STRONG><DD>
	initialization goal specification
</DL>
    SpecList is a comma-separated sequence of one or more of such items.
    The export/1 primitive usually occurs as a directive in compiled
    module files. It can occur anywhere in the file.
<P>
   <BIG>Exporting Procedures</BIG>
<P>
   A procedure can be (and usually is) declared as exported before it
   is actually defined.  Export declarations should occur either at the
   beginning of a module text, or just before the procedure definition,
   e.g
<PRE>
       :- export double/2.
       double(X, Y) :-
	   Y is 2*X.
</PRE>
<P>
   You can only export procedures that are defined in the exporting
   module.  Imported procedures cannot be exported with export/1 (it
   raises error 94) - use reexport/1 to do this.
<P>
   Declaring a procedure as exported will make it accessible to other modules.
   That means that it can either be called with explicit module qualification
   using :/2, or it can be imported and thus made visible elsewhere.
<P>
   Procedures can be imported and calls to them compiled before they have
   been exported, e.g. when an importing module is compiled before the
   exporting module.  This mechanism should be used only in exceptional
   situations, normally the exporting module should be compiled first. 
   The reason is that the compiler needs some information about the
   predicate when compiling a call to it. If this information is not
   available at call time, an incompatibility may occur later when the
   exported definition is encountered.
<P>
   <BIG>Exporting Other Declarations</BIG>
<P>
   Exported structure, operator, syntax, macro and portray
   declarations have the same effect as the corresponding local
   declarations in the module where they occur.  In addition, they are
   available in every module where they are imported.
<P>
   <BIG>Exporting Initializations</BIG>
<P>
   The exported initialization directive does not have any effect in
   the exporting module, but <EM>only</EM> in the module where it is
   imported.  The initialization goal is called once in the context of
   every importing module.
<P>
   <BIG>Further Hints</BIG>
<P>
   All the export (and reexport) directives of a module together form
   what is called the module's <EM>interface</EM>. The module interface
   can be extracted from a module source file using the icompile/2
   utility from library(document). The interface can also be retrieved
   from a loaded module by calling get_module_info/3.
<P>
   Exporting the same item twice, or exporting something that has
   previously been declared local, is accepted silently.
<P>
   The following primitives implicitly export items:  The module/3
   directive and the create_module/3 predicate export the list of
   items given in their second argument.  The tool/2 declaration
   implicitly exports the tool body predicate.  Event handlers, error
   handlers and interrupt handlers are implicitly exported by the
   corresponding set_xxx_handler primitive.
<P>
   The export/1 primitive can not only occur as a directive but can also
   be called at runtime.

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>SpecList is not instantiated.
<DT><EM>(5) type error </EM>
<DD>SpecList contains an invalid specification.
<DT><EM>(94) trying to redefine an existing imported procedure </EM>
<DD>SpecList is already imported.
</DL>
<H2>Examples</H2>
<PRE>
% A module that exports a predicate and an operator:

    :- module(m1).

    :- export
    	before/2,
	op(700, xfx, before).

    A before B :-
    	A &lt; B.

% Using this module elsewhere:

    :- module(m2).

    :- import m1.    % or :- use_module(".../m1...").

    main :-
    	3 before 7.  % operator and procedure definition are visible!

% Using before/2 without import, via explicit qualification:
% We can call before/2, but we cannot use the infix syntax!

    :- module(m3).

    main :-
    	m1:before(3,7).


% Error cases:

  :- export Q.                         (Error 4).
  :- export p/a.                       (Error 5).
  :- import p/1 from m.
  :- export p/1.                       (Error 94).
</PRE>
<H2>See Also</H2>
<A HREF="../../kernel/modules/import-1.html">import / 1</A>, <A HREF="../../kernel/modules/reexport-1.html">reexport / 1</A>, <A HREF="../../kernel/modules/local-1.html">local / 1</A>, <A HREF="../../kernel/modules/use_module-1.html">use_module / 1</A>, <A HREF="../../kernel/modules/module-1.html">module / 1</A>, <A HREF="../../kernel/control/N-2.html">: / 2</A>, <A HREF="../../kernel/modules/get_module_info-3.html">get_module_info / 3</A>, <A HREF="../../lib/document/icompile-1.html">document : icompile / 1</A>, <A HREF="../../lib/document/icompile-2.html">document : icompile / 2</A>, <A HREF="../../kernel/termcomp/domain-1.html">domain / 1</A>, <A HREF="../../kernel/syntax/macro-3.html">macro / 3</A>, <A HREF="../../kernel/syntax/op-3.html">op / 3</A>, <A HREF="../../kernel/syntax/portray-3.html">portray / 3</A>, <A HREF="../../kernel/syntax/struct-1.html">struct / 1</A>
</BODY></HTML>
