<HTML><HEAD><TITLE>maplist(+Pred, ?OldList, ?NewList)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">library(lists)</A> | <A HREF="../index.html">The ECLiPSe Libraries</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>maplist(+Pred, ?OldList, ?NewList)</H1>
Succeeds if Pred(Old, New) succeeds for corresponding pairs of elements
from OldList and NewList.


<DL>
<DT><EM>+Pred</EM></DT>
<DD>Atom or compound term.
</DD>
<DT><EM>?OldList</EM></DT>
<DD>List or variable.
</DD>
<DT><EM>?NewList</EM></DT>
<DD>List or variable.
</DD>
</DL>
<H2>Description</H2>
   Either OldList or NewList should be a proper list.  maplist/3 succeeds
   if for every corresponding pair of elements Old, New of the two lists
   OldList and NewList the invocation of Pred with two aditional arguments
   Old and New succeeds.
<P>
   The definition of this Prolog library predicate is:
<PRE>
:- tool(maplist/3, maplist_body/4).

maplist_body(_, [], [], _).
maplist_body(Pred, [H1|T1], [H2|T2], M) :-
    Pred =.. PL,
    append(PL, [H1, H2], NewPred),
    Call =.. NewPred,
    call(Call, M),
    maplist_body(Pred, T1, T2, M).
</PRE>
   This predicate does not perform any type testing functions.
	
<H3>Fail Conditions</H3>
   Fails if at least for one pair of corresponding elements of OldList and
   NewList the invocation of Pred with these two additional arguments
   fails.


<H3>Resatisfiable</H3>
   No.
<H2>Examples</H2>
<PRE>
Success:
  maplist(integer_atom, [1, 2, 3], ['1', '2', '3']).
  maplist(sin, [0, 1, 2], X).
      (gives X = [0.0, 0.841471, 0.909297])
  maplist(get_flag(var/1), [skip, type, spy], [off, built_in, off]).
Fail:
  maplist(type_of, [1, a, "a"], [integer, atom, atom]).



</PRE>
<H2>See Also</H2>
<A HREF="../../lib/lists/checklist-2.html">checklist / 2</A>
</BODY></HTML>
