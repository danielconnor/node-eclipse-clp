
insetdomain(?Set, ?CardSel, ?ElemSel, ?Order)

   Instantiate Set to a possible value

Arguments
   Set                 a set or set variable
   CardSel             atom or variable
   ElemSel             atom, structure or variable
   Order               atom or variable

Type
   library(ic_sets)

Description

    This predicate instantiates a set variable to a possible value,
    according to its domain.  The predicate backtracks over all
    possible set instantiations.  The three option arguments allow to
    choose between a number of different enumeration orders. Giving a
    variable as option argument will select the default.

    The CardSel argument determines whether the sets are enumerated
    according to their cardinality. It can take the following values:

any (default)
    the sets are not enumerated in a particular cardinality order
increasing
    the sets are enumerated with increasing cardinality, ie. small
    sets are tried first
decreasing
    the sets are enumerated with decreasing cardinality, ie. large
    sets are tried first


    The ElemSel argument determines which potential set elements
    are considered first for inclusion or exclusion. It can take the
    following values:

small_first (default)
    small set elements (small numbers) are considered first
big_first
    big set elements (big numbers) are considered first
random
    potential set elements are considered in random order
heavy_first(Weights)
    heavy set elements (according to Weight array) are considered first
light_first(Weights)
    light set elements (according to Weight array) are considered first


    The Order argument determines whether it is first tried to make
    the selected potential element a set member, or whether to exclude it
    first.  The argument can take the following values:

in_notin (default)
    try inclusion first, then exclusion
notin_in
    try exclusion first, then inclusion
sbds
    uses sbds_try/2 to include or exclude an element in or from a set
    (this is for use in conjunction with the classic SBDS library
    (lib(ic_sbds) or lib(fd_sbds)), and whether inclusion or exclusion is
    tried first depends on the "fix pred" specified in the prior call to
    sbds_initialise/4 or sbds_initialise/5)
gap_sbds_in_notin
    try inclusion first, then exclusion, using sbds_try_set/3 (this is
    for use in conjunction with the GAP-based SBDS library lib(ic_gap_sbds))
gap_sbds_notin_in
    try exclusion first, then inclusion, using sbds_try_set/3 (this is
    for use in conjunction with the GAP-based SBDS library lib(ic_gap_sbds))
gap_sbdd_in_notin
    try inclusion first, then exclusion, using sbdd_try_set/3 (this is
    for use in conjunction with the GAP-based SBDD library lib(ic_gap_sbdd))
gap_sbdd_notin_in
    try exclusion first, then inclusion, using sbdd_try_set/3 (this is
    for use in conjunction with the GAP-based SBDD library lib(ic_gap_sbdd))


    Note that there are many different enumeration strategies for a set
    variable, and insetdomain/4 only allows a limited number of them.
    For an actual application, it might be more appropriate to choose a
    problem-specific enumeration order. This can be programmed easily.
    As a guideline, here is the code for insetdomain with the default
    options:

    insetdomain(Set, _, _, _) :-
    	nonvar(Set).
    insetdomain(Set, any, small_first, in_notin) :-
    	var(Set),
    	potential_members(Set, PotentialElements),
	PotentialElements = [Element|_],
	(
	    Element in Set
	;
	    Element notin Set
	),
	insetdomain(Set, any, small_first, in_notin).



Resatisfiable
   yes

Exceptions
     4 --- Set is a variable, but not a set variable

Examples
   
?-  X::[]..[1,2,3], insetdomain(X,_,_,_), writeln(X), fail.
[1, 2, 3]
[1, 2]
[1, 3]
[1]
[2, 3]
[2]
[3]
[]

no (more) solution.
?-  X::[]..[1,2,3], insetdomain(X,increasing,_,_), writeln(X), fail.
[]
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 3]
[1, 2, 3]

no (more) solution.
?-  X::[]..[1,2,3], insetdomain(X,_,big_first,_), writeln(X), fail.
[1, 2, 3]
[2, 3]
[1, 3]
[3]
[1, 2]
[2]
[1]
[]

no (more) solution.
?-  X::[]..[1,2,3], insetdomain(X,_,_,notin_in), writeln(X), fail.
[]
[3]
[2]
[2, 3]
[1]
[1, 3]
[1, 2]
[1, 2, 3]

no (more) solution.
?-  X::[]..[1,2,3],
	insetdomain(X, increasing, heavy_first([](2,9,4,7)), _),
	writeln(X), fail.
[]
[2]
[3]
[1]
[2, 3]
[1, 2]
[1, 3]
[1, 2, 3]

no (more) solution.


See Also
   conjunto : refine / 1, conjunto_fd_sets : refine / 1, potential_members / 2, fd_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_try_set / 3, library(ic_gap_sbds), ic_gap_sbdd : sbdd_try_set / 3, library(ic_gap_sbdd)
