lib(eplex)


   This library lets you use an external Simplex or MIP solver like
   CPLEX or XPRESS-MP from within ECLiPSe. The library provides just
   the interface, and does not include the solver or any required licence 
   to use them.

   The is the `standalone' version of the eplex library which does not require 
   additional libraries (e.g. IC) to support the variable bounds. Instead,
   the bounds are stored in the external solver instance. This version of
   eplex is not completely source compatible with the other versions of eplex.
   Note, however, that once the library is loaded, the default eplex
   instance created is eplex and the low-level predicates are accessed
   through the module eplex, rather than s_eplex.

    The main difference from the other eplex versions are:
    
    Bounds posted to a bounds keeper are not automatically seen by
        eplex.
    Bounds are kept by the external solver and treated as proper eplex
        constraints. They can be posted/added to each external solver.
        instance. New variables in the constraints will now always be added 
        to the external solver instance.
    The bounds and integers/1 constraint does not imply any type for
        its variables. The integers/1 constraint simply informs the external 
        solver instance to treat the variables as integer.
    Eplex bound constraints will never cause the variable to become 
        instantiated.
    No bounds propagation is performed with the eplex bounds
        constraints.
    The objective variable in a demon solver is not automatically given
        bounds.
    Constraints are added to the external solver instance immediately
        after solver setup.
 


    The constraints provided are:
    
    X =:= Yequality over linear expressions
    X >= Yinequality over linear expressions
    X =< Yinequality over linear expressions
    X $= Yequality over linear expressions
    X $>= Yinequality over linear expressions
    X $=< Yinequality over linear expressions
    integers(Xs)integrality of variables
    Vs :: BoundBounds on variables
    Vs $:: BoundBounds on variables
    
    Their operational behaviour is as follows:

    When they contain no variables, they simply succeed or fail.

    When they contain exactly one variable, they are translated into a
    bound update on that variable for the external solver instance. This
    can lead to immediate failure if the lower bound is greater than the upper.

    Otherwise, the constraint is given to the external solver instance.
    This happens either immediately, or in response
    to certain trigger conditions.  This mechanism makes it possible to
    tailor the solving behaviour for a particular application's needs.


The following arithmetic expression can be used inside the constraints:

X
Variables. If X is not yet a ranged variable for the external solver
    instance, it  is turned into one via an implicit declaration 
    X :: -inf..inf.


123, 3.4
Integer or floating point constants.


+Expr
Identity.


-Expr
Sign change.


E1+E2
Addition.


sum(ListOfExpr)
Equivalent to the sum of all list elements.


E1-E2
Subtraction.


E1*E2
Multiplication.


ListOfExpr1*ListOfExpr2
Scalar product: The sum of the products of the corresponding
elements in the two lists.  The lists must be of equal length.



