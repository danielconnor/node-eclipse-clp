<HTML><HEAD><TITLE>lp_setup(+NormConstraints, +Objective, ++ListOfOptions, -Handle)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">library(eplex)</A> | <A HREF="../index.html">The ECLiPSe Libraries</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>lp_setup(+NormConstraints, +Objective, ++ListOfOptions, -Handle)</H1>
Create a new external solver state for the constraints NormConstraints.
<DL>
<DT><EM>NormConstraints</EM></DT>
<DD>normalised constraints
</DD>
<DT><EM>Objective</EM></DT>
<DD>Objective function: min(CostExpr) or max(CostExpr)
</DD>
<DT><EM>ListOfOptions</EM></DT>
<DD>List of solver options
</DD>
<DT><EM>Handle</EM></DT>
<DD>handle to solver state
</DD>
</DL>
<H2>Description</H2>
<P>
    Create a new solver state for the set of constraints NormConstraints
    (see normalise_cstrs/3 for how to obtain a set of normalised
    constraints).  Apart from the explicitly listed constraints, the
    variable's ranges will be taken into account as the variable bounds for
    the simplex algorithm.  Undeclared variables are implicitly declared as
    reals (see reals/1 of the range library).

</P><P>
    However, when variables have been declared integers (using ::/2 or
    integers/1 of the range library) that is not taken into account by the
    solver by default.  This means that the solver will only work on the
    <EM>relaxed problem</EM> (ie. ignoring the integrality constraints),
    unless specified otherwise in the options.

</P><P>
    CostExpr is a linear expression
    (or quadratic if supported by the external solver).

</P><P>
    Options is a list of options (see below).


</P><P>
    A solver-handle Handle is returned which is used to refer to the solver
    subsequently.

</P><P>
    Note: Some external solvers need to write temporary files when they
    are solving a problem. These are written to the temporary directory
    specified in ECLiPSe's tmp_dir setting (get_flag/2, set_flag/2).

</P><P>
The solver Options are:
<DL>

<DT><STRONG><TT>integers(+ListOfVars)</TT></STRONG>
    <DD>Consider the specified variables to be integers (whether or not
    they have been declared such).
    This option will instruct the external solver to use its own MIP solver
    (ie. branch-and-bound search happens within the external solver) instead of
    just the Simplex.

<P>
<DT><STRONG><TT>method(+Method)</TT></STRONG>
    <DD>Use the specified method (<TT>default, primal, dual, net,
    barrier, sifting</TT>) (representing Primal Simplex, Dual Simplex,
    Network Simplex, Barrier, and Sifting respectively) to solve the
    problem. For MIP problems, this specifies the start algorithm (the one
    that is used to solve the initial relaxation). See the external
    solver's manual for a description of these methods.
<P> 
    For some of the methods, an additional `auxiliary' method may be 
    specified in brackets. These are:
<DL>
<P>
      <DT><TT>net(Simplex)</TT>: 
      <DD>specifies the Simplex method (<TT>primal</TT> or <TT>dual</TT>) to 
      follow the network optimisation. For LP problems only.
<P>
      <DT><TT>barrier(Crossover)</TT>: 
      <DD>specifies how the crossover to a basic solution from the barrier
      solution is performed. <TT>Crossover</TT> can be <TT>primal</TT>, 
      <TT>dual</TT>, or <TT>none</TT>. <TT>none</TT> means no crossover is
      performed. 
<P>
      <DT><TT>sifting(SubMethod)</TT>: 
      <DD>specifies the method for solving the sifting subproblem. 
      <TT>SubMethod</TT> can be <TT>primal, dual, net, barrier</TT>.
<P>
</DL>
    For all the auxiliary methods, <TT>default</TT> can also be specified.
    This is eqivalent to not specifying a auxiliary method at all. 
<P>
    Note that not all the methods are available on all external solvers. 
    The default method would use the solver's default method to solve the
    problem. The actual method depends on the external solver. If no method
    is specified, default is used.

<P>
<DT><STRONG><TT>node_method(+Method)</TT></STRONG>
    <DD>For MIP problems only. Use the specified method (<TT>default, primal,
    dual, net, barrier, sifting</TT>) to solve the subproblem at each node
    of the MIP search-tree, except the root node, which is specified by
    <TT>method</TT> option above. See method option for more description of
    the methods. Note that there are less choices in the specifications of
    the auxiliary methods that in the method option, due to limitations in
    the solvers. If a specified auxiliary method cannot be used, `default'
    will be used instead.

<P>
<DT><STRONG><TT>solution(+YesNo)</TT></STRONG>
    <DD>Make the solutions available each time the problem has been (re-)solved
    successfully.
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    <TT>yes</TT>.

<P>
<DT><STRONG><TT>dual_solution(+YesNo)</TT></STRONG>
    <DD>Make the dual solutions available each time the problem has been 
    (re-)solved successfully. If the problem is a MIP, then depending on
    the external solver, this is either unavailable or are the values for
    the optimal LP node. 
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    <TT>no</TT>.

<P>
<DT><STRONG><TT>slack(+YesNo)</TT></STRONG>
    <DD>Make the constraint slacks available each time the problem has been 
    (re-)solved successfully.
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    <TT>no</TT>.

<P>
<DT><STRONG><TT>reduced_cost(+YesNo)</TT></STRONG>
    <DD>Make the reduced costs available each time the problem has been
    (re-)solved successfully. If the problem is a MIP, then depending on
    the external solver, this is either unavailable or are the values for
    the optimal LP node. 
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    <TT>no</TT>.

<P>
<DT><STRONG><TT>keep_basis(+YesNo)</TT></STRONG>
    <DD>Store the basis each time the problem has been solved successfully,
    and use this basis as a starting point for re-solving next time.
    This option only affects performance.
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    <TT>no</TT>.

<P>
<DT><STRONG><TT>demon_tolerance(RealTol, IntTol)</TT></STRONG>
    <DD>Specify how far outside a variable's range an lp-solution
    can fall before lp_demon_setup/5 re-triggers.
    <TT>RealTol</TT> and <TT>IntTol</TT> are floats and default to
    0.00001 and 0.5 respectively.

<P>
<DT><STRONG><TT>sos1(VarList)</TT></STRONG>
    <DD><TT>VarList</TT> is a list of variables which the solver should
    treat as variables of a type 1 special ordered set (SOS), i.e. at most
    one of the variables in the set can be non-zero.

<P>
<DT><STRONG><TT>sos2(VarList)</TT></STRONG>
    <DD><TT>VarList</TT> is a list of variables which the solver should
    treat as variables of a type 2 special ordered set (SOS), i.e. at most
    two of the variables in the set can be non-zero.

<P>
<DT><STRONG><TT>presolve(+YesNo)</TT></STRONG>
    <DD>Specify if the external solver should perform presolve for this
    problem. With presolving, the external solver will transform the
    problem before solving it. This can lead to significantly faster times
    to find solutions. However, as the problem has been transformed, some
    external solvers have restriction on accessing or changing the problem
    state. In addition, if the solver is repeatedly called because the
    problem is frequently modified, then presolve may not be an advantage.
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    determined by the global setting of <TT>presolve</TT>, which can be
    changed via <TT>lp_set/2</TT>. The initial default is <TT>yes</TT>.
    Note that the presolve setting cannot be changed for a problem once it
    is set.
<P>
<DT><STRONG><TT>timeout(+TimeOut)</TT></STRONG>
    <DD>Set the external solver to time-out after <TT>TimeOut</TT> seconds.
    <TT>TimeOut</TT> is a positive number. The solver will abort (in either
    the abort or suboptimal state, depending on if a suboptimal solution
    was found) if the optimal solution was not found within the time
    limit. This should be used instead of setting the solver-specific
    parameter for time-out directly. In cases where the solver expects an
    integer for the time-out interval, the time given is rounded up to the
    next integer value.
<P>
<DT><STRONG><TT>suboptimal_handler(+Goal)</TT></STRONG>
    <DD>Specifies a user defined goal Goal to handle the case when the
    external solver returned a suboptimal solution (because the problem
    was aborted). Goal would be run in place of raising the default 
    <TT>eplex_suboptimal</TT> event.
<P>
<DT><STRONG><TT>unbounded_handler(+Goal)</TT></STRONG>
    <DD>Specifies a user defined goal Goal to handle the case when the
    problem is unbounded. Goal would be run in place of raising the  
    default <TT>eplex_unknown</TT> event.
<P>
<DT><STRONG><TT>unknown_handler(+Goal)</TT></STRONG>
    <DD>Specifies a user defined goal Goal to handle the case when the
    external solver was not able to determine if the problem is unbounded
    or infeasible. Goal would be run in place of raising the default 
    <TT>eplex_unknown</TT> event.
<P>
<DT><STRONG><TT>abort_handler(+Goal)</TT></STRONG>
    <DD>Specifies a user defined goal Goal to handle the case when the
    external solver aborted without finding any solution. Goal would be 
    run in place of raising the default <TT>eplex_abort</TT> event.
<P>
<DT><STRONG><TT>use_var_names(+YesNo)</TT></STRONG>
    <DD>Specify if variable names (set using <TT>set_var_name/2</TT> of the 
    var_name library) should be passed to the external solver. If a 
    particular variable does not have a name, a solver's default name 
    would be used. Note that for XPRESS-MP, there is a limit on the length
    of the name, which can be changed between 8 and 64 in steps of 8 with
    the parameter <TT>N_NAMLEN</TT>. Variable names longer than this limit 
    are truncated to the limit. 
    YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default is 
    <TT>no</TT>.
<P>
    <DT><STRONG><TT>mip_use_copy(YesNo)</TT></STRONG>
        <DD>Some external solvers do not allow a MIP problem to be modified
        once the MIP search has been started. Eplex works around this
        problem by making a copy of the problem and solving that, so that
        the original problem can still be modified. This can be turned off to
        avoid the overhead of making this copy, in which case the MIP
        problem cannot be modified. This option is used only when solving a
        MIP problem, and the external solver does not allow a MIP problem to
        be modified; otherwise it is ignored.
        YesNo is one of the atoms <TT>yes</TT> or <TT>no</TT>, the default 
        is <TT>yes</TT> so that the problem can be modified.
<P>
    <DT><STRONG><TT>write_before_solve(Format,File)</TT></STRONG>
        <DD>This option is most useful for debugging purposes. If given,
        Eplex will ask the external solver to dump the problem each time
        the solver is invoked by calling <TT>lp_write/3</TT>. This allows
        the problem in an <TT>eplex_probe/2</TT> or <TT>lp_probe/3</TT> to
        be dumped. <TT>Format</TT> and <TT>File</TT> are simply passed to 
        <TT>lp_write/3</TT>.

    <DT><STRONG><TT>post_equality_when_unified(+YesNo)</TT></STRONG>
        <DD>This option determines if an equality constraint between two
        variables will be posted to the solver when these variables are
        unified. Setting <TT>YesNo</TT> to no means that the constraint 
        will <EM>not</EM> be posted. Note that this can lead to the
        solver's problem becoming inconsistent with ECLiPSe's. 
<P>
<DT><STRONG><TT>sync_bounds(+YesNo)</TT></STRONG>
    <DD>This option determines if the bounds of the problems variables are
    synchronised with other solvers (i.e. the generic bounds are obtained
    with get_var_bounds/3 and then passed to the external solver) before
    the external solver is invoked. This was always done for previous
    non-standalone version of eplex. For standalone eplex, as the bounds
    are communicated directly to the external solver, the synchronisation
    of variable bounds is not needed unless the user is using eplex
    co-operatively with other solvers (e.g. ic). Even in such cases, it may
    be more efficient to communicate these bounds changes by explicitly
    programming it, especially if the problem has many variables and bounds
    changes happen only to a few of the variables. Setting <TT>YesNo</TT>
    to yes should increase compatibility with previous code (but note that
    previous eplex obtained the bounds from a specific bounds keeper like
    ic or range rather than the generic bounds).  YesNo is one of the atoms
    <TT>yes</TT> or <TT>no</TT>, the default is <TT>no</TT>.

</DL>

<H2>See Also</H2>
<A HREF="../../lib/eplex/lp_add-3.html">lp_add / 3</A>, <A HREF="../../lib/eplex/lp_set-3.html">lp_set / 3</A>, <A HREF="../../lib/eplex/lp_add_vars-2.html">lp_add_vars / 2</A>, <A HREF="../../lib/eplex/lp_add_constraints-3.html">lp_add_constraints / 3</A>, <A HREF="../../lib/eplex/lp_solve-2.html">lp_solve / 2</A>, <A HREF="../../lib/eplex/lp_probe-3.html">lp_probe / 3</A>, <A HREF="../../lib/eplex/lp_get-3.html">lp_get / 3</A>, <A HREF="../../lib/eplex/normalise_cstrs-3.html">normalise_cstrs / 3</A>, <A HREF="../../lib/eplex/lp_write-3.html">lp_write / 3</A>
</BODY></HTML>
