<HTML><HEAD><TITLE>make_graph_symbolic(+NodeNameArray, ++SymbolicEdgeList, -Graph)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">library(graph_algorithms)</A> | <A HREF="../index.html">The ECLiPSe Libraries</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>make_graph_symbolic(+NodeNameArray, ++SymbolicEdgeList, -Graph)</H1>
Creates a graph using node names
<DL>
<DT><EM>NodeNameArray</EM></DT>
<DD>array of ground data, usually node names
</DD>
<DT><EM>SymbolicEdgeList</EM></DT>
<DD>(possibly empty) list of edge/3 structures in no particular order
</DD>
<DT><EM>Graph</EM></DT>
<DD>will be bound to a graph structure
</DD>
</DL>
<H2>Description</H2>
<P>
    This predicate is similar to make_graph/3 in that it creates a
    graph data structure according to the given information.
    If the nodes have names, then make_graph_symbolic/3 allows to
    specify the graph in a more readable way by using the node names
    rather than node numbers in the edge specifications.
    The node names are given as the array NodeNameArray, and the
    symbolic edges are written in the form
<PRE>
	edge(SourceName, TargetName, EdgeData)
</PRE>
    where SourceName and TargetName should match an entry (usually the
    node name) in NodeNameArray.  Note the use of the functor edge/3 for
    the symbolic edge representation as opposed to e/3 for the internal
    edge representation.
    </P>
<H2>Examples</H2>
<PRE>
    % the 13-node undirected graph from Sedgewick:Algorithms
    make_graph_symbolic(
	[](a,b,c,d,e,f,g,h,i,j,k,l,m),
	[ edge(a,f,1),edge(a,b,1),edge(a,g,1),edge(c,a,1),edge(d,f,1),edge(e,d,1),
	  edge(f,e,1),edge(g,e,1),edge(g,j,1),edge(g,c,1),edge(h,g,1),edge(h,i,1),edge(i,h,1),
	  edge(j,k,1),edge(j,l,1),edge(j,m,1),edge(l,g,1),edge(l,m,1),edge(m,l,1) ],
	Graph).
    </PRE>
<H2>See Also</H2>
<A HREF="../../lib/graph_algorithms/make_graph-3.html">make_graph / 3</A>, <A HREF="../../lib/graphviz/index.html">library(graphviz)</A>
</BODY></HTML>
