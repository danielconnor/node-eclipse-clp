<HTML><HEAD><TITLE>dom(+Var, ?List)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">library(fd)</A> | <A HREF="../index.html">The ECLiPSe Libraries</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>dom(+Var, ?List)</H1>
List is the list of elements in the domain of Var.


<DL>
<DT><EM>+Var</EM></DT>
<DD>A domain variable or an integer.
</DD>
<DT><EM>?List</EM></DT>
<DD>Term unifying with a list of integers.
</DD>
</DL>
<H2>Description</H2>
   If Var is a domain variable, List is unified with a sorted list of all
   elements in its domain.  If Var is an integer, List is unified with a
   singleton list.

<P>
   The predicates ::/2 and #::/2 can also be used to query the domain of a domain
   variable, however they yield a list of integer intervals, which is the
   direct domain representation (it is therefore also more efficient
   because no new structures have to be created).

<P>
   Use this predicate with care, because it might expand a compact
   representation of large intervals into an explicit list of their
   elements.  Unless an explicit list representation of the domain is
   really required, the predicates working on domains should be preferred.

<P>

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Var is not a domain variable.
</DL>
<H2>Examples</H2>
<PRE>
   [eclipse 9]: X::[1..3, 100..102], dom(X, List), X::I.
   List = [1, 2, 3, 100, 101, 102]
   X = X :: [1 .. 3, 100 .. 102]
   I = [1 .. 3, 100 .. 102]
   yes.



</PRE>
<H2>See Also</H2>
<A HREF="../../lib/fd/NN-2.html">:: / 2</A>, <A HREF="../../lib/fd/HNN-2.html">#:: / 2</A>, <A HREF="../../lib/fd/maxdomain-2.html">maxdomain / 2</A>, <A HREF="../../lib/fd/mindomain-2.html">mindomain / 2</A>
</BODY></HTML>
