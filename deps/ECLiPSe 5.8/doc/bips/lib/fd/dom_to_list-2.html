<HTML><HEAD><TITLE>dom_to_list(+Dom, ?List)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">library(fd)</A> | <A HREF="../index.html">The ECLiPSe Libraries</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>dom_to_list(+Dom, ?List)</H1>
List is the list of elements in the domain Dom.


<DL>
<DT><EM>+Dom</EM></DT>
<DD>A finite domain.
</DD>
<DT><EM>?List</EM></DT>
<DD>Term unifying with a list of integers.
</DD>
</DL>
<H2>Description</H2>
   List is unified with a sorted list of all elements in the domain Dom.

<P>
   The predicates ::/2 and #::/2 can also be used to query the domain of a domain
   variable, however they yield a list of integer intervals, which is the
   direct domain representation (it is therefore also more efficient
   because no new structures have to be created).

<P>
   Use this predicate with care, because it might expand a compact
   representation of large intervals into an explicit list of their
   elements.  Unless an explicit list representation of the domain is
   really required, the predicates working on domains should be preferred.

<P>

<H3>Fail Conditions</H3>
   None.


<H3>Resatisfiable</H3>
   No.
<H3>Exceptions</H3>
<DL>
<DT><EM>(4) instantiation fault </EM>
<DD>Var is not a domain variable.
</DL>
<H2>Examples</H2>
<PRE>
   [eclipse 9]: X::[1..3, 100..102], dvar_domain(X, D), dom_to_list(D,
   List), X::I.
   D = [1..3, 100..102]
   List = [1, 2, 3, 100, 101, 102]
   X = X :: [1 .. 3, 100 .. 102]
   I = [1 .. 3, 100 .. 102]
   yes.



</PRE>
<H2>See Also</H2>
<A HREF="../../lib/fd/NN-2.html">:: / 2</A>, <A HREF="../../lib/fd/HNN-2.html">#:: / 2</A>, <A HREF="../../lib/fd/maxdomain-2.html">maxdomain / 2</A>, <A HREF="../../lib/fd/mindomain-2.html">mindomain / 2</A>
</BODY></HTML>
