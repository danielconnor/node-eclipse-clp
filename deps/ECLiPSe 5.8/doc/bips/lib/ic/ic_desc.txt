lib(ic)


   The IC (Interval Constraint) library is a hybrid integer/real interval
   arithmetic constraint solver.  Its aim is to make it convenient for
   programmers to write hybrid solutions to problems, mixing together
   integer and real constraints and variables.

   The integer constraints and variables are similar to those available in
   the old finite domain library `fd'.  The real constraints are similar to
   those that were available in the old real interval arithmetic library
   `ria'.  Constraints which are not specifically integer constraints can be
   applied to either real or integer variables (or a mix) seamlessly, and
   any real variable can be converted to an integer variable at any time by
   imposing an integrality constraint on it.

   The IC library replaces the `fd', `ria' and `range' libraries (with a new
   symbolic solver library providing the non-numeric functionality of `fd').
   
   For more information, see the IC section of the constraint library manual
   or the documentation for the individual IC predicates.

   The IC library solves constraint problems over the reals.  It is not
   limited to linear constraints, so it can be used to solve general
   problems like:
   
   [eclipse 2]: ln(X) $>= sin(X).

   X = X{0.36787944117144228 .. 1.0Inf}
   yes.
   
   
   The IC library handles linear and non-linear, reified constraints and
   user defined functions. 
   
   User-defined functions/constraints are treated in a similar manner to
   user defined functions found in expressions handled by is/2.  Note,
   however, that user defined constraints/functions, when used in IC, should
   be (semi-)deterministic.  User defined constraints/functions which leave
   choice points may not behave as expected.
   
   Linear constraints are handled by a single propagator, whereas non-linear
   constraints are broken down into simpler ternary/binary/unary
   propagators.  The value of any constraint found in an expression is its
   reified truth value (0..1).
   
   Variables appearing in arithmetic IC constraints at compile-time are
   assumed to be IC variables unless they are wrapped in an eval/1
   term.  The eval/1 wrapper inside arithmetic constraints is used to
   indicate that a variable will be bound to an expression at run-time.
   This feature will only be used by programs which generate their
   constraints dynamically at run-time, for example.
   
   broken_sum(Xs,Sum):-
       (
	   foreach(X,Xs),
	   fromto(Expr,S1,S2,0)
       do
	   S1 = X + S2
       ),
       Sum $= Expr.
   
   
   The above implementation of a summation constraint will not work as
   intended because the variable Expr will be treated like an IC
   variable when it is in fact the term +(X1,+(X2,+(...))) which is
   constructed in the for-loop.  In order to get the desired functionality,
   one must wrap the variable Expr in an eval/1.
   
   
   working_sum(Xs,Sum):-
       (
	   foreach(X,Xs),
	   fromto(Expr,S1,S2,0)
       do
	   S1 = X + S2
       ),
       Sum $= eval(Expr).
   
   
   The following arithmetic expression can be used inside the constraints:
   
   X
	    Variables.  If X is not yet an interval variable, it is turned 
	    into one.

   123
	    Integer constants.

   0.1
	    Floating point constants.  These are assumed to be exact and
	    are converted to zero-width bounded reals.

   0.1__0.2
	    Bounded real constants.

   pi, e
	    Intervals enclosing the constants pi and e respectively.

   inf
	    Floating point infinity.

   +Expr
	    Identity.

   -Expr
	    Sign change.

   +-Expr
	    Expr or -Expr.  The result is an interval enclosing both.

   abs(Expr)
	    The absolute value of Expr.

   E1+E2
	    Addition.

   E1-E2
	    Subtraction.

   E1*E2
	    Multiplication.

   E1/E2
	    Division.

   E1^E2
	    Exponentiation.

   min(E1,E2)
	    Minimum.

   max(E1,E2)
	    Maximum.

   sqr(Expr)
	    Square.  Logically equivalent to Expr*Expr, but with better 
	    operational behaviour.

   sqrt(Expr)
	    Square root (always positive).

   exp(Expr)
	    Same as e^Expr.

   ln(Expr)
	    Natural logarithm, the reverse of the exp function.

   sin(Expr)
	    Sine.

   cos(Expr)
	    Cosine.

   atan(Expr)
	    Arcus tangens.  (Returns value between -pi/2 and pi/2.)

   rsqr(Expr)
	    Reverse of the sqr function.  The same as +-sqrt(Expr).

   rpow(E1,E2)
	    Reverse of exponentiation. i.e. finds X in E1 = X^E2.

   sub(Expr)
	    A subinterval of Expr.

   sum(ExprList)
	    Sum of a list of expressions.

   min(ExprList)
	    Minimum of a list of expressions.

   max(ExprList)
	    Maximum of a list of expressions.

   and
	    Reified constraint conjunction.  e.g. X>3 and Y<8

   or
	    Reified constraint disjunction.  e.g. X>3 or Y<8

   =>
	    Reified constraint implication.  e.g. X>3 => Y<8

   neg
	    Reified constraint negation.  e.g. neg X>3

   $=, $\=, $>, $>=, $<, $=<, #=, #\=, #>, #>=, #<, #=<,
   =:=, =\=, >, >=, <, =<, and, or, =>, neg
	    Constraints whose value is taken as their reified truth value
	    (0..1).

   foo(Arg1, Arg2 ... ArgN), module:foo(Arg1, Arg2 ...  ArgN)
	    Call user-defined constraint/function foo.

   eval(Var)
	    Var will be an expression at run-time.
   


