
+Goal infers +Language

   Do generalized propagation over Goal according to the approximation Language.

Arguments
   +Goal               Callable Term.
   +Language           One of the terms most, unique, consistent, fd, ic, range or ac

Type
   library(propia)

Description
	Used to turn an arbitrary, nondeterministic Goal into a
	(deterministic) constraint, whose inference power is
	determined by the approximation Language. This is done using the
	Generalised Propagation Method (see T. Le Provost and M. Wallace,
	Domain-Independent Propagation, Proceedings of the FGCS'92, Tokyo,
	June 1992).
	
	The infers-predicate computes the most specific generalization
	of all the solutions of the Goal according to the approximation
	Language and delays if Goal has several non comparable solutions.
	
	With the language 'most', Goal is bound to the most specific
	generalization of all its solutions.  This generalisation will
	depend what solvers are loaded - (ic, fd, range or several of
	them).  If one of the solutions is not a variant of this
	answer, the goal is delayed until one of its variables is
	bound.  Note that the Goal may have an infinity of solutions.
	
	Using other languages, an approximation of this most specific
	generalization can be computed.  With the 'unique' language,
	infers/2 instantiates the Goal only if it has a unique
	solution (or the first solution of Goal subsumes all the
	others).  With the 'consistent' language, infers/2 does not
	bind the Goal but only checks if Goal has at least one
	solution.  The languages 'ic', 'fd' and 'range' extract the most
	specific generalisation expresssible using finite domains and
	ranges respectively.
	
	The language 'ac' implements generalised arc consistency on
	the table produced by computing all the (finitely) many
	solutions to the goal in advance. This requires that some solver
	implementing the element/3 constraint is loaded (fd, ic_global).
	

Resatisfiable
   No.

Fail Conditions
   Fails if Goal has no solution.

Exceptions
     4 --- Goal or Language is not instantiated.
     6 --- Language is not a correct language.
    68 --- Goal is an undefined procedure.

Examples
   
    Success:
	[eclipse]: member(X, [f(1), f(2)]) infers most.
        X = f(_g1)
        Delayed goals:
        member(f(_g1), [f(1), f(2)]) infers most
        yes.
	[eclipse]: [user].
	and(0, 0, 0).
        and(0, 1, 0).
	and(1, 0, 0).
	and(1, 1, 1).
	user       compiled traceable 528 bytes in 0.00 seconds
	yes.
	[eclipse]: and(0, X, Y).
	X = X
	Y = 0     More? (;)          % Prolog: two solutions
	X = 0
	Y = 0
	yes.
	[eclipse]: and(0, X, Y) infers most.
	X = X
	Y = 0
	yes.                         % Prolog + infers: one solution
	[eclipse]: [user].
	greater_than(succ(X), X).
	greater_than(succ(X), Y) :- greater_than(X, Y).
	user       compiled traceable 268 bytes in 0.00 seconds
	yes.
	[eclipse]: greater_than(X, zero).
	X = succ(zero)     More? (;) % Prolog: infinity of solutions
	...
	[eclipse]: greater_than(X, zero) infers most.
	X = succ(_g2)
	Delayed goals:
	    infers(greater_than(succ(_g2), zero), most, eclipse)
	yes.
        [eclipse]: lib(fd).
        ...
        [eclipse]: member(X, [f(1), f(2)]) infers most.
	X = f(_g3[1, 2])
	yes.
    Fail:
	[eclipse]: member(1, [2, 3]) infers consistent.
	no (more) solution.
    Error:
	Goal infers most. % Error 4
	true infers true.  % Error 6
    

See Also
   
