
construct_group(+Array, ++VarDimNames, ++ValueSpec, ++SymSpecs, ++GroupName, -MaxPoints, -ToPointPred, -FromPointPred)

   Constructs a GAP group based on the provided symmetry specification.

Arguments
   Array               The array of search variables
   VarDimNames         A list of symbolic names for each dimension in Array
   ValueSpec           The symbolic name for values and their range
   SymSpecs            A list of symmetry specifiers
   GroupName           The GAP name to give the constructed group (string)
   MaxPoints           The number of GAP points operated on by group
   ToPointPred         A predicate for converting a variable/value assignment to a GAP point
   FromPointPred       A predicate for converting a GAP point to a variable/value assignment

Type
   library(sym_expr)

Description
    This predicate is intended for use in conjunction with a
    GAP/ECLiPSe-based symmetry breaking method.  Given an array of search
    variables (Array) and a description of the symmetries, this predicate
    constructs the corresponding group in GAP (GroupName) and returns a pair
    of `to point' and `from point' predicates suitable for use in
    conjunction with it.

    In order to facilitate the expression of the symmetries, a list of
    symbolic names (VarDimNames) is required, to specify a symbolic name for
    each of the dimensions of Array.  Similarly, some way is needed to
    refer to the value `dimension'; this is provided by ValueSpec, which is
    of the form ValueName:ValueRange.  ValueRange specifies the range of
    values the variables may take (this is just used for constructing the
    group; it is not imposed on the variables) and must be of the form
    Lo..Hi.

    The symmetries (SymSpecs) are then specified by a list with entries of
    the form symmetry(Symmetry, SymmetryDimensions, OtherDimensions).
    Roughly speaking, Symmetry specifies the base symmetry,
    SymmetryDimensions specifies which dimensions it applies to, and
    OtherDimensions specifies which other dimensions should be treated
    specially with respect to this symmetry (if any).  The options for
    Symmetry are:

    s_n
	(1 dimension)
	Full permutation of the indices of the specified dimension.

    cycle
	(1 dimension)
	Indices may be cycled (i.e. all shifted k positions modulo the
	size of the dimension).

    r_4
	(2 dimensions)
	Rotational symmetry of the square.  The two dimensions specified
	must be of equal size.

    d_4
	(2 dimensions)
	Full symmetry of the square (i.e. including reflections).  The
	two dimensions specified must be of equal size.

    reverse
	(1 dimension)
	Indices may be reversed.

    gap_group(GroupFunc)
	(no fixed number of dimensions)
	The symmetries described by the group returned by the GAP
	function GroupFunc.  GroupFunc should accept a single argument,
	which is a list of the sizes of the dimensions that the symmetry is
	expected to act upon.  The mapping between GAP points and the
	elements of the subarray that this symmetry acts upon is obtained
	by numbering the indices of the elements in lexicographic order
	(first dimension most significant).  For example, if the symmetry
	subarray is of size MxN, then the element with index [I,J] is
	mapped to point (I-1)*N + J, so that [1,1]->1, [1,N]->N, [2,1]->N+1,
	etc.

    function(Func)
	(no fixed number of dimensions)
	Allows a generator to be specified via an ECLiPSe function Func,
	a la classic SBDS symmetry functions.  Func should accept three
	(extra) arguments: DimSizes, SrcIdx and DestIdx.  The first,
	DimSizes, is a list of the sizes of the dimensions that the symmetry
	is expected to act upon.  The second, SrcIdx, provides the index of
	an element of the subarray that the symmetry acts upon.  The third,
	DestIdx, should then be unified with the index of the element that
	SrcIdx is mapped to by this function.  For example, if the generator
	is intended to exchange the dimensions of a square array (i.e.
	reflect along the leading diagonal), if `swap_dim' is passed as
	Func, then the definition of `swap_dim' might be
	swap_dim([N, N], [I, J], [J, I]).
	Note that for 1-dimensional arrays, DestIdx may be returned as
	just an integer rather than a length-1 list containing the integer,
	if desired.

    table(Generator)
	(no fixed number of dimensions)
	Allows a generator to be specified via a lookup table.
	Generator must be an array of same size as the subarray the
	symmetry acts upon, with each element containing the index of the
	element that that element should be mapped to.
	Note that for 1-dimensional arrays, an index may be specified
	using just an integer rather than a length-1 list containing the
	integer, if desired.

    SymmetryDimensions must be a list with one entry for each dimension of
    the base symmetry.  Each entry must either be the name of a dimension,
    or of the form Dimension:IdxSpec, where Dimension is the name of a
    dimension and IdxSpec specifies a subset of the indices of that
    dimension.  IdxSpec may be an integer, an integer range L..H, or a list
    of these.  Providing such a qualification means that the symmetry is
    only applied to the specified indices of the dimension, not the
    dimension as a whole.

    By default, a symmetry affects the array as a whole; that is, for
    example, a symmetry applied to columns will affect all rows, and in
    particular all rows in the same way (it won't, say, swap columns 1 and 3
    in row 1, but swap 5 and 6 in row 2; the columns will be rearranged in
    the same way in every row).  If one or more indices for a dimension
    should be affected independently of the rest of the indices for that
    dimension, then this can be specified in the OtherDimensions field,
    which is a list of terms of the form Dimension:IdxSpec.  This specifies
    that the symmetry should only affect the given indices of the given
    dimension, independent of the other indices (the specified indices are
    still affected synchronously).  This allows one to express, for example,
    that the elements of a given row can be permuted, independent of the
    other rows.  If OtherDimensions is just the empty list, then it may be
    omitted.


    To do:
	Support multiple value dimensions
	Support multiple matrices
	More error checking...  :)



Examples
    Balanced Incomplete Block Design (BIBD)
	Standard model, with a 2-D array of booleans.
	Full row and column permutation.

	dim(Array, [NRows, NCols]),
	...
	construct_group(Array, [rows, cols], values:0..1, [
		    symmetry(s_n, [rows], []),
		    symmetry(s_n, [cols], [])
		], "bibd_group", MaxPoints, ToPointPred, FromPointPred)

    Social golfer problem
	Boolean model, with one boolean variable for each round/group/player
	combination.
	Full permutation of the rounds, full permutation of the groups in
	any round, and full permutation of the players.

	dim(Array, [NRounds, NGroups, NPlayers]),
	...
	construct_group(Array, [rounds, groups, players], values:0..1, [
		    symmetry(s_n, [rounds], []),
		    symmetry(s_n, [groups], [rounds:1]),
		    symmetry(s_n, [players], [])
		], "golf_group", MaxPoints, ToPointPred, FromPointPred)

	Note that the permutation of the groups within a round does not
	need to be specified for every round; the fact that the rounds are
	interchangeable means that it need only be specified for one round.

    N Queens problem
	Standard row model, with one integer for each row specifying which
	column the queen appears in.
	The symmetries of the square, including reflection, applied to the
	row/column combination.

	dim(Array, [NQueens]),
	...
	construct_group(Array, [rows], cols:1..NQueens, [
		    symmetry(d_4, [rows, cols], [])
		], "queens_group", MaxPoints, ToPointPred, FromPointPred)

    N Queens problem
	Boolean model, with one boolean for each location on the board,
	specifying whether a queen appears there or not.
	The symmetries of the square, including reflection.

	dim(Array, [NQueens, NQueens]),
	...
	construct_group(Array, [rows, cols], values:0..1, [
		    symmetry(d_4, [rows, cols], [])
		], "queens_group", MaxPoints, ToPointPred, FromPointPred)

	Note that the symmetry expression for this model is exactly the
	same as for the standard row model; whether the columns are values
	or a dimension of the variable array is irrelevant.



