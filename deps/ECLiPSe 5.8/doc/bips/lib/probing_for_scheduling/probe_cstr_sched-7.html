<HTML><HEAD><TITLE>probe_cstr_sched(+Starts, +Durations, +Resources, ++MaxResource, +Constraints, -Cost, ++Options)</TITLE>
</HEAD><BODY>[ <A HREF="index.html">library(probing_for_scheduling)</A> | <A HREF="../index.html">The ECLiPSe Libraries</A> | <A HREF="../../index.html">Reference Manual</A> | <A HREF="../../fullindex.html">Alphabetic Index</A> ]
<H1>probe_cstr_sched(+Starts, +Durations, +Resources, ++MaxResource, +Constraints, -Cost, ++Options)</H1>
Find a resource-feasible schedule that minimises the
cost, subject to the constraints
<DL>
<DT><EM>Starts</EM></DT>
<DD> A list of (n) task start times (integers or
finite domain variables)
</DD>
<DT><EM>Durations</EM></DT>
<DD>A list of (n) task durations (integers or
finite domain variables)
</DD>
<DT><EM>Resources</EM></DT>
<DD>A list of (n) task resource needs (integers)
</DD>
<DT><EM>MaxResource</EM></DT>
<DD>The available resource, not to be exceeded
</DD>
<DT><EM>Constraints</EM></DT>
<DD>A list of numeric equations and inequations, 
using functors '=:=', '&gt;=', '&gt;', '=&lt;' and '&lt;'.
</DD>
<DT><EM>Cost</EM></DT>
<DD>A numeric variable which will be minimised during search
</DD>
<DT><EM>Options</EM></DT>
<DD> A list, '[granularity(G),priority(P)]',
    where
    'G' is an integer specifying the time granularity, and
    'P' is the priority of the probe demon.
</DD>
</DL>
<H2>Description</H2>
<P> 
This offers the same functionality as <B>probe_sched/5</B>, but with added 
flexibility, and a more complex user interface.  The extra arguments offer 
the user  more control.  
</P><P>
The <B>Cost</B> argument is a variable, and it must be linked to the task 
variables by the list of linear constraints.  The user can add not only 
linear constraints on the cost function, but also constraints between the 
task variables.  Only constraints made explicit in this list are 'seen' by 
the probe.   <B>probe_cstr_sched</B> also posts them to the fd solver.
</P><P>
The options offer user control over
the temporal granularity, and the priority of the probe.
</P><P>
The algorithm uses <B>min_max</B>, but directs the search using a probe
which focusses the search on the optimum.  The probe is a procedure
that finds optimal solutions to a relaxed problem ignoring resource
limits.  For details see <B>setup_probe</B>.  Additionally the algorithm
sets up a binary variable between each pair of tasks, see
<B>make_overlap_bivs</B>.  Whenever the probe returns tentative start
times, these are propagated to the overlap binary variables yielding a
total resource usage which reveals any bottlenecks, where needed
resources exceed thos available.  <B>probe_search</B> then
non-deterministically introduces a new constraint which reduces the
bottleneck.
The probe_sched call:
<PRE>
probe_sched(Ss,Ds,Rs,MaxR,abs(X-X1)+Y)
</PRE>
translates into the probe_cstr_sched call:
<PRE>
probe_cstr_sched(Ss,Ds,Rs,MaxR,[Cost=:=E1+Y,E1>=X-X1,E1>=X1-X],Cost,
[granularity(1),priority(5)])
</PRE>
Thus making the default granularity '1' and the default priority '5'.

<H3>Resatisfiable</H3>
no
<H2>See Also</H2>
<A HREF="../../lib/probing_for_scheduling/probe_sched-5.html">probe_sched / 5</A>, <A HREF="../../lib/fd/min_max-2.html">fd : min_max / 2</A>, <A HREF="../../lib/ic_probe/set_up_probe-5.html">ic_probe : set_up_probe / 5</A>, <A HREF="../../lib/probe/set_up_probe-5.html">probe : set_up_probe / 5</A>, <A HREF="../../lib/ic_make_overlap_bivs/make_overlap_bivs-5.html">ic_make_overlap_bivs : make_overlap_bivs / 5</A>, <A HREF="../../lib/make_overlap_bivs/make_overlap_bivs-5.html">make_overlap_bivs : make_overlap_bivs / 5</A>, <A HREF="../../lib/ic_probe_search/probe_search-5.html">ic_probe_search : probe_search / 5</A>, <A HREF="../../lib/probe_search/probe_search-5.html">probe_search : probe_search / 5</A>
</BODY></HTML>
