<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Internal data representation</TITLE>
<META NAME="description" CONTENT="Internal data representation">
<META NAME="keywords" CONTENT="tutorial">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="tutorial.css">
<LINK REL="previous" HREF="node15.html">
<LINK REL="up" HREF="node14.html">
<LINK REL="next" HREF="node17.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html585"
 HREF="node17.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html579"
 HREF="node14.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html575"
 HREF="node15.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html581"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html583"
 HREF="node78.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html586"
 HREF="node17.html">Getting it to Work</A>
<B> Up:</B> <A NAME="tex2html580"
 HREF="node14.html">Data Structures</A>
<B> Previous:</B> <A NAME="tex2html576"
 HREF="node15.html">External data representation</A>
 &nbsp <B>  <A NAME="tex2html582"
 HREF="node1.html">Contents</A></B> 
 &nbsp <B>  <A NAME="tex2html584"
 HREF="node78.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html587"
 HREF="node16.html#SECTION00421000000000000000">Named structures</A>
<LI><A NAME="tex2html588"
 HREF="node16.html#SECTION00422000000000000000">Placeholder variables</A>
<LI><A NAME="tex2html589"
 HREF="node16.html#SECTION00423000000000000000">Nested structures vs. key lookup</A>
<LI><A NAME="tex2html590"
 HREF="node16.html#SECTION00424000000000000000">Lists</A>
<LI><A NAME="tex2html591"
 HREF="node16.html#SECTION00425000000000000000">Hash tables</A>
<LI><A NAME="tex2html592"
 HREF="node16.html#SECTION00426000000000000000">Vectors and arrays</A>
<LI><A NAME="tex2html593"
 HREF="node16.html#SECTION00427000000000000000">Multi-representation structures</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00420000000000000000">
Internal data representation</A>
</H1>
The next question is how the data should be represented inside <A NAME="368"></A>the application. For this purpose we will have to introduce data structures<A NAME="369"></A> which allow rapid access to information, which deal with multiple data sets in different parts of the application and where we can add information in a structured way. It should be clear that the built-in fact data base cannot be used for this purpose. Instead, we have to pass the information via arguments of the predicates. In the following sections, we will discuss how the data should be structured to simplify access and coding.

<P>
Note that all our data structures use <I>single assignment</I><A NAME="371"></A>, i.e. there is no destructive assignment<A NAME="372"></A> in the language<A NAME="tex2html11"
 HREF="footnode.html#foot373"><SUP>3.2</SUP></A>. Instead of removing<A NAME="374"></A><A NAME="375"></A><A NAME="376"></A> or changing elements of a structuce, we will always make a near-copy with some information being removed or changed. 

<P>

<H2><A NAME="SECTION00421000000000000000">
Named structures</A>
</H2>
The principal data representation feature of ECLiPSe are named structures<A NAME="378"></A><A NAME="379"></A>. These are terms were each argument is linked to an argument name. We can access one or more of the arguments with the <I>with</I><A NAME="381"></A> operator. Named structures are very similar to structures in other languages, the arguments of the structure correspond to attributes of the entity represented. Different attributes can have different types, so that we can store diverse information in a named structure.

<P>
In order to use a structure, it must be defined with a <I>struct</I><A NAME="383"></A> definition. We can define a structure either <I>local</I><A NAME="385"></A> to a module or <I>export</I> <A NAME="387"></A>the definition so that the same structure can be used in other modules which import the definition. As part of a systematic design we normally create a module which contains nothing but exported structure definitions. This module is then imported with a <I>use_module</I><A NAME="389"></A> directive in all other modules of the application which use the structures. If a structure is used in one module only, we should define it as a local structure in that module.

<P>
We also use comment directives to document the named structures, just like we do for exported predicates. For each attribute name, we define the data type of the attribute. Normally, these will be atomic data types <A NAME="390"></A>(integer, real, atom, string), but that is not required. The attribute can hold any data type that we can pass as an argument to a predicate. 

<P>
As an example of a named structure we use a small part of the RiskWise module <I>flow_structures</I><A NAME="392"></A>. 
<PRE>
:-comment(struct(group),[
summary:"
this data structure describes the group object
",
fields:[
"name":"atom, name of the group",
"type":"atom, one of pop, interconntion, vpn or tariff_class",
"index":"integer, unique index of the group",
"list":"list of interface indices belonging to the group",
"nodes":"list of nodes which contain interfaces of that group"
]
]).
:-export struct(group(name,
                      type,
                      index,
                      list,
                      nodes)).
</PRE>

<P>

<H2><A NAME="SECTION00422000000000000000"></A>
<A NAME="396"></A>
<BR>
Placeholder variables
</H2>If we do not specify a fixed attribute value when the named structure is created, then its value will be a free variable which can be bound later on. This is useful for two main purposes. On one side we can define attributes of a structure which will hold the constraint variables<A NAME="397"></A> of a problem, on the other side we can leave some attributes initially unassigned so that we can fill these slots with results of a computation later on.

<P>

<H2><A NAME="SECTION00423000000000000000"></A>
<A NAME="399"></A><A NAME="400"></A>
<BR>
Nested structures vs. key lookup
</H2>A very common data representation problem is how to access information about some structure from another structure, for example in RiskWise how to access the information about a router from an interface of the router. There are two main alternatives. The first is to insert the data of the first entity (router) directly in the representation of the second entity (interface) as an additional attribute, the second is to store a key which can be used to look up the entity. Although the first method has the advantage of avoiding the extra lookup, we do not recommend this approach. If we have recursive references to objects (in our example above if the router also contains a link to all its interfaces) then this direct representation becomes an infinite data structure, which causes problems for printing and debugging. If we use the second approach, we obviously need a way to find the entity belonging to a particular key without too much overhead. The choice of the key depends on the representation of our overall data structure, which we will discuss in the next sections.

<P>

<H2><A NAME="SECTION00424000000000000000">
Lists</A>
</H2>
A natural way to represent a collection of items of the same type is to use lists<A NAME="402"></A>. They are very convenient to handle an arbitrary number of items by iterating on successive heads of the list, until the empty list is reached. Unfortunately, finding a particular item in a list is a very expensive operation, as we have to scan the list sequentially.

<P>
We should never use a list when we can use a structure<A NAME="403"></A> instead. If we know that a collection will always have the same number of items (say 3), it is much better to use a structure with that number of arguments than to use a list. 

<P>

<H2><A NAME="SECTION00425000000000000000">
Hash tables</A>
</H2>
Hash tables<A NAME="405"></A> are a very useful alternative to lists, if we sometimes want to look up items rather than iterate over all of them. They are defined in the library <I>hash</I>.
We can add items one by one, without an a priori limit on the number of items.
As key <A NAME="407"></A>we can use numbers, atoms or arbitrary terms, but atoms would be the most common key in a hash table. This is very useful when converting input data, since the external data representation often will use names (atoms) to identify objects.

<P>
While it is possible to iterate over all items of a hash table, this is not as simple as iteration over a list or an array.

<P>

<H2><A NAME="SECTION00426000000000000000">
Vectors and arrays</A>
</H2>
Vectors<A NAME="409"></A> are another way to represent a collection of items. Each item is associated with an integer key in the range from 1 to <I>N</I>, where <I>N</I> is the size of the vector. Unfortunately, the value <I>N</I> must be known a priori, when we first create the vector. Accessing individual entries by index is very fast, and iterating over all entries is nearly as simple as for lists. The main drawbacks of a vector representation are that we have to know the total number of items beforehand and that the keys must be consecutive integers in the range from 1 to <I>N</I>.

<P>
Multi-dimensional arrays <A NAME="410"></A>are simple nested vectors, they are created with the <I>dim</I> <A NAME="412"></A>predicate for a given dimension and size. Access to an element is with the <I>subscript</I><A NAME="414"></A> predicate (see section <A HREF="node29.html#iterationonarray">5.5</A> for an example).

<P>

<H2><A NAME="SECTION00427000000000000000">
Multi-representation structures</A>
</H2>
Each of the alternative representations given above has some advantages and disadvantages. To obtain a very flexible representation, we can choose a multi-representation structure<A NAME="417"></A>. In this structure, a collection of items is represented as a list and as a hash table and as an array. The list representation can be used for a very simple iteration over all items, the hash table is used in the initial data input phase to find items with a given name and the array of items is used in the core routines of the solver for the fastest access by an integer index. 

<P>
The memory requirements of this multi-representation scheme are quite low. The storage to hold the items themselves is shared for all representations, we only need the additional space for the list, hash table and array structures.

<P>
In RiskWise<A NAME="418"></A>, we use the multi-representation scheme for most data structures, with special access predicates like <I>find_interface/3</I><A NAME="420"></A> to access items with either numeric indices or atom keys. References from one entity to another are by integer key, e.g. each interface structure contains as an attribute the integer key value of the node (router) to which it belongs.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html585"
 HREF="node17.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html579"
 HREF="node14.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html575"
 HREF="node15.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html581"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html583"
 HREF="node78.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html586"
 HREF="node17.html">Getting it to Work</A>
<B> Up:</B> <A NAME="tex2html580"
 HREF="node14.html">Data Structures</A>
<B> Previous:</B> <A NAME="tex2html576"
 HREF="node15.html">External data representation</A>
 &nbsp <B>  <A NAME="tex2html582"
 HREF="node1.html">Contents</A></B> 
 &nbsp <B>  <A NAME="tex2html584"
 HREF="node78.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
