<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Approximate Generalised Propagation</TITLE>
<META NAME="description" CONTENT="Approximate Generalised Propagation">
<META NAME="keywords" CONTENT="libman">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="libman.css">
<LINK REL="previous" HREF="node41.html">
<LINK REL="up" HREF="node39.html">
<LINK REL="next" HREF="node43.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html1448"
 HREF="node43.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1444"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1440"
 HREF="node41.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1446"
 HREF="node71.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1449"
 HREF="node43.html">The Constraint Handling Rules</A>
<B> Up:</B> <A NAME="tex2html1445"
 HREF="node39.html">Propia - A Library</A>
<B> Previous:</B> <A NAME="tex2html1441"
 HREF="node41.html">Invoking and Using Propia</A>
 &nbsp <B>  <A NAME="tex2html1447"
 HREF="node71.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00730000000000000000"></A>
<A NAME="approx"></A><A NAME="2786"></A>
<A NAME="2787"></A>
<A NAME="2788"></A>
<BR>
Approximate Generalised Propagation
</H1>

<P>
The syntax <EM>Goal infers most</EM> can also be varied to invoke
different levels of Generalised Propagation.  Other alternatives are
<EM>Goal infers ic</EM>, 
<EM>Goal infers unique</EM>, and <EM>Goal infers consistent</EM>.
The strongest constraint is generated by <EM>Goal infers most</EM>,
but it can be expensive to compute.  The other alternatives may be
evaluated more efficiently, and may yield a better overall performance
on different applications.
We call them ``approximations'', since the information they produce
during propagation is a (weaker) approximation of the information
produced by the strongest constraint.

<P>
We illustrate the different approximations supported by the current
version of Propia on a single small example.
The results for <EM>Goal infers most</EM> reflect the problem that
structured terms cannot appear in <code>IC</code> integer domains.<PRE>
 
p(1,a).
p(2,f(Z)).
p(3,3).
</PRE>
<P><PRE>
?- p(X, Y) infers most.
X = X{1 .. 3}
Y = Y
There is 1 delayed goal.
Yes (0.00s cpu)

?- X :: 1 .. 3, p(X, Y) infers most.
X = X{1 .. 3}
Y = Y
There is 1 delayed goal.
Yes (0.00s cpu)

?- p(2, Y) infers most.
Y = f(_326)
There is 1 delayed goal.
Yes (0.00s cpu)
</PRE> 
The first approximation we will introduce in this section 
is one that searches for the unique answer to
the query.
It is written <EM>Goal infers unique</EM>.
This is cheap because as soon as two different answers to the query
have been found, the constraint evaluation terminates and the
constraint is delayed again until new information becomes available.
Here are two examples of this approximation.
In the first example notice that no domain is produced for <EM>X</EM>.<PRE>
?- p(X, Y) infers unique.
X = X
Y = Y
There is 1 delayed goal.
Yes (0.00s cpu)
</PRE>
In the second example, by contrast, <code>infers unique</code> yields the same
result as <code>infers most</code>: <PRE>
 
?- p(X,X) infers unique.
X = 3
Yes (0.00s cpu)
</PRE>

<P>
The next example shows that  <EM>unique</EM> can even capture
nonground answers:<PRE>
?- p(2, X) infers unique.
X = f(Z)
Yes (0.00s cpu)
</PRE>

<P>
The next approximation we shall describe is even weaker: it tests if there is an
answer and if not it fails.
If there is an answer it checks to see if the constraint is already
true.

<P><PRE>
?- p(1, X) infers consistent.
X = X
There is 1 delayed goal.
Yes (0.00s cpu)

?- p(1, a) infers consistent.
Yes (0.00s cpu)

?- p(1, X) infers consistent, X = b.
No (0.00s cpu)
</PRE>

<P>
The strongest language <code>infers most</code> extracts any information
possible from the loaded constraint solvers.  The solvers currently
handled by Propia are <EM>unification</EM> (which is the built-in solver
of Prolog), <EM>ic</EM> and <EM>ic_symbolic</EM>.  The <code>IC</code> library is
loaded by <code>lib(ic)</code> and the symbolic library by
<code>lib(ic_symbolic)</code>.  These libraries are described elsewhere.  If
both libraries are loaded, then <code>infers most</code> extracts
information from unification, <code>IC</code> domains and symbolic domains.  For example:<PRE>
 
 p(f(X),1) :- X *&gt;=0, X *=&lt; 10.
 p(f(X),1) :- X=12.
</PRE>
with the above program<PRE>
 
?- p(X, Y) infers most.
X = f(_338{0.0 .. 12.0})
Y = Y{[1, 2]}
There is 1 delayed goal.
Yes (0.00s cpu)
</PRE>

<P>
The approximation <code>infers ic</code> is
similar to <code>infers most</code>.  However, while <code>infers most</code>
extracts information based on whatever constraint solvers are loaded, 
the others only infers information derived from the specified constraint
solver.
Here's the same example using <code>infers ic</code>:<PRE>
 
?- p(X, Y) infers ic.
X = f(_353{0.0 .. 12.0})
Y = Y{[1, 2]}
There is 1 delayed goal.
Yes (0.00s cpu)
</PRE>

<P>
One rather special approximation langue is <code>infers ac</code>, where
<code>ac</code> stands for arc-consistency.
This has similar semantics to <code>infers ic</code>, but is implemented
very efficiently using the built-in <code>element</code> constraint of the
<code>IC</code> solver.
The limitation is that <code>Goal infers ac</code> is implemented by
executing the goal repeatedly to find all the solutions, and then
manipulating the complete set of solutions.
It will only work in case there are finitely many solutions and they
are all ground.  

<P>
Finally it is possible to invoke Propia in such a way as to influence
its waking conditions.  To do this, use the standard
<code>suspend</code> syntax.  For example ``forward checking'' can be
implemented as follows:<PRE>
propagate(Goal,fc) :- !,
    suspend(Goal,7,Goal-&gt;inst) infers most.
</PRE>
In this case the Propia constraint wakes up each time a variable in
the goal is instantiated.   

<P>
The default priority for
Propia constraints is 3.
However, in the above example, the priority of the Propia
constraint has been set to 7.

<P>

<P>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html1448"
 HREF="node43.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1444"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1440"
 HREF="node41.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1446"
 HREF="node71.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1449"
 HREF="node43.html">The Constraint Handling Rules</A>
<B> Up:</B> <A NAME="tex2html1445"
 HREF="node39.html">Propia - A Library</A>
<B> Previous:</B> <A NAME="tex2html1441"
 HREF="node41.html">Invoking and Using Propia</A>
 &nbsp <B>  <A NAME="tex2html1447"
 HREF="node71.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey <BR>
2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
