<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Introduction</TITLE>
<META NAME="description" CONTENT="Introduction">
<META NAME="keywords" CONTENT="libman">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="libman.css">
<LINK REL="next" HREF="node12.html">
<LINK REL="previous" HREF="node10.html">
<LINK REL="up" HREF="node10.html">
<LINK REL="next" HREF="node12.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html995"
 HREF="node12.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html991"
 HREF="node10.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html985"
 HREF="node10.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html993"
 HREF="node71.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html996"
 HREF="node12.html">Common constraints</A>
<B> Up:</B> <A NAME="tex2html992"
 HREF="node10.html">Common Solver Interface</A>
<B> Previous:</B> <A NAME="tex2html986"
 HREF="node10.html">Common Solver Interface</A>
 &nbsp <B>  <A NAME="tex2html994"
 HREF="node71.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00210000000000000000">
Introduction</A>
</H1>
ECLiPSe now provides a common syntax for the main arithmetic constraints
provided by different constraint solvers.
The basic idea is that the name and syntax of the constraint determines the
declarative meaning, while the operational semantics (the algorithmic
constraint behaviour) is determined by the module which implements the
constraint.
This principle simplifies the development of applications that use
hybrid solution methods. Constraints can be passed easily to different,
even multiple, solvers.

<P>
<BR> <HR>
<ADDRESS>
<I>Warwick Harvey <BR>
2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
