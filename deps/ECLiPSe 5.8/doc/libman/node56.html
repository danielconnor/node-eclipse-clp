<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Advanced Use of Eplex Instances</TITLE>
<META NAME="description" CONTENT="Advanced Use of Eplex Instances">
<META NAME="keywords" CONTENT="libman">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="libman.css">
<LINK REL="next" HREF="node57.html">
<LINK REL="previous" HREF="node55.html">
<LINK REL="up" HREF="node53.html">
<LINK REL="next" HREF="node57.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html1735"
 HREF="node57.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1731"
 HREF="node53.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1725"
 HREF="node55.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1733"
 HREF="node71.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1736"
 HREF="node57.html">Low-Level Solver Interface</A>
<B> Up:</B> <A NAME="tex2html1732"
 HREF="node53.html">EPLEX: The ECLiPSe/LP/MIP Interface</A>
<B> Previous:</B> <A NAME="tex2html1726"
 HREF="node55.html">Eplex Instances</A>
 &nbsp <B>  <A NAME="tex2html1734"
 HREF="node71.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html1737"
 HREF="node56.html#SECTION00931000000000000000">Obtaining Solver State Information</A>
<LI><A NAME="tex2html1738"
 HREF="node56.html#SECTION00932000000000000000">Creating Eplex Instances Dynamically</A>
<LI><A NAME="tex2html1739"
 HREF="node56.html#SECTION00933000000000000000">Interface for CLP-Integration: Solver Demons</A>
<UL>
<LI><A NAME="tex2html1740"
 HREF="node56.html#SECTION00933100000000000000">EplexInstance:eplex_solver_setup(+Objective, -Cost, +ListOfOptions, +TriggerModes)</A>
<LI><A NAME="tex2html1741"
 HREF="node56.html#SECTION00933200000000000000">Example</A>
</UL>
<LI><A NAME="tex2html1742"
 HREF="node56.html#SECTION00934000000000000000">Probing Using a Different Objective</A>
<UL>
<LI><A NAME="tex2html1743"
 HREF="node56.html#SECTION00934100000000000000">EplexInstance:eplex_probe(+Probes, -Cost)</A>
</UL>
<LI><A NAME="tex2html1744"
 HREF="node56.html#SECTION00935000000000000000">Destroying the Solver State</A>
<UL>
<LI><A NAME="tex2html1745"
 HREF="node56.html#SECTION00935100000000000000">EplexInstance:eplex_cleanup</A>
</UL>
<LI><A NAME="tex2html1746"
 HREF="node56.html#SECTION00936000000000000000">Eplex Instance Interface Example: definition of optimize/2:</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00930000000000000000"></A>
<A NAME="eplex-instance-advanced"></A>
<BR>
Advanced Use of Eplex Instances
</H1>

<P>

<H2><A NAME="SECTION00931000000000000000"></A>
<A NAME="eplex-instance-solver-info"></A>
<BR>
Obtaining Solver State Information
</H2>
The black-box interface binds both the objective value (Cost) and the
problem variables by bindings these variables. On the other hand, <B>  eplex_solve/1</B> binds the objective value, but does not bind the problem
variables. These values can be obtained by:

<P>

<DL>
<DT><STRONG><A NAME="tex2html461"
 HREF="../bips/lib/eplex/eplex_var_get-3.html">EplexInstance:eplex_var_get(+Var, +What, -Value)</A><A NAME="4508"></A></STRONG>
<DD><P>
Retrieve information about the solver state associated with the eplex
instance for the variable <TT>Var</TT>. If <TT>What</TT> is <TT>solution</TT> or
<TT>typed_solution</TT>, then the value assigned to this variable by the
solver state to obtain the optimal solution is returned in <TT>Value</TT>. <TT>solution</TT> returns the value as a float, and <TT>typed_solution</TT> returns the value as either a float or a rounded integer, depending
on if the variable was constrained to an integer in the eplex problem.

<P>
<DT><STRONG><A NAME="tex2html463"
 HREF="../bips/lib/eplex/eplex_get-2.html">EplexInstance:eplex_get(+What, -Value)</A><A NAME="4511"></A></STRONG>
<DD><P>
Retrieve information about solver state associated with the eplex instance.
This returns information such as the problem type, the constraints for the
eplex problem. See the reference manual for more details.

<P>
<DT><STRONG><A NAME="tex2html465"
 HREF="../bips/lib/eplex/eplex_set-2.html">EplexInstance:eplex_set(+What, +Value)</A><A NAME="4514"></A></STRONG>
<DD>Set a solver option for the eplex instance. 
<DT><STRONG><A NAME="tex2html467"
 HREF="../bips/lib/eplex/eplex_write-2.html">EplexInstance:eplex_write(+Format, +File)</A><A NAME="4517"></A></STRONG>
<DD>Write out the problem in the the eplex instance's solver state to the file
File in format Format. The writing is done by the external solver. Use the
use_var_name(yes) option in
<A NAME="tex2html471"
 HREF="../bips/lib/eplex/eplex_solver_setup-4.html">eplex_solver_setup/4</A><A NAME="4520"></A>
so that the written file uses ECLiPSevariable names. Also the <TT>write_before_solve</TT> option of eplex_solver_setup/4 can be used to write out
a problem just before it is solved by the external solver: this allows
problem to be written in places where eplex_write/2 cannot be added
(e.g. for probing problems)..

<P>
<DT><STRONG><A NAME="tex2html469"
 HREF="../bips/lib/eplex/eplex_read-2.html">EplexInstance:eplex_read(+Format, +File)</A><A NAME="4523"></A></STRONG>
<DD>Read a MP problem in the file File in format Format into a solver state,
and associate the solver with the eplex instance. No solver must already be
setup for the eplex instance. The solver state that is setup can only be
triggered explicitly.

<P>
</DL>

<P>
So for the simple MIP example:
<PRE>
:- lib(eplex).
:- eplex_instance(my_instance).

mip_example2([X,Y], Cost) :-
     my_instance: (X+Y $&gt;= 3),
     my_instance: (X-Y $= 0),
     my_instance: integers([X]),
     my_instance: eplex_solver_setup(min(X)),
     my_instance: eplex_solve(Cost),
     my_instance: eplex_var_get(X, typed_solution, X),
     my_instance: eplex_var_get(Y, typed_solution, Y).

....
[eclipse 2]: mip_example2([X,Y],C).

X = 2
Y = 2.0
C = 2.0
</PRE>

<P>
In the example, only X is returned as an integer, as Y was not explicitly
constrained to be an integer.

<P>
Note that if there are multiple eplex instances, and a variable is shared
between the instances, then the solver state for each instance can have a
different optimal value to the variable.

<P>

<H2><A NAME="SECTION00932000000000000000"></A>
<A NAME="4167"></A>
<BR>
Creating Eplex Instances Dynamically
</H2>
So far, we have shown the use of <TT>eplex_instance/1</TT> as a directive to
declare an eplex instance. For some applications, it might be necessary to
create eplex instances dynamically at run-time. The can be done by calling
<TT>eplex_instance/1</TT> at run-time.
In this case, the instance name should <EM>not</EM> be used to module-qualify
any predicates in the code, since this will raise a compiler warning
complaining about an unknown module.

<P>
<PRE>
   new_pool(X,Y) :- % INCORRECT
eplex_instance(pool),
      pool: (X $&gt;= Y), % will generate a warning
...
</PRE>

Of course, in the above code, the instance name <TT>pool</TT> is already known
at compile time, so it can always be declared by a directive.

<P>
If the name is truly generated dynamically, this can be done as follows:
<PRE>
   new_pool(Pool,X,Y) :-
       eplex_instance(Pool),
       Pool: (X $&gt;= Y),
       ....
</PRE>

<P>

<H2><A NAME="SECTION00933000000000000000">
Interface for CLP-Integration: Solver Demons</A>
</H2>

<P>
To implement hybrid algorithms where a run of a simplex/MIP solver is only
a part of the global solving process, the black-box model presented above
is not appropriate anymore. With eplex instances, we can call <TT>eplex_solve/1</TT> repeatedly to re-solve the problem, perhaps after adding
more constraints to the problem or after changes in the variable
bounds. However, the solver must be invoked explicitly. We require more
sophisticated methods of invoking the solver. This can be done by setting
up a solver demon, and specifying the conditions in which the demon is to
wake up and invoke the external solver.

<P>

<H3><A NAME="SECTION00933100000000000000"></A><A NAME="4526"></A>
<BR>
<A NAME="tex2html474"
 HREF="../bips/lib/eplex/eplex_solver_setup-4.html">EplexInstance:eplex_solver_setup(+Objective, -Cost, +ListOfOptions, +TriggerModes)</A>
</H3>
This is a more sophisticated set up for a new solver state than
<TT>eplex_solver_setup/1</TT> (in fact eplex_solver_setup/1 is a special case
of eplex_solver_setup/4).
The main idea is that a list of trigger conditions
are specified in <TT>TriggerModes</TT>, and along with setting up the solver
state, a demon goal is created which is woken up when one of the
specified trigger condition is met. This demon goal will then invoke the
solver, with any 
constraints posted to the eplex instance since the solver was last invoked
taken into account, to re-solve the problem. 

<P>
The <TT>ListOfOptions</TT> is a list of solver options for setting up the
solver state. Some of these affect the way the external solver solves the
problem, such as if presolve should be applied before solving the problem.
See the reference manual for <A NAME="tex2html476"
 HREF="../bips/lib/eplex/eplex_solver_setup-4.html">eplex_solver_setup/4</A><A NAME="4529"></A> for
details on the available options and trigger modes.

<P>
As the solver is designed to be invoked repeatedly, it is inappropriate to
directly bind <TT>Cost</TT> to the objective value. Instead, the objective
value is exported as a bound to Cost:
For a minimization problem, each solution's
cost becomes a lower bound, for maximization an upper bound on Cost.
This technique allows for repeated re-solving with reduced variable bounds
or added constraints. Note that the bound update is done only if the
solution is optimal. Note also that Cost is not automatically 
made a problem variable, and thus may not have bounds associated
with in. In order for the bounds information not to be lost, some bounds
should be given to Cost (e.g. making it a problem variable (but
this might introduce unnecessarily self-waking on bounds change), or via
another solver with bounds (e.g. ic)). 

<P>
<A NAME="4187"></A>
Note that when a solver demon runs frequently on relatively small problems,
it can be important for efficiency to switch the external solver's
presolving off for this demon as part of the <TT>ListOfOptions</TT> during the
setup of the problem to reduce overheads.

<P>

<H3><A NAME="SECTION00933200000000000000">
Example</A>
</H3>

<P>
The simplest case of having a simplex solver automatically cooperating
with a CLP program, is to set up a solver demon which will repeatedly
check whether the continuous relaxation of a set of constraints
is still feasible.
The code could look as follows (we use the eplex instance in this example):
<PRE>
simplex :-
    eplex:eplex_solver_setup(min(0), C, [solution(no)], [bounds]).
</PRE>
First, the constraints are normalised and checked for linearity.
Then a solver with a dummy objective function is set up. The option
<TT>solution(no)</TT> indicates that we are not interested in solution values.
Then we start a solver demon which will re-examine the problem
whenever a change of variable bounds occurs.
The demon can be regarded as a compound constraint implementing the
conjunction of the individual constraints. It is able to detect
some infeasibilities that for instance could not be detected by a
finite domains solver, e.g.
<PRE>
[eclipse 2]: eplex:(X+Y+Z =&lt; 1),
    eplex_solver_setup(min(0), C, [solution(no)], [bounds]),
    K = 2.

No (0.00s cpu)
</PRE>
In the example, the initial simplex is successful, but instantiating
K wakes the demon again, and the simplex fails this time.

<P>
A further step is to take advantage of the cost bound that the simplex
procedure provides. To do this, we need to give the objective 
The setup is similar to above, but we accept an objective function and
add a cost variable. The bounds of the cost variable will be updated
whenever a simplex invocation finds a better cost bound on the problem.
In the example below, an upper bound for the cost of 1.5 is found
initially:
<PRE>
[eclipse 5]: ic: (Cost $:: -1.0Inf..1.0Inf), 
      eplex:(X+Y $=&lt; 1), eplex:(Y+Z $=&lt; 1), eplex:(X+Z $=&lt; 1),
      eplex:eplex_solver_setup(max(X+Y+Z), Cost, [solution(no)], [bounds]).

X = X{-1e+20 .. 1e+20}
Y = Y{-1e+20 .. 1e+20}
Z = Z{-1e+20 .. 1e+20}
Cost = Cost{-1.0Inf .. 1.500001}


Delayed goals:
        lp_demon(prob(...), ...)
Yes (0.00s cpu)
</PRE>
(Note that the ranges for X, Y and Z is -1e+20 .. 1e+20 as 1e+20 is this
external solver's notion of infinity). 

<P>
If the variable bounds change subsequently, the solver will be re-triggered,
improving the cost bound to 1.3:
<PRE>
[eclipse 6]: ic: (Cost $:: -1.0Inf..1.0Inf), 
      eplex:(X+Y $=&lt; 1), eplex:(Y+Z $=&lt; 1), eplex:(X+Z $=&lt; 1),
      eplex:eplex_solver_setup(max(X+Y+Z), Cost, [solution(no)], [bounds]), 
      eplex:(Y =&lt; 0.3).

X = X{-1e+20 .. 1e+20}
Z = Z{-1e+20 .. 1e+20}
Cost = Cost{-1.0Inf .. 1.300001}
Y = Y{-1e+20 .. 0.3}


Delayed goals:
        lp_demon(prob(...), ...)
Yes (0.00s cpu)
</PRE>

<P>
A further example is the implementation of a MIP-style branch-and-bound
procedure. Source code is provided in the library file mip.pl.

<P>

<H2><A NAME="SECTION00934000000000000000">
Probing Using a Different Objective</A>
</H2>

<P>
The external mathematical programming solvers often provides the facility
for the user to change the problem being solved. This includes the addition
or removal of constraints, and the changing of the objective function.
We have already seen how extra constraints can be added. As ECLiPSe is a
logic programming language, removal of constraints is automatically
achieved by backtracking. We do not allow the user to explicitly remove
constraints that have been collected by the external solver, as this makes 
the problem non-monotonic.
For the same reason, we do not allow the objective function to be
changed.<A NAME="tex2html479"
 HREF="footnode.html#foot4454"><SUP>9.1</SUP></A>However, we do allow the problem (including the objective function) to be
<I>temporarily</I> changed in certain specified ways. This allows the
problem to be `probed' with these changes:

<P>

<H3><A NAME="SECTION00934100000000000000"></A><A NAME="4532"></A>
<BR>
<A NAME="tex2html480"
 HREF="../bips/lib/eplex/eplex_probe-2.html">EplexInstance:eplex_probe(+Probes, -Cost)</A>
</H3>
Similar to eplex_solve/1, but the problem is first temporarily modified as
specified in Probes before the optimisation. The Cost value
is instantiated to the objective value for this new modified problem, and
any solution state requested are also updated. 

<P>

<H2><A NAME="SECTION00935000000000000000">
Destroying the Solver State</A>
</H2>

<H3><A NAME="SECTION00935100000000000000"></A><A NAME="4535"></A>
<BR>
<A NAME="tex2html482"
 HREF="../bips/lib/eplex/eplex_cleanup-0.html">EplexInstance:eplex_cleanup</A>
</H3>

<P>
Destroy the specified solver, free all memory, etc.
Note that ECLiPSe will normally do the cleanup automatically,
for instance when execution fails across the solver setup, or
when a solver handle gets garbage collected. The solver is disassociated
with the eplex instance, and any outstanding constraints not yet collected
by the  solver are removed, with a warning to the user. In effect, the
eplex instance is reinitialised.

<P>
Note that this is a non-logical operation. Backtracking into code before 
<TT>eplex_cleanup/0</TT> will not restore the solver state, and any attempt to
reuse the solver state will not be possible (the execution will abort with
an error). Normally, it is recommended to let ECLiPSe perform the cleanup 
automatically,
for instance when execution fails across the solver setup, or
when an unused solver state handle gets garbage collected.
However, calling eplex_cleanup/0 may
cause resources (memory and licence) to be freed earlier.

<P>

<H2><A NAME="SECTION00936000000000000000"></A>
<A NAME="defoptimize"></A>
<BR>
Eplex Instance Interface Example: definition of optimize/2:
</H2>
A black-box setup-and-solve predicate <B>optimize/2</B> can be defined as:
<PRE>
optimize(OptExpr, ObjVal) :-
        eplex:eplex_solver_setup(OptExpr),
        eplex:eplex_solve(ObjVal),
        eplex:eplex_get(vars, VArr),
        eplex:eplex_get(typed_solution, SolutionVector),
        VArr = SolutionVector, % do the bindings
eplex:eplex_cleanup.
</PRE>
A solver state is set up for the eplex instance <TT>eplex</TT>, to allow
constraints that were previously posted to <TT>eplex</TT> to be collected.
This happens once the solver is invoked by <TT>eplex_solve/1</TT>. If there
is a solution, the solution vector is obtained, and the
variables are instantiated to those solutions.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html1735"
 HREF="node57.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1731"
 HREF="node53.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1725"
 HREF="node55.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html1733"
 HREF="node71.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1736"
 HREF="node57.html">Low-Level Solver Interface</A>
<B> Up:</B> <A NAME="tex2html1732"
 HREF="node53.html">EPLEX: The ECLiPSe/LP/MIP Interface</A>
<B> Previous:</B> <A NAME="tex2html1726"
 HREF="node55.html">Eplex Instances</A>
 &nbsp <B>  <A NAME="tex2html1734"
 HREF="node71.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey <BR>
2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
