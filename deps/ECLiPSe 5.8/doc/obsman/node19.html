<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Program Examples</TITLE>
<META NAME="description" CONTENT="Program Examples">
<META NAME="keywords" CONTENT="obsman">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="obsman.css">
<LINK REL="next" HREF="node20.html">
<LINK REL="previous" HREF="node18.html">
<LINK REL="up" HREF="node2.html">
<LINK REL="next" HREF="node20.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html622"
 HREF="node20.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html618"
 HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html612"
 HREF="node18.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html620"
 HREF="node34.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html623"
 HREF="node20.html">Current Known Restrictions and</A>
<B> Up:</B> <A NAME="tex2html619"
 HREF="node2.html">The Finite Domains Library</A>
<B> Previous:</B> <A NAME="tex2html613"
 HREF="node18.html">Example of Defining a</A>
 &nbsp <B>  <A NAME="tex2html621"
 HREF="node34.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html624"
 HREF="node19.html#SECTION002171000000000000000">Constraining Variable Pairs</A>
<UL>
<LI><A NAME="tex2html625"
 HREF="node19.html#SECTION002171100000000000000">User-Defined Constraints</A>
<LI><A NAME="tex2html626"
 HREF="node19.html#SECTION002171200000000000000">Using the <I>element</I> Constraint</A>
<LI><A NAME="tex2html627"
 HREF="node19.html#SECTION002171300000000000000">Using Evaluation Constraints</A>
<LI><A NAME="tex2html628"
 HREF="node19.html#SECTION002171400000000000000">Using Generalised Propagation</A>
<LI><A NAME="tex2html629"
 HREF="node19.html#SECTION002171500000000000000">Using Constraint Handling Rules</A>
</UL>
<LI><A NAME="tex2html630"
 HREF="node19.html#SECTION002172000000000000000">Puzzles</A>
<LI><A NAME="tex2html631"
 HREF="node19.html#SECTION002173000000000000000">Bin Packing</A>
<UL>
<LI><A NAME="tex2html632"
 HREF="node19.html#SECTION002173100000000000000">Capacity Constraints</A>
<LI><A NAME="tex2html633"
 HREF="node19.html#SECTION002173200000000000000">Containment Constraints</A>
<LI><A NAME="tex2html634"
 HREF="node19.html#SECTION002173300000000000000">Requirement Constraints</A>
<LI><A NAME="tex2html635"
 HREF="node19.html#SECTION002173400000000000000">Exclusive Constraints</A>
<LI><A NAME="tex2html636"
 HREF="node19.html#SECTION002173500000000000000">Atmost Constraints</A>
<LI><A NAME="tex2html637"
 HREF="node19.html#SECTION002173600000000000000">Ordering Constraints</A>
<LI><A NAME="tex2html638"
 HREF="node19.html#SECTION002173700000000000000">Labeling</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION002170000000000000000">
Program Examples</A>
</H1>
In this section we present some FD programs that show various
aspects of the library usage.
More examples can be found on the <A NAME="tex2html211"
 HREF="http://www.icparc.ic.ac.uk/eclipse/">ECLiPSe web site
http://www.icparc.ic.ac.uk/eclipse/</A>.

<P>

<H2><A NAME="SECTION002171000000000000000">
Constraining Variable Pairs</A>
</H2>
The finite domain library gives the user the possibility
to impose constraints on the value of a variable.
How, in general, is it possible to impose constraints on two
or more variables?
For example, let us assume that we have a set of colours and we
want to define that some colours fit with each other and others do not.
This should work in such a way as to propagate possible changes
in the domains as soon as this becomes possible.

<P>
Let us assume we have a symmetric relation that defines which
colours fit with each other:<PRE>
% The basic relation
fit(yellow, blue).
fit(yellow, red).
fit(blue, yellow).
fit(red, yellow).
fit(green, orange).
fit(orange, green).
</PRE>

<P>
The predicate <B>nice_pair(X, Y)</B> is a constraint and any change of
the possible values of X or Y is propagated
to the other variable.
There are many ways in which this pairing can be defined in ECLiPSe.
They are different solutions with different properties, but
they yield the same results.

<P>

<H3><A NAME="SECTION002171100000000000000">
User-Defined Constraints</A>
</H3>
We use more or less directly the low-level primitives to handle
finite domain variables.
We collect all consistent values for the two variables, remove
all other values from their domains and then suspend
the predicate until one of its arguments is updated:<PRE>
nice_pair(A, B) :-
 % get the domains of both variables
dvar_domain(A, DA),         
    dvar_domain(B, DB),         
 % make a list of respective matching colours
setof(Y, X^(dom_member(X, DA), fit(X, Y)), BL),
    setof(X, Y^(dom_member(Y, DB), fit(X, Y)), AL),
 % convert the lists to domains
sorted_list_to_dom(AL, DA1),
    sorted_list_to_dom(BL, DB1),
 % intersect the lists with the original domains
dom_intersection(DA, DA1, DA_New, _),
    dom_intersection(DB, DB1, DB_New, _),
 % and impose the result on the variables
dvar_update(A, DA_New),
    dvar_update(B, DB_New),
 % unless one variable is already instantiated, suspend
% and wake as soon as any element of the domain is removed
    (var(A), var(B) -&gt;
        suspend(nice_pair(A, B), 2, [A,B]-&gt;any)
    ;
        true
    ).

% Declare the domains
colour(A) :-
    findall(X, fit(X, _), L),
    A :: L.
</PRE>

<P>
After defining the domains, we can state the constraints:<PRE>
[eclipse 5]: colour([A,B,C]), nice_pair(A, B), nice_pair(B, C), A #\= green.

B = B{[blue, green, red, yellow]}
C = C{[blue, orange, red, yellow]}
A = A{[blue, orange, red, yellow]}
 
Delayed goals:
  nice_pair(A{[blue, orange, red, yellow]}, B{[blue, green, red, yellow]})
  nice_pair(B{[blue, green, red, yellow]}, C{[blue, orange, red, yellow]})
</PRE>

<P>
This way of defining new constraints is often the most efficient
one, but usually also the most tedious one.

<P>

<H3><A NAME="SECTION002171200000000000000">
Using the <I>element</I> Constraint</A>
</H3>
In this case we use the available primitive in the fd library. Whenever
it is necessary to associate a fd variable with some other fd variable,
the <A NAME="tex2html212"
 HREF="../bips/lib/fd/element-3.html">element/3</A><A NAME="1322"></A> constraint is a likely candidate. Sometimes it is
rather awkward to use, because additional variables must be used,
but it gives enough power:

<P><PRE>
nice_pair(A, B) :-
    element(I, [yellow, yellow, blue, red, green, orange], A),
    element(I, [blue, red, yellow, yellow, orange, green], B).
</PRE>

<P>
We define a new variable <B>I</B> which is a sort of index into the
clauses of the fit predicate. The first colour list contains
colours in the first argument of fit/2 and the second list
contains colours from the second argument. The propagation is similar
to that of the previous one.

<P>
When <A NAME="tex2html214"
 HREF="../bips/lib/fd/element-3.html">element/3</A><A NAME="1325"></A> can be used, it is usually faster
than the previous approach, because <A NAME="tex2html216"
 HREF="../bips/lib/fd/element-3.html">element/3</A><A NAME="1328"></A> is partly
implemented in C.

<P>

<H3><A NAME="SECTION002171300000000000000">
Using Evaluation Constraints</A>
</H3>
We can also encode directly the relations between elements
in the domains of the two variables:

<P><PRE>
nice_pair(A, B) :-
    np(A, B),
    np(B, A).

np(A, B) :-
    [A,B] :: [yellow, blue, red, orange, green],
    A #= yellow #=&gt; B :: [blue, red],
    A #= blue #=&gt; B #= yellow,
    A #= red #=&gt; B #= yellow,
    A #= green #=&gt; B #= orange,
    A #= orange #=&gt; B #= green.
</PRE>

<P>
This method is quite simple and does not need any special analysis;
on the other hand it potentially creates a huge number of
auxiliary constraints and variables.

<P>

<H3><A NAME="SECTION002171400000000000000">
Using Generalised Propagation</A>
</H3>
Propia is the first candidate to convert an existing relation into
a constraint. One can simply use <B>infers most</B> to achieve the propagation:

<P><PRE>
nice_pair(A, B) :-
    fit(A, B) infers most.
</PRE>

<P>
Using Propia is usually very easy and the programs are short
and readable, so that this style of constraints writing
is quite useful e.g. for teaching.
It is not as efficient as with user-defined constraints, but
if the amount of propagation is more important that the efficiency
of the constraint itself, it can yield good results, too.

<P>

<H3><A NAME="SECTION002171500000000000000">
Using Constraint Handling Rules</A>
</H3>
The <TT>domain</TT> solver in <I>CHR</I> can be used directly with the
<A NAME="tex2html218"
 HREF="../bips/lib/fd/element-3.html">element/3</A><A NAME="1331"></A> constraint as well, however it is also possible
to define directly domains consisting of pairs:<PRE>
:- lib(chr).
:- chr(lib(domain)).

nice_pair(A, B) :-
    setof(X-Y, fit(X, Y), L),
    A-B :: L.
</PRE>

<P>
The pairs are then constrained accordingly:<PRE>
[eclipse 2]: nice_pair(A, B), nice_pair(B, C), A ne orange.

B = B
C = C
A = A

Constraints:
(9) A_g1484 - B_g1516 :: [blue - yellow, green - orange, red - yellow,
yellow - blue, yellow - red]
(10) A_g1484 :: [blue, green, red, yellow]
(12) B_g1516 - C_g3730 :: [blue - yellow, orange - green, red - yellow,
yellow - blue, yellow - red]
(13) B_g1516 :: [blue, orange, red, yellow]
(14) C_g3730 :: [blue, green, red, yellow]
</PRE>

<P>

<H2><A NAME="SECTION002172000000000000000">
Puzzles</A>
</H2>
Various kinds of puzzles can be easily solved using finite domains.
We show here the classical Lewis Carrol's puzzle with five houses and a zebra:<PRE>
Five men with different nationalities live in the first five houses
of a street.  They practise five distinct professions, and each of
them has a favourite animal and a favourite drink, all of them
different.  The five houses are painted in different colours.

The Englishman lives in a red house.
The Spaniard owns a dog.
The Japanese is a painter.
The Italian drinks tea.
The Norwegian lives in the first house on the left.
The owner of the green house drinks coffee.
The green house is on the right of the white one.
The sculptor breeds snails.
The diplomat lives in the yellow house.
Milk is drunk in the middle house.
The Norwegian's house is next to the blue one.
The violinist drinks fruit juice.
The fox is in a house next to that of the doctor.
The horse is in a house next to that of the diplomat.

Who owns a Zebra, and who drinks water?
</PRE>

<P>
One may be tempted to define five variables Nationality,
Profession, Colour, etc. with atomic domains to represent
the problem.
Then, however, it is quite difficult to express equalities
over these different domains.
A much simpler solution is to define 5x5 integer variables for each
mentioned item, to number the houses from one to five
and to represent the fact that e.g. Italian drinks tea
by equating Italian = Tea.
The value of both variables represents then the number of their house.
In this way, no special constraints are needed and
the problem is very easily described:<PRE>
:- lib(fd).

zebra([zebra(Zebra), water(Water)]) :-
    Sol = [Nat, Color, Profession, Pet, Drink],
    Nat = [English, Spaniard, Japanese, Italian, Norwegian],
    Color = [Red, Green, White, Yellow, Blue],
    Profession = [Painter, Sculptor, Diplomat, Violinist, Doctor],
    Pet = [Dog, Snails, Fox, Horse, Zebra],
    Drink = [Tea, Coffee, Milk, Juice, Water],

 % we specify the domains and the fact
% that the values are exclusive
    Nat :: 1..5,
    Color :: 1..5,
    Profession :: 1..5,
    Pet :: 1..5,
    Drink :: 1..5,
    alldifferent(Nat),
    alldifferent(Color),
    alldifferent(Profession),
    alldifferent(Pet),
    alldifferent(Drink),

 % and here follow the actual constraints
English = Red,
    Spaniard = Dog,
    Japanese = Painter,
    Italian = Tea,
    Norwegian = 1,
    Green = Coffee,
    Green #= White + 1,
    Sculptor = Snails,
    Diplomat = Yellow,
    Milk = 3,
    Dist1 #= Norwegian - Blue, Dist1 :: [-1, 1],
    Violinist = Juice,
    Dist2 #= Fox - Doctor, Dist2 :: [-1, 1],
    Dist3 #= Horse - Diplomat, Dist3 :: [-1, 1],

    flatten(Sol, List),
    labeling(List).
</PRE>

<P>

<H2><A NAME="SECTION002173000000000000000">
Bin Packing</A>
</H2>
In this type of problems the goal is to pack a certain amount of
different things into the minimal number of bins under specific constraints.
Let us solve an example given by Andre Vellino in the Usenet
group comp.lang.prolog, June 93:

<UL><LI>There are 5 types of components:

<P>
glass, plastic, steel, wood, copper

<P>

<LI>There are three types of bins:

<P>
red, blue, green

<P>

<LI>whose capacity constraints are:

<P>

<UL><LI>red   has capacity 3

<LI>blue  has capacity 1

<LI>green has capacity 4

</UL>

<P>

<LI>containment constraints are:

<UL><LI>red   can contain glass, wood, copper

<LI>blue  can contain glass, steel, copper

<LI>green can contain plastic, wood, copper

</UL>

<P>

<LI>and requirement constraints are (for all bin types):

<P>
wood requires plastic

<P>

<LI>Certain component types cannot coexist:

<P>

<UL><LI>glass  exclusive copper

<LI>copper exclusive plastic

</UL>

<P>

<LI>and certain bin types have capacity constraint for certain
components

<P>

<UL><LI>red   contains at most 1 of wood

<LI>green contains at most 2 of wood

</UL>

<P>

<LI>Given an initial supply of:
1 of glass,
2 of plastic,
1 of steel,
3 of wood,
2 of copper,
what is the minimum total number of bins required to
contain the components?

</UL>

<P>
To solve this problem, it is not enough to state constraints on some
variables and to start a labeling procedure on them.
The variables are namely not known, because we don't know how many
bins we should take.
One possibility would be to take a large enough number of bins
and to try to find a minimum number.
However, usually it is better to generate constraints
for an increasing fixed number of bins until a solution is found.

<P>
The predicate <B>solve/1</B> returns the solution for this
particular problem, <B>solve_bin/2</B> is the general predicate
that takes an amount of components packed into a <B>cont/5</B>
structure and it returns the solution.<PRE>
solve(Bins) :-
    solve_bin(cont(1, 2, 1, 3, 2), Bins).
</PRE>

<P>
<B>solve_bin/2</B> computes the sum of all components which is necessary
as a limit value for various domains, calls <B>bins/4</B> to
generate a list <B>Bins</B> with an increasing number of elements
and finally it labels all variables in the list:<PRE>
solve_bin(Demand, Bins) :-
    Demand = cont(G, P, S, W, C),
    Sum is G + P + S + W + C,
    bins(Demand, Sum, [Sum, Sum, Sum, Sum, Sum, Sum], Bins),
    label(Bins).
</PRE>

<P>
The predicate to generate a list of bins with appropriate
constraints works as follows:
first it tries to match the amount of remaining components with zero
and the list with nil.
If this fails, a new bin represented by a list
<P>
<BLOCKQUOTE><B>[Colour, Glass, Plastic, Steel, Wood, Copper]</B>
</BLOCKQUOTE>
<P>
is added to the bin list,
appropriate constraints are imposed on all the new bin's
variables,
its contents is subtracted from the remaining number of components,
and the predicate calls itself recursively:

<P><PRE>
bins(cont(0, 0, 0, 0, 0), 0, _, []).
bins(cont(G0, P0, S0, W0, C0), Sum0, LastBin, [Bin|Bins]) :-
    Bin = [_Col, G, P, S, W, C],
    bin(Bin, Sum),
    G2 #= G0 - G,
    P2 #= P0 - P,
    S2 #= S0 - S,
    W2 #= W0 - W,
    C2 #= C0 - C,
    Sum2 #= Sum0 - Sum,
    ordering(Bin, LastBin),
    bins(cont(G2, P2, S2, W2, C2), Sum2, Bin, Bins).
</PRE>
The <B>ordering/2</B> constraints are strictly necessary because
this problem has a huge number of symmetric solutions.

<P>
The constraints imposed on a single bin correspond exactly to the
problem statement:<PRE>
bin([Col, G, P, S, W, C], Sum) :-
    Col :: [red, blue, green],
    [Capacity, G, P, S, W, C] :: 0..4,
    G + P + S + W + C #= Sum,
    Sum #&gt; 0, % no empty bins
Sum #&lt;= Capacity,
    capacity(Col, Capacity),
    contents(Col, G, P, S, W, C),
    requires(W, P),
    exclusive(G, C),
    exclusive(C, P),
    at_most(1, red, Col, W),
    at_most(2, green, Col, W).
</PRE>

<P>
We will code all of the special constraints with the
maximum amount of propagation to show how this can be
achieved.
In most programs, however, it is not necessary to
propagate all values everywhere which simplifies the
code quite considerably.
Often it is also possible to use some of the built-in symbolic
constraints of ECLiPSe, e.g. <A NAME="tex2html220"
 HREF="../bips/lib/fd/element-3.html">element/3</A><A NAME="1334"></A> or <A NAME="tex2html222"
 HREF="../bips/lib/fd/atmost-3.html">atmost/3</A><A NAME="1337"></A>.

<P>

<H3><A NAME="SECTION002173100000000000000">
Capacity Constraints</A>
</H3>
<B>capacity(Color, Capacity)</B> should instantiate the capacity
if the colour is known, and reduce the colour values
if the capacity is known to be greater than
some values.
If we use evaluation constraints, we can code the constraint directly,
using equivalences:<PRE>
capacity(Color, Capacity) :-
    Color #= blue #&lt;=&gt; Capacity #= 1,
    Color #= green #&lt;=&gt; Capacity #= 4,
    Color #= red #&lt;=&gt; Capacity #= 3.
</PRE>

<P>
A more efficient code would take into account the ordering on the
capacities.
Concretely, if the capacity is greater than 1, the colour cannot
be blue and if it is greater than 3, it must be green:

<P><PRE>
capacity(Color, Capacity) :-
    var(Color),
    !,
    dvar_domain(Capacity, DC),
    dom_range(DC, MinC, _),
    (MinC &gt; 1 -&gt;
        Color #\= blue,
        (MinC &gt; 3 -&gt;
            Color = green
        ;
            suspend(capacity(Color, Capacity), 3, (Color, Capacity)-&gt;inst)
        )
    ;
        suspend(capacity(Color, Capacity), 3, [Color-&gt;inst, Capacity-&gt;min])
    ).
capacity(blue, 1).
capacity(green, 4).
capacity(red, 3).
</PRE>
Note that when suspended, the predicate waits for colour instantiation
or for minimum of the capacity to be updated (except that 3 is one less
than the maximum capacity and thus waiting for its instantiation
is equivalent).

<P>

<H3><A NAME="SECTION002173200000000000000">
Containment Constraints</A>
</H3>
The containment constraints are stated as logical expressions
and this is also the easiest way to medel them.
The important point to remember is that a condition like
<I>red can contain glass, wood, copper</I>
actually means
<I>red cannot contain plastic or steel</I>
which can be written as

<P><PRE>
contents(Col, G, P, S, W, _) :-
    Col #= red #=&gt; P #= 0 #/\ S #= 0,
    Col #= blue #=&gt; P #= 0 #/\ W #= 0,
    Col #= green #=&gt; G #= 0 #/\ S #= 0.
</PRE>

<P>
If we want to model the containment with low-level domain predicates,
it is easier to state them in the equivalent conjugate form:

<UL><LI>glass can be contained in red or blue

<LI>plastic can be contained in green

<LI>steel can be contained in blue

<LI>wood can be contained in red, green

<LI>copper can be contained in red, blue, green

</UL>

<P>
or in a further equivalent form that uses at most one bin colour:

<UL><LI>glass can not be contained in green

<LI>plastic can be contained in green

<LI>steel can be contained in blue

<LI>wood can not be contained in blue

<LI>copper can be contained in anything

</UL>

<P><PRE>
contents(Col, G, P, S, W, _) :-
    not_contained_in(Col, G, green),
    contained_in(Col, P, green),
    contained_in(Col, S, blue),
    not_contained_in(Col, W, blue).
</PRE>

<P>
<B>contained_in(Color, Component, In)</B> states that
if Color is different from In, there can be no such component
in it, i.e. Component is zero:<PRE>
contained_in(Col, Comp, In) :-
    nonvar(Col),
    !,
    (Col \== In -&gt;
        Comp = 0
    ;
        true
    ).
contained_in(Col, Comp, In) :-
    dvar_domain(Comp, DM),
    dom_range(DM, MinD, _),
    (MinD &gt; 0 -&gt;
        Col = In
    ;
        suspend(contained_in(Col, Comp, In), 2, [Comp-&gt;min, Col-&gt;inst])
    ).
</PRE>

<P>
<B>not_contained_in(Color, Component, In)</B> states that if the bin is of the given
colour, the component cannot be contained in it:<PRE>
not_contained_in(Col, Comp, In) :-
    nonvar(Col),
    !,
    (Col == In -&gt;
        Comp = 0
    ;
        true
    ).
not_contained_in(Col, Comp, In) :-
    dvar_domain(Comp, DM),
    dom_range(DM, MinD, _),
    (MinD &gt; 0 -&gt;
        Col #\= In
    ;
        suspend(not_contained_in(Col, Comp, In), 2, [Comp-&gt;min, Col-&gt;any])
    ).
</PRE>

<P>
As you can see again, modeling with the low-level domain predicates
might give a faster and more precise programs,
but it is much more difficult than using constraint
expressions and evaluation constraints.
A good approach is thus to start with constraint expressions
and only if they are not efficient enough, to (stepwise) recode
some or all constraints with the low-level predicates.

<P>

<H3><A NAME="SECTION002173300000000000000">
Requirement Constraints</A>
</H3>
The constraint `A requires B' is written as

<P><PRE>
requires(A, B) :-
    A #&gt; 0 #=&gt; B #&gt; 0.
</PRE>

<P>
With low-level predicates,
the constraint `A requires B' is woken as soon as some
A is present or B is known:<PRE>
requires(A, B) :-
    nonvar(B),
    !,
    ( B = 0 -&gt;
        A = 0
    ;
        true
    ).
requires(A, B) :-
    dvar_domain(A, DA),
    dom_range(DA, MinA, _),
    ( MinA &gt; 0 -&gt;
        B #&gt; 0
    ;
        suspend(requires(A, B), 2, [A-&gt;min, B-&gt;inst])
    ).
</PRE>

<P>

<H3><A NAME="SECTION002173400000000000000">
Exclusive Constraints</A>
</H3>
The exclusive constraint can be written as<PRE>
exclusive(A, B) :-
    A #&gt; 0 #=&gt; B #= 0,
    B #&gt; 0 #=&gt; A #= 0.
</PRE>
however a simple form with one disjunction is enough:<PRE>
exclusive(A, B) :-
    A #= 0 #\/ B #= 0.
</PRE>

<P>
With low-level domain predicates,
the exclusive constraint defines a suspension which is woken
as soon as one of the two components is present:<PRE>
exclusive(A, B) :-
    dvar_domain(A, DA),
    dom_range(DA, MinA, MaxA),
    ( MinA &gt; 0 -&gt;
        B = 0
    ; MaxA = 0 -&gt;
 % A == 0
true
    ;
        dvar_domain(B, DB),
        dom_range(DB, MinB, MaxB),
        ( MinB &gt; 0 -&gt;
            A = 0
        ; MaxB = 0 -&gt;
 % B == 0
true
        ;
            suspend(exclusive(A, B), 3, (A,B)-&gt;min)
        )
    ).
</PRE>

<P>

<H3><A NAME="SECTION002173500000000000000">
Atmost Constraints</A>
</H3>
<B>at_most(N, In, Colour, Components)</B> states that if Colour
is equal to In, then there can be at most N Components
and vice versa, if there are more than N Components, the colour
cannot be In.
With constraint expressions, this can be simply coded as<PRE>
at_most(N, In, Col, Comp) :-
    Col #= In #=&gt; Comp #&lt;= N.
</PRE>

<P>
A low-level solution looks as follows:<PRE>
at_most(N, In, Col, Comp) :-
    nonvar(Col),
    !,
    (In = Col -&gt;
        Comp #&lt;= N
    ;
        true
    ).
at_most(N, In, Col, Comp) :-
    dvar_domain(Comp, DM),
    dom_range(DM, MinM, _),
    (MinM &gt; N -&gt;
        Col #\= In
    ;
        suspend(at_most(N, In, Col, Comp), 2, [In-&gt;inst, Comp-&gt;min])
    ).
</PRE>

<P>

<H3><A NAME="SECTION002173600000000000000">
Ordering Constraints</A>
</H3>
To filter out symmetric solutions we can e.g. impose a lexicographic
ordering on the bins in the list, i.e. the second bin must be
lexicographically greater or equal than the first one etc.
As long as the corresponding most significant
variables in two consecutive bins
are not instantiated, we cannot constrain the following ones
and thus we suspend the ordering on the <B>inst</B> lists:

<P><PRE>
ordering([], []).
ordering([Val1|Bin1], [Val2|Bin2]) :-
    Val1 #&lt;= Val2,
    (integer(Val1) -&gt;
        (integer(Val2) -&gt;
            (Val1 = Val2 -&gt;
                ordering(Bin1, Bin2)
            ;
                true
            )
        ;
            suspend(ordering([Val1|Bin1], [Val2|Bin2]), 2, Val2-&gt;inst)
        )
    ;
        suspend(ordering([Val1|Bin1], [Val2|Bin2]), 2, Val1-&gt;inst)
    ).
</PRE>

<P>
There is a problem with the representation of the colour:
If the colour is represented by an atom, we cannot apply
the <B>#<code>&lt;=</code>/2</B> predicate on it.
To keep the ordering predicate simple and still have a symbolic
representation of the colour in the program, we can define
input macros that transform the colour atoms into integers:

<P><PRE>
:- define_macro(no_macro_expansion(blue)/0, tr_col/2, []).
:- define_macro(no_macro_expansion(green)/0, tr_col/2, []).
:- define_macro(no_macro_expansion(red)/0, tr_col/2, []).

tr_col(no_macro_expansion(red), 1).
tr_col(no_macro_expansion(green), 2).
tr_col(no_macro_expansion(blue), 3).
</PRE>

<P>

<H3><A NAME="SECTION002173700000000000000">
Labeling</A>
</H3>
A straightforward labeling would be to flatten the list with
the bins and use e.g. <A NAME="tex2html224"
 HREF="../bips/lib/fd/deleteff-3.html">deleteff/3</A><A NAME="1340"></A> to label a variable out of it.
However, for this example not all variables have the same
importance -- the colour variables propagate much more data
when instantiated.
Therefore, we first filter out the colours and label
them before all the component variables:<PRE>
label(Bins) :-
    colours(Bins, Colors, Things),
    flatten(Things, List),
    labeleff(Colors),
    labeleff(List).

colours([], [], []).
colours([[Col|Rest]|Bins], [Col|Cols], [Rest|Things]) :-
    colours(Bins, Cols, Things).

labeleff([]).
labeleff(L) :-
    deleteff(V, L, Rest),
    indomain(V),
    labeleff(Rest).
</PRE>

<P>
Note also that we need a special version of <B>flatten/3</B>
that works with nonground lists.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html622"
 HREF="node20.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html618"
 HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html612"
 HREF="node18.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html620"
 HREF="node34.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html623"
 HREF="node20.html">Current Known Restrictions and</A>
<B> Up:</B> <A NAME="tex2html619"
 HREF="node2.html">The Finite Domains Library</A>
<B> Previous:</B> <A NAME="tex2html613"
 HREF="node18.html">Example of Defining a</A>
 &nbsp <B>  <A NAME="tex2html621"
 HREF="node34.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey <BR>
2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
