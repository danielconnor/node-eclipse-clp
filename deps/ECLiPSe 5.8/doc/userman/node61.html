<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Communication via Streams</TITLE>
<META NAME="description" CONTENT="Communication via Streams">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node62.html">
<LINK REL="previous" HREF="node60.html">
<LINK REL="up" HREF="node59.html">
<LINK REL="next" HREF="node62.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3167"
 HREF="node62.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3163"
 HREF="node59.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3157"
 HREF="node60.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3165"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3168"
 HREF="node62.html">In-memory Streams</A>
<B> Up:</B> <A NAME="tex2html3164"
 HREF="node59.html">Input and Output</A>
<B> Previous:</B> <A NAME="tex2html3158"
 HREF="node60.html">Streams</A>
 &nbsp <B>  <A NAME="tex2html3166"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html3169"
 HREF="node61.html#SECTION001021000000000000000">Character I/O</A>
<LI><A NAME="tex2html3170"
 HREF="node61.html#SECTION001022000000000000000">Token I/O</A>
<LI><A NAME="tex2html3171"
 HREF="node61.html#SECTION001023000000000000000">Term I/O</A>
<LI><A NAME="tex2html3172"
 HREF="node61.html#SECTION001024000000000000000">General Parsing and Text Generation</A>
<LI><A NAME="tex2html3173"
 HREF="node61.html#SECTION001025000000000000000">Flushing</A>
<LI><A NAME="tex2html3174"
 HREF="node61.html#SECTION001026000000000000000">Prompting</A>
<LI><A NAME="tex2html3175"
 HREF="node61.html#SECTION001027000000000000000">Positioning</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION001020000000000000000">
Communication via Streams</A>
</H1>
The contents of a stream may be interpreted in one of the
three basic ways.
The first one is to
consider it as a sequence of characters, so that the basic unit to
be read or written is a character. The second one interprets
the stream as a sequence of tokens, thus providing an interface
to the Prolog lexical analyzer and the third one is to consider a stream as
a sequence of Prolog terms.

<P>

<H2><A NAME="SECTION001021000000000000000">
Character I/O</A>
</H2>
The <A NAME="tex2html783"
 HREF="../bips/kernel/iochar/get-1.html">get/1, 2</A><A NAME="5934"></A> and <A NAME="tex2html785"
 HREF="../bips/kernel/iochar/put-1.html">put/1, 2</A><A NAME="5937"></A>
<A NAME="5595"></A>
<A NAME="5596"></A>
<A NAME="5597"></A>
<A NAME="5598"></A>
predicates corresponds to the first way
of looking at streams. The call<PRE>
get(Char)
</PRE> takes the next character
from
the current input stream and matches it as a single character with Char.
Note that a character in ECLiPSe is represented as an integer corresponding
to the ASCII code of the character.
If the end of file has been reached then an exception is raised.
The call<PRE>
put(Char)
</PRE> puts the char Char on to the current output
stream.
The predicates<PRE>
get(Stream, Char)
</PRE> and<PRE>
put(Stream, Char)
</PRE> work similarly on the specified stream.

<P>
The input and output is normally buffered by ECLiPSe.
To make I/O in <I>raw mode</I>, without buffering, the predicates
<A NAME="tex2html791"
 HREF="../bips/kernel/iochar/tyi-1.html">tyi/1, 2</A><A NAME="5940"></A> and <A NAME="tex2html793"
 HREF="../bips/kernel/iochar/tyo-1.html">tyo/1, 2</A><A NAME="5943"></A> are provided.
<A NAME="5622"></A>
<A NAME="5623"></A>
<A NAME="5624"></A>
<A NAME="5625"></A>

<P>

<H2><A NAME="SECTION001022000000000000000"></A>
<A NAME="5627"></A>
<BR>
Token I/O
</H2>
The predicates
<A NAME="tex2html800"
 HREF="../bips/kernel/iochar/read_token-2.html">read_token/2</A><A NAME="5946"></A> and
<A NAME="tex2html802"
 HREF="../bips/kernel/iochar/read_token-3.html">read_token/3</A><A NAME="5949"></A><PRE>
read_token(Token, Class)
read_token(Stream, Token, Class)
</PRE>
represent the second way of interpreting stream contents.
They read the next token from the current
input stream, unify it with <I>Token</I>,
and its token class is unified with <I>Class</I>.
A token is either a sequence of characters with the same or compatible
<A NAME="5638"></A>
character class, e.g. ab_1A, then it is a Prolog constant
or variable, or a single character, e.g. ')'.
<A NAME="5639"></A>
The token class represents the type of the token and
its special meaning, e.g. <TT>fullstop</TT>, <TT>comma</TT>, <TT>open_par</TT>, etc.
The exact definition of character classes and tokens can be found in
appendices <A HREF="node142.html#charclass">A.2.1</A> and <A HREF="node142.html#tokendef">A.2.3</A>, respectively.

<P>
A further, very flexible possibility to read a sequence of
characters is provided by the built-ins
<A NAME="tex2html806"
 HREF="../bips/kernel/iochar/read_string-3.html">read_string/3</A><A NAME="5952"></A> and
<A NAME="tex2html808"
 HREF="../bips/kernel/iochar/read_string-4.html">read_string/4</A><A NAME="5955"></A><PRE>
read_string(Delimiters, Length, String)
read_string(Stream, Delimiters, Length, String)
</PRE>
Here, the input is read up to a specified delimiter or up to a specified
length, and returned as an ECLiPSe string.

<P>
In particular, one line of input can be read as follows:<PRE>
read_line(Stream, String) :-
    read_string(Stream, end_of_line, _Length, String).
</PRE>
Once a string has been read, string manipulation predicates like
<A NAME="tex2html810"
 HREF="../bips/kernel/stratom/split_string-4.html">split_string/4</A><A NAME="5958"></A>
can be used to break it up into smaller components.

<P>

<H2><A NAME="SECTION001023000000000000000">
Term I/O</A>
</H2>
The <A NAME="tex2html812"
 HREF="../bips/kernel/ioterm/read-1.html">read/1, 2</A><A NAME="5961"></A> and <A NAME="tex2html814"
 HREF="../bips/kernel/ioterm/write-1.html">write/1, 2</A><A NAME="5964"></A> predicates  correspond to
<A NAME="5665"></A>
<A NAME="5666"></A>
<A NAME="5667"></A>
<A NAME="5668"></A>
the third way of looking at streams.
For input, the goal <PRE>
read(Term)
</PRE> reads the next ECLiPSe term from the current input
stream and unifies it with <I>Term</I>. The input term must be followed by a
full stop, that is, a '.' character followed by a layout
character (tab, space or newline) or by the end of file.
The exact definition of the term syntax can be found in appendix
<A HREF="node140.html#chapsyntax">A</A>.

<P>
If end of file has been reached then
an exception is raised, the default handler causes the atom
<I>end_of_file</I> to be returned.
A term may be read from a stream other than the current input stream by
the call <PRE>
read(Stream, Term)
</PRE> which reads the term from the
named stream.

<P>
For additional information about other options for reading terms,
in particular for how to get variable names, refer to
<A NAME="tex2html820"
 HREF="../bips/kernel/ioterm/readvar-3.html">readvar/3</A><A NAME="5967"></A>,
<A NAME="tex2html822"
 HREF="../bips/kernel/ioterm/read_term-2.html">read_term/2</A><A NAME="5970"></A> and
<A NAME="tex2html824"
 HREF="../bips/kernel/ioterm/read_term-3.html">read_term/3</A><A NAME="5973"></A>.
For reading and processing complete ECLiPSe source code files, use the
<A NAME="tex2html826"
 HREF="../bips/lib/source_processor/index.html">library(source_processor)</A><A NAME="5976"></A>.

<P>
For output, the goal <PRE>
write(Term)
</PRE> writes <I>Term</I> to the current output stream.
<A NAME="5695"></A>
<A NAME="5696"></A>
This is done by taking the current operator declarations into account. Output
produced by the <A NAME="tex2html830"
 HREF="../bips/kernel/ioterm/write-1.html">write/1, 2</A><A NAME="5979"></A> predicate is not (necessarily) in
a form suitable for subsequent input to a Prolog program using the <A NAME="tex2html832"
 HREF="../bips/kernel/ioterm/read-1.html">read/1</A><A NAME="5982"></A>
predicate, for this purpose <A NAME="tex2html834"
 HREF="../bips/kernel/ioterm/writeq-1.html">writeq/1, 2</A><A NAME="5985"></A> is to be used.
<A NAME="5703"></A>
<A NAME="5704"></A>
The goal <PRE>
write(Stream, Term)
</PRE> writes <I>Term</I> to the
named output stream.
For more details about how to output terms in different formats, see
section <A HREF="node63.html#secoutputformats">10.4</A>.

<P>
When the flag <TT>variable_names</TT> is switched off,
<A NAME="5712"></A>
the output predicates are not able to write free variables
in their source form, i.e. with the correct variable names.
Then the variables are output in the form<PRE>
_N
</PRE>
where <TT>N</TT> is a number which identifies the variable (but note that these
numbers may change on garbage collection and can therefore not be used to
identify the variable in a more permanent way).
Occasionally the number will be prefixed with the lower-case letter <TT>l</TT>,
indicating that the variable is in a short-lived memory area called the
local stack (see <A HREF="node122.html#chapmemory">19</A>).
<A NAME="5720"></A>

<P>

<H2><A NAME="SECTION001024000000000000000">
General Parsing and Text Generation</A>
</H2>

<P>
Reading and writing of I/O formats that cannot be handled by the methods
discussed above are probably best done using Definite Clause Grammar
(DCG) rules. See chapter <A HREF="node70.html#dcg">12.3</A> for details.

<P>

<H2><A NAME="SECTION001025000000000000000">
Flushing</A>
</H2>
On most devices, output is buffered, i.e. any output does not appear
<A NAME="5724"></A>
immediately on the file, pipe or socket, but goes into a buffer first.
To make sure the data is actually written to the device, the stream
usually has to be flushed using
<A NAME="tex2html841"
 HREF="../bips/kernel/iostream/flush-1.html">flush/1</A><A NAME="5988"></A>.
If this is forgotten, the receiving end of a pipe or socket may hang
in a blocking read operation.

<P>
It is possible to configure a stream such that it is automatically
flushed at every line end (see 
<A NAME="tex2html843"
 HREF="../bips/kernel/iostream/set_stream_property-3.html">set_stream_property/3</A><A NAME="5991"></A>).

<P>

<H2><A NAME="SECTION001026000000000000000">
Prompting</A>
</H2>
Input streams on terminals can be configured to print a prompt
whenever input is required, see 
<A NAME="tex2html845"
 HREF="../bips/kernel/iostream/set_stream_property-3.html">set_stream_property/3</A><A NAME="5994"></A>.

<P>

<H2><A NAME="SECTION001027000000000000000">
Positioning</A>
</H2>
Streams that are opened on files or strings can be positioned,
ie. the read/write position can be moved forward or backwards.
This is not possible on pipes, sockets, queues and terminals.

<P>
To specify a position in the file
to write to or read from, the predicate <A NAME="tex2html847"
 HREF="../bips/kernel/iostream/seek-2.html">seek/2</A><A NAME="5997"></A> is provided. The
<A NAME="5735"></A>
call <PRE>
seek(Stream, Pointer)
</PRE> moves the current position in the
file (the 'file pointer') to the offset <I>Pointer</I> (a number specifying
the length in bytes) from
the start of the file.
If <I>Pointer</I> is the atom <I>end_of_file</I> the
current position is moved to the end of the file.
Hence a file could be open in <TT>append</TT> mode using<PRE>
open(File, update, Stream), seek(Stream, end_of_file)
</PRE>
The current position in a file may be found by the predicate <A NAME="tex2html850"
 HREF="../bips/kernel/iostream/at-2.html">at/2</A><A NAME="6000"></A>.
<A NAME="5750"></A>
The call <PRE>
at(Stream, Pointer)
</PRE> unifies <I>Pointer</I> with the current
position in the file.
The predicate<PRE>
at_eof(Stream)
</PRE>
succeeds if the current position in the given stream
is at the file end.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html3167"
 HREF="node62.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3163"
 HREF="node59.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3157"
 HREF="node60.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3165"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3168"
 HREF="node62.html">In-memory Streams</A>
<B> Up:</B> <A NAME="tex2html3164"
 HREF="node59.html">Input and Output</A>
<B> Previous:</B> <A NAME="tex2html3158"
 HREF="node60.html">Streams</A>
 &nbsp <B>  <A NAME="tex2html3166"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
