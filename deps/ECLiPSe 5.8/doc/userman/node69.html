<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Using the macros</TITLE>
<META NAME="description" CONTENT="Using the macros">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node70.html">
<LINK REL="previous" HREF="node68.html">
<LINK REL="up" HREF="node67.html">
<LINK REL="next" HREF="node70.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3279"
 HREF="node70.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3275"
 HREF="node67.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3269"
 HREF="node68.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3277"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3280"
 HREF="node70.html">Definite Clause Grammars </A>
<B> Up:</B> <A NAME="tex2html3276"
 HREF="node67.html">ECLiPSe Macros</A>
<B> Previous:</B> <A NAME="tex2html3270"
 HREF="node68.html">Introduction</A>
 &nbsp <B>  <A NAME="tex2html3278"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001220000000000000000"></A>
<A NAME="usingmacros"></A>
<BR>
Using the macros
</H1>

<P>
The following declarations and built-ins control macro expansion:
<DL>
<DT><STRONG>local macro(+TermClass, +TransPred, +Options)</STRONG>
<DD>define a macro for the given <I>TermClass</I>. The transformation will
be performed by the predicate <I>TransPred</I>.
<DT><STRONG>export macro(+TermClass, +TransPred, +Options)</STRONG>
<DD>as above, but available to other modules.
<DT><STRONG>erase_macro(+TermClass, +Options)</STRONG>
<DD>erase a currently defined macro for <I>TermClass</I>. This can only be done
in the module where the definition was made.
<DT><STRONG>current_macro(?TermClass, ?TransPred, ?Options, ?Module)</STRONG>
<DD>retrieve information about currently defined visible macros.
</DL>
Macros are selectively applied only to terms of the specified class.
<I>TermClass</I> can take two forms:
<DL>
<DT><STRONG>Name/Arity</STRONG>
<DD>transform all terms with the specified functor
<A NAME="6562"></A>
<A NAME="6563"></A>
<DT><STRONG>type(Type)</STRONG>
<DD>transform all terms of the specified type, where Type
is one of <TT>compound, string, integer, rational, float, breal, atom,
goal</TT><A NAME="tex2html936"
 HREF="footnode.html#foot6565"><SUP>12.1</SUP></A>.
</DL>
The +TransPred argument specifies the predicate that will perform the
transformation. It has to be of arity 2 or 3 and should have the form:<PRE>
trans_function(OldTerm, NewTerm [, Module]) :- ... .
</PRE>
At transformation time, the system will call <I>TransPred</I> in the module
where <A NAME="tex2html939"
 HREF="../bips/kernel/syntax/macro-3.html">macro/3</A><A NAME="6737"></A> was invoked.
The term to transform is passed as the first argument, the second is a free
variable which the transformation predicate should bind to the
transformed term, and the optional
third argument is the module where the term is read or written.

<P>
<I>Options</I> is a list which may be empty (in this case the macro defaults
to a local read term macro) or contain specifications from
the following categories:

<UL><LI>mode
<DL>
<DD><A NAME="6578"></A>
<DT><STRONG>read:</STRONG>
<DD>This is a read macro and shall be applied after reading a
term (default).

<P>
<A NAME="6579"></A>
<DT><STRONG>write:</STRONG>
<DD>This is a write macro and shall be applied before printing
a term. 
</DL>

<P>

<LI>type
<DL>
<DD><A NAME="6582"></A>
<DT><STRONG>term:</STRONG>
<DD>Transform all terms (default).

<P>
<A NAME="6583"></A>
<DT><STRONG>clause:</STRONG>
<DD>Transform only if the term is a program clause,
i.e. inside <A NAME="tex2html945"
 HREF="../bips/kernel/database/compile-1.html">compile/1</A><A NAME="6740"></A>, <A NAME="tex2html947"
 HREF="../bips/kernel/dynamic/assert-1.html">assert/1</A><A NAME="6743"></A> etc.
Write macros are applied using the 'C' option in the <A NAME="tex2html949"
 HREF="../bips/kernel/ioterm/printf-2.html">printf/2</A><A NAME="6746"></A> predicate.

<P>
<A NAME="6590"></A>
<DT><STRONG>goal:</STRONG>
<DD>Goal-read-macros are transformed only if the term is a
subgoal in the body of a program clause.
Goal-write macros are applied using the 'G' option in the
<A NAME="tex2html952"
 HREF="../bips/kernel/ioterm/printf-2.html">printf/2</A><A NAME="6749"></A> predicate.
</DL>

<P>

<LI>additional specification
<DL>
<DD><A NAME="6595"></A>
<DT><STRONG>protect_arg:</STRONG>
<DD>Disable transformation of subterms (optional).
<A NAME="6596"></A>
<DT><STRONG>top_only:</STRONG>
<DD>Consider only the whole term, not subterms (optional).
</DL>
</UL>
The following shorthands exist:
<DL>
<DT><STRONG>local/export portray(+TermClass, +TransPred, +Options)</STRONG>
<DD><A NAME="tex2html956"
 HREF="../bips/kernel/syntax/portray-3.html">portray/3</A><A NAME="6752"></A>

is like
    <A NAME="tex2html958"
 HREF="../bips/kernel/syntax/macro-3.html">macro/3</A><A NAME="6755"></A>,

but the write-option is implied.
<DT><STRONG>inline(+PredSpec, +TransPred)</STRONG>
<DD><A NAME="tex2html960"
 HREF="../bips/kernel/database/inline-2.html">inline/2</A><A NAME="6758"></A>

is the same as a goal-read-macro. The visibility is inherited
    from the transformed predicate.
</DL>

<P>
Here is an example of a conditional read macro:<PRE>
[eclipse 1]: [user].
 trans_a(a(X,Y), b(Y)) :- % transform a/2 into b/1,
number(X), % but only under these
X &gt; 0. % conditions

:- local macro(a/2, trans_a/2, []).
  user       compiled traceable 204 bytes in 0.00 seconds

yes.
[eclipse 2]: read(X).
        a(1, hello).

X = b(hello) % transformed
yes.
[eclipse 3]: read(X).
        a(-1, bye).

X = a(-1, bye) % not transformed
yes.
</PRE>
If the transformation function fails, the term is not transformed. Thus, 
<B>a(1, zzz)</B> is transformed into <B>b(zzz)</B> but <B>a(-1, zzz)</B> 
is not transformed.
The arguments are transformed bottom-up. It is possible to protect the 
subterms of a transformed term by specifying the flag <TT>protect_arg</TT>.

<P>
A term can be protected against transformation by quoting it with 
the ``protecting functor'' (by default it is <B>no_macro_expansion/1</B>):
<A NAME="6616"></A>
<A NAME="6617"></A><PRE>
[eclipse 4]: read(X).
        a(1, no_macro_expansion(a(1, zzz))).
X = b(a(1, zzz)).
</PRE>
Note that the protecting functor is itself defined as a macro:<PRE>
trprotect(no_macro_expansion(X), X).
:- export macro(no_macro_expansion/1, trprotect/2, [protect_arg]).
</PRE>

<P>
A local macro is only visible in the module where it has been defined.
When it is defined as exported, then it is copied to all
other modules that contain a
<A NAME="tex2html964"
 HREF="../bips/kernel/modules/use_module-1.html">use_module/1</A><A NAME="6761"></A> or
<A NAME="tex2html966"
 HREF="../bips/kernel/modules/import-1.html">import/1</A><A NAME="6764"></A>
for this module.
The transformation function should also be exported in this case.
There are a few global macros predefined by the system, e.g. for
<TT>--&gt;/2</TT> (grammar rules, see below) or <TT>with/2</TT> and <TT>of/2</TT>
(structure syntax, see section <A HREF="node21.html#chapstruct">5.1</A>).
These predefined macros can be hidden by local macro definitions.

<P>
<A NAME="6635"></A>
The global flag <B>macro_expansion</B> can be used to disable
macro expansion globally, e.g. for debugging purposes.
Use <TT>set_flag(macro_expansion, off)</TT> to do so.

<P>
The next example shows the use of a type macro. Suppose we want to represent
integers as s/1 terms:<PRE>
[eclipse 1]: [user].
 tr_int(0, 0).
 tr_int(N, s(S)) :- N &gt; 0, N1 is N-1, tr_int(N1, S).
 :- local macro(type(integer), tr_int/2, []).

yes.
[eclipse 2]: read(X).
        3.

X = s(s(s(0)))
yes.
</PRE>
When we want to convert the s/1 terms back to normal integers so that they
are printed in the familiar form, we can use a write macro.
Note that we first erase the read macro for integers, otherwise we would get
unexpected effects since all integers occurring in the definition of
tr_s/2 would turn into s/1 structures:<PRE>
[eclipse 3]: erase_macro(type(integer)).

yes.
[eclipse 4]: [user].
 tr_s(0, 0).
 tr_s(s(S), N) :- tr_s(S, N1), N is N1+1.
 :- local macro(s/1, tr_s/2, [write]).

yes.
[eclipse 2]: write(s(s(s(0)))).
3
yes.
</PRE>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html3279"
 HREF="node70.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3275"
 HREF="node67.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3269"
 HREF="node68.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3277"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3280"
 HREF="node70.html">Definite Clause Grammars </A>
<B> Up:</B> <A NAME="tex2html3276"
 HREF="node67.html">ECLiPSe Macros</A>
<B> Previous:</B> <A NAME="tex2html3270"
 HREF="node68.html">Introduction</A>
 &nbsp <B>  <A NAME="tex2html3278"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
