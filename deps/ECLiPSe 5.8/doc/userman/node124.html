<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Garbage collection</TITLE>
<META NAME="description" CONTENT="Garbage collection">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="previous" HREF="node123.html">
<LINK REL="up" HREF="node122.html">
<LINK REL="next" HREF="node125.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html4097"
 HREF="node125.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html4093"
 HREF="node122.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html4089"
 HREF="node123.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html4095"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html4098"
 HREF="node125.html">Operating System Interface</A>
<B> Up:</B> <A NAME="tex2html4094"
 HREF="node122.html">Memory Organisation And Garbage</A>
<B> Previous:</B> <A NAME="tex2html4090"
 HREF="node123.html">Introduction</A>
 &nbsp <B>  <A NAME="tex2html4096"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001920000000000000000"></A>
<A NAME="11932"></A>
<A NAME="gc"></A>
<BR>
Garbage collection
</H1>

<P>
The four stacks grow an shrink as needed<A NAME="tex2html1610"
 HREF="footnode.html#foot11934"><SUP>19.1</SUP></A>.
In addition, ECLiPSe provides an incremental garbage collector
for the global and the trail stack.
It is also equipped with a dictionary garbage
collector that frees memory that is occupied by obsolete atoms and functors.
Both collectors are switched on by default and are automatically invoked
from time to time.
Nevertheless, there are some predicates to control their action.
The following predicates affect both collectors:
<DL>
<DT><STRONG>set_flag(gc, on).</STRONG>
<DD><A NAME="11937"></A>
	Enable the garbage collector (the default).
<DT><STRONG>set_flag(gc, verbose).</STRONG>
<DD>The same as 'on', but print a message on every collection
	(the message goes to toplevel_output):
<PRE>
GC ... global: 96208 - 88504 (92.0 %), trail: 500 - 476 (95.2 %), time: 0.017
</PRE>
	It displays the area to be searched for garbage, the amount
	and percentage of garbage, and the time for the collection.
	The message of the dictionary collector is as follows:
<PRE>
DICTIONARY GC ... 2814 - 653, (23.2 %), time: 0.033
</PRE>
	It displays the number of dictionary entries before the collection,
	the number of collected entries, the percentage of reduction and
	the collection time.
<DT><STRONG>set_flag(gc, off).</STRONG>
<DD>Disable the garbage collector (and risk an overflow), eg. for
	time-critical execution sequences.
</DL>
Predicates related to the stack collector are:
<DL>
<DT><STRONG>set_flag(gc_policy, adaptive).</STRONG>
<DD>This option affects the triggering heuristics of the garbage
	collector, together with the gc_interval setting.
	The adaptive policy (the default) minimises garbage collection time.
<DT><STRONG>set_flag(gc_policy, fixed).</STRONG>
<DD>This option affects the triggering heuristics of the garbage
	collector, together with the gc_interval setting.
	The fixed policy minimises space consumption. 
<DT><STRONG>set_flag(gc_interval, Nbytes).</STRONG>
<DD>Specify how often the collector is invoked. Roughly, Nbytes
	is the number of bytes that your program can use up before
	a garbage collection is triggered.
	There may be programs that create lots of (useful) lists and
	structures while leaving few garbage. This will cause the garbage
	collector to run frequently while reclaiming little space.
	If you suspect this, you should call statistics/0 and check
	the garbage ratio. If it is very low (say below 50%) it may
	make sense to increase the <TT>gc_interval</TT>, thus reducing
	the number of garbage collections.  This is normally only
	necessary when the gc_policy is set to fixed.  With gc_policy
	set to adaptive, the collection intervals will be adjusted
	automatically.
<DT><STRONG>garbage_collect.</STRONG>
<DD><A NAME="11945"></A>
	Request an immediate collection (only if enabled). The use of this
	predicate should be restricted to situations where the automatic
	triggering performs badly. It should then be inserted in a place
	where you know for sure that you have just created a lot of garbage,
	eg. before the tail-recursive call in something like
<PRE>
        cycle(OldState) :-
                transform(OldState, NewState),  /* long computation     */
                !,
                garbage_collect,                /* OldState is obsolete */
                cycle(NewState).
</PRE>
<DT><STRONG>statistics(gc_number, N).</STRONG>
<DD><A NAME="11948"></A>
	The number of stack garbage collections performed during this ECLiPSe session.
<DT><STRONG>statistics(gc_collected, Bytes).</STRONG>
<DD>The amount of global stack space reclaimed by all the
	garbage collections in bytes.
<DT><STRONG>statistics(gc_area, Bytes).</STRONG>
<DD>The average global stack area that was scanned by each garbage
	collection. This number should be close to the selected
	<TT>gc_interval</TT>, if it is much larger, <TT>gc_interval</TT>
	should be increased.
<DT><STRONG>statistics(gc_ratio, Percentage).</STRONG>
<DD>The average percentage of garbage found and reclaimed by each
	garbage collection.
	If this ratio is low, <TT>gc_interval</TT> should be increased.
<DT><STRONG>statistics(gc_time, Seconds).</STRONG>
<DD>The total cputime spent during all garbage collections.
</DL>

<P>
Predicates related to the dictionary collector are:
<DL>
<DT><STRONG>set_flag(gc_interval_dict, N).</STRONG>
<DD>Specify that the dictionary collector should be invoked after
	N new dictionary entries have been made.
<DT><STRONG>statistics(dict_gc_number, N).</STRONG>
<DD>The number of dictionary garbage collections performed during this ECLiPSe session.
<DT><STRONG>statistics(dict_gc_time, Seconds).</STRONG>
<DD>The total cputime spent by all dictionary garbage collections.
</DL>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html4097"
 HREF="node125.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html4093"
 HREF="node122.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html4089"
 HREF="node123.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html4095"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html4098"
 HREF="node125.html">Operating System Interface</A>
<B> Up:</B> <A NAME="tex2html4094"
 HREF="node122.html">Memory Organisation And Garbage</A>
<B> Previous:</B> <A NAME="tex2html4090"
 HREF="node123.html">Introduction</A>
 &nbsp <B>  <A NAME="tex2html4096"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
