<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Formal definition of clause syntax</TITLE>
<META NAME="description" CONTENT="Formal definition of clause syntax">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node144.html">
<LINK REL="previous" HREF="node142.html">
<LINK REL="up" HREF="node140.html">
<LINK REL="next" HREF="node144.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html4383"
 HREF="node144.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html4379"
 HREF="node140.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html4373"
 HREF="node142.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html4381"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html4384"
 HREF="node144.html">Syntax Differences between ECLiPSe</A>
<B> Up:</B> <A NAME="tex2html4380"
 HREF="node140.html">Syntax</A>
<B> Previous:</B> <A NAME="tex2html4374"
 HREF="node142.html">Notation</A>
 &nbsp <B>  <A NAME="tex2html4382"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html4385"
 HREF="node143.html#SECTION002331000000000000000">Comments</A>
<LI><A NAME="tex2html4386"
 HREF="node143.html#SECTION002332000000000000000">Operators</A>
<LI><A NAME="tex2html4387"
 HREF="node143.html#SECTION002333000000000000000">Operator Ambiguities</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION002330000000000000000">
Formal definition of clause syntax</A>
</H1>
What follows is the specification of the syntax. The terminal symbols are 
written in UPPER CASE or as the character sequence they consist of.
<A NAME="12989"></A>
<A NAME="12990"></A>
<A NAME="12991"></A>
<PRE>
program                 ::=     clause EOCL
                         |      clause EOCL program

clause                  ::=     head
                         |      head rulech goals
                         |      rulech goals

head                    ::=     term_h

goals                   ::=     term_g
                         |      goals , goals
                         |      goals ; goals
                         |      goals -&gt; goals
                         |      goals -&gt; goals ; body

term_h                  ::=     term_h(0)
                         |      term(1200)

term_g                  ::=     term_g(0)
                         |      term(1200)

term(0)                 ::=      VAR            /* not a term_h */
                         |       attr_var       /* not a term_h */
                         |       ATOM
                         |       structure
                         |       structure_with_fields
                         |       subscript
                         |       list
                         |       STRING         /* not a term_h nor a term_g */
                         |       number         /* not a term_h nor a term_g */
                         |       bterm

term(N)                 ::=     term(0)
                         |      prefix_expression(N)
                         |      infix_expression(N)
                         |      postfix_expression(N)

prefix_expression(N)    ::=     fx(N)   term(N-1)
                         |      fy(N)   term(N)
                         |      fxx(N)  term(N-1)  term(N-1)
                         |      fxy(N)  term(N-1)  term(N)

infix_expression(N)     ::=     term(N-1)  xfx(N)  term(N-1)
                         |      term(N)    yfx(N)  term(N-1)
                         |      term(N-1)  xfy(N)  term(N)

postfix_expression(N)   ::=     term(N-1)  xf(N)
                         |      term(N)    yf(N)

attr_var                ::=     VAR { attributes }
                                /* Note: no space before { */

attributes              ::=     attribute
                         |      attribute , attributes

attribute               ::=     qualified_attribute
                         |      nonqualified_attribute

qualified_attribute     ::=     ATOM : nonqualified_attribute

nonqualified_attribute  ::=     term_a

structure               ::=     functor ( termlist )
                                /* Note: no space before ( */

structure_with_fields   ::=     functor { termlist }
                                /* Note: no space before { */

subscript               ::=     structure list
                         |      VAR list
                                /* Note: no space before list */

termlist                ::=      term_a
                         |       term_a , termlist

list                    ::=     [ listexpr ]
                         |      .(term_a, term_a)

listexpr                ::=     term_a
                         |      term_a | term_a
                         |      term_a , listexpr

term_a                  ::=     term(1200)
                                /* Note: it depends on syntax_options */

number                  ::=     INT
                         |      INTBAS
                         |      INTCHAR
                         |      RAT
                         |      FLOAT
                         |      BREAL

bterm                   ::=     ( clause )
                         |      { clause }

functor                 ::=     ATOM                    /* arity &gt; 0 */

rulech                  ::=     :-
                         |      ?-
</PRE>

<P>

<H2><A NAME="SECTION002331000000000000000">
Comments</A>
</H2>

<P>
Comments can be full line comments, that is enclosed by CM1-CM2 and CM2-CM1, or end of line comments, that is enclosed by CM and NL. They behave as separators.

<P>

<H2><A NAME="SECTION002332000000000000000"></A>
<A NAME="12996"></A>
<BR>
Operators
</H2>
In Prolog, the user is able to modify the syntax dynamically by explicitly 
declaring new operators. The builtin <A NAME="tex2html1775"
 HREF="../bips/kernel/syntax/op-3.html">op/3</A><A NAME="13064"></A> performs this 
task. As in Edinburgh Prolog, a lower precedence value means that the
operator binds stronger (1 strongest, 1200 weakest).

<P>
Any atom (whether symbolic, alphanumeric, or quoted) can be declared as an
operator.  Once an operator has been declared, the parser will accept
the corresponding operator notation, and certain output builtins will
produce the operator notation if possible.  There are three classes of
operators: prefix, infix and postfix.
<A NAME="12999"></A>
<A NAME="13000"></A>
<A NAME="13001"></A>

<UL><LI>When <code>f</code> is declared prefix unary (fx or fy),
then the term <code>f(X)</code> can alternatively be written as <code>f X</code>.

<LI>When <code>f</code> is declared prefix binary (fxx or fxy),
then the term <code>f(X,Y)</code> can alternatively be written as <code>f X Y</code>.

<LI>When <code>f</code> is declared postfix (xf or yf),
then the term <code>f(X)</code> can alternatively be written as <code>X f</code>.

<LI>When <code>f</code> is declared infix (xfx, xfy or yfx),
then the term <code>f(X,Y)</code> can alternatively be written as <code>X f Y</code>.

</UL>
An operator can belong to more than one class, e.g. the plus sign
is both a prefix and an infix operator at the same time.

<P>
In the associativity specification of an operator (e.g. fx, yfx), x
represents an argument whose precedence must be lower than that of the
operator.  y represents an argument whose precedence must be lower or
equal to that of the operator.  y should be used if one wants to allow
chaining of operators.  The position of the y will determine the
grouping within a chain of operators. For example:<PRE>
Example declaration        will allow          to stand for
---------------------------------------------------------------
:- op(500,xfx,in).         A in B              in(A,B)
:- op(500,xfy,in).         A in B in C         in(A,in(B,C))
:- op(500,yfx,in).         A in B in C         in(in(A,B),C)
:- op(500,fx ,pre).        pre A               pre(A)
:- op(500,fy ,pre).        pre pre A           pre(pre(A))
:- op(500, xf,post).       A post              post(A)
:- op(500, yf,post).       A post post         post(post(A))
:- op(500,fxx,bin).        bin A B             bin(A,B)
:- op(500,fxy,bin).        bin A bin B C       bin(A,bin(B,C))
</PRE>

<P>
Operator declarations are usually local to a module, but they can be
exported and imported.  The operator visible in a module is either the
local one (if any), an imported one, or a predefined one.
Some operators are pre-defined (see Appendix <A HREF="node146.html#chapopers">B</A> on
page <A HREF="node146.html#chapopers"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="cross_ref_motif.gif"></A>).  They may be locally redefined if desired.

<P>
Note that parentheses are used to build expressions with precedence zero
and thus to override operator declarations<A NAME="tex2html1774"
 HREF="footnode.html#foot13010"><SUP>A1</SUP></A>.

<P>

<H2><A NAME="SECTION002333000000000000000"></A>
<A NAME="13012"></A>
<BR>
Operator Ambiguities
</H2>
Unlike the canonical syntax, operator syntax can lead to ambiguities.

<UL><LI><A NAME="13014"></A>
For instance, when a prefix operator is followed by an infix or postfix
operator, the prefix is often not meant to be a prefix operator, but
simply the left hand side argument of the following infix or postfix.
In order to decide whether that is the case, ECLiPSe uses the operator's
relative precedences and their associativities, and, if necessary,
a two-token lookahead. If this rules out the prefix-interpretation, then
the prefix is treated as a simple atom. In the rare case where this
limited lookahead is not enough to disambigute, the prefix must be
explicitly enclosed in parentheses.

<P>

<LI><A NAME="13016"></A>
Another source of ambiguity are operators which have been declared
both infix and postfix. In this case, ECLiPSe uses a one-token
lookahead to check whether the infix-interpretation can be ruled out.
If yes, the operator is interpreted as postfix, otherwise as infix.
Again, in rare cases parentheses may be necessary to enforce the
interpretation as postfix.

<P>

<LI><A NAME="13018"></A>
When a binary prefix operator is followed by an infix operator, then
either of them could be the main functor. Faced with the ambiguity, the
system will prefer the infix interpretation. To force the binary prefix
to be recognised, the infix must be enclosed in parentheses.

</UL>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html4383"
 HREF="node144.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html4379"
 HREF="node140.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html4373"
 HREF="node142.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html4381"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html4384"
 HREF="node144.html">Syntax Differences between ECLiPSe</A>
<B> Up:</B> <A NAME="tex2html4380"
 HREF="node140.html">Syntax</A>
<B> Previous:</B> <A NAME="tex2html4374"
 HREF="node142.html">Notation</A>
 &nbsp <B>  <A NAME="tex2html4382"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
