<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Details of the Execution Mechanism</TITLE>
<META NAME="description" CONTENT="Details of the Execution Mechanism">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node117.html">
<LINK REL="previous" HREF="node115.html">
<LINK REL="up" HREF="node105.html">
<LINK REL="next" HREF="node117.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3990"
 HREF="node117.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3986"
 HREF="node105.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3980"
 HREF="node115.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3988"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3991"
 HREF="node117.html">Simulating other System's Delay-Primitives</A>
<B> Up:</B> <A NAME="tex2html3987"
 HREF="node105.html">Advanced Control Features</A>
<B> Previous:</B> <A NAME="tex2html3981"
 HREF="node115.html">More about Priorities</A>
 &nbsp <B>  <A NAME="tex2html3989"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html3992"
 HREF="node116.html#SECTION0017111000000000000000">Particularities of Waking by Unification</A>
<LI><A NAME="tex2html3993"
 HREF="node116.html#SECTION0017112000000000000000">Cuts and Suspended Goals</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION0017110000000000000000">
Details of the Execution Mechanism</A>
</H1>

<P>

<H2><A NAME="SECTION0017111000000000000000"></A>
<A NAME="10713"></A>
<BR>
Particularities of Waking by Unification
</H2>
Goals that are suspended on the <B>inst</B> or <B>bound</B> waking
conditions are woken by unifications of their
<I>suspending variables</I>.
<A NAME="10717"></A>
One suspending variable can be responsible for delaying several goals,
on the other hand one goal can be suspended on several
suspending variables (as alternative waking conditions).
This means that when one suspending variable is bound,
several delayed goals may be woken at once.
The order of executing woken suspended goals does not necessarily correspond
to the order of their suspending. It is in fact determined by their
priorities and is implementation-dependent within the same priority group.

<P>
The waking process never interrupts unifications and/or a sequence
of simple goals.
<A NAME="10718"></A>
Simple goals are a subset of the built-ins and
can be recognised by their <B>call_type</B>
flag as returned by
<A NAME="tex2html1526"
 HREF="../bips/kernel/database/get_flag-3.html">get_flag/3</A><A NAME="10983"></A>,
simple goals having the type <TT>external</TT>.
Note also that some predicates, e.g. <A NAME="tex2html1528"
 HREF="../bips/kernel/arithmetic/is-2.html">is/2</A><A NAME="10986"></A>,
are normally in-line expanded and thus simple, but can be regular when
inlining is suppressed, e.g. by the <B>pragma(noexpand)</B> directive.

<P>
ECLiPSe treats simple predicates (including unification) always as a block.
Delayed goals are therefore woken only at the end of a successful
unification and/or a sequence of simple goals.
If a suspending variable is bound in a simple goal, the suspended
goals are woken only at the end of the last consecutive simple
goal or at the clause end.
If the clause contains simple goals at the beginning of its
body, they are considered part of the head (<I>extended head</I>)
<A NAME="10728"></A>
and if a suspending variable is bound in the head unification or
in a simple predicate in the extended head, the corresponding
delayed goals are woken at the end of the extended head.

<P>
A
<A NAME="tex2html1531"
 HREF="../bips/kernel/control/I-0.html">cut</A><A NAME="10989"></A>
is also considered a simple goal and is therefore
always executed <B>before</B> waking any pending suspended goals.
This is important to know especially in the situations where the cut
acts like a guard, immediately after the clause neck or after
a sequence of simple goals.
If the goals woken by the head unification or by the extended head
are considered as constraints on the suspending variables,
the procedure will not behave as expected.
For example<PRE>
filter(_P,[],[]) :- !.
filter(P,[N|LI],[N|NLI]) :-
        N mod P =\= 0,
        !,
        filter(P,LI,NLI).
filter(P,[N|LI],NLI) :-
        filter(P,LI,NLI).

delay integers(_, List) if var(List).
integers(_, []).
integers(N, [N|Rest]) :-
        N1 is N + 1,
        integers(N1, Rest).
 
?- integers(2, Ints), filter(2, Ints, [X1,X2]).
</PRE>
The idea here is that integers/2 fills a list with integers on demand,
i.e. whenever new list elements appear.
Filter/3 is a predicate that removes all integers that are a multiple
of P. In the example query, the call to <B>integers/2</B> initially delays.
When <B>filter/3</B> is called, Ints gets instantiated in the head unification
of the second clause of filter/3, which will wake up integers/2. However,
since the second clause of filter/3 has an extended head which extends up to
the cut, integers/2 will not actually be executed until after the cut.
Therefore, N is not yet instantiated at the time of the arithmetic test
and causes an error message.

The reason why delayed goals are woken <B>after</B> the cut and not before
it is that neither of the two possibilities is always the intended
or the correct one, however when goals are woken <B>before</B> the cut,
there is no way to escape it and wake them after, and so if
a nondeterministic goal is woken, it is committed by this cut
which was most probably not intended.
On the other hand, it is always possible to force waking before the cut
by inserting a regular goal before it, for example <A NAME="tex2html1533"
 HREF="../bips/kernel/control/true-0.html">true/0</A><A NAME="10992"></A>,
so the sequence
<DIV ALIGN="CENTER">
<B>true, !</B>

</DIV>
can be viewed as a special cut type.
 
As a consequence, the example can be fixed by inserting <TT>true</TT> at the
beginning of the second clause.
However, a preferable and more robust way is using the if-then-else
construct, which always forces waking suspended goals before
executing the condition.
This would also be more efficient by avoiding the creation of a choice point:<PRE>
filter(_P,[],[]).
filter(P,[N|LI],LL) :-
        (N mod P =\= 0 -&gt;
                LL = [N|NLI],
                filter(P, LI, NLI)
        ;
                filter(P,LI,LL)
        ).
</PRE>

<P>

<H2><A NAME="SECTION0017112000000000000000"></A>
<A NAME="delaycut"></A>
<BR>
Cuts and Suspended Goals
</H2>
The
<A NAME="tex2html1535"
 HREF="../bips/kernel/control/I-0.html">cut</A><A NAME="10995"></A>
relies on a fixed order of goal execution in that it discards
some choice points if all goals preceding it in the clause body have
succeeded.
If some of these goals delay without being woken before the cut,
or if the head unification of the
clause with the cut wakes any nondeterministic delayed goal,
the completeness of the resulting program is lost
and there is no clean way to save it as long as the cut is used.

<P>
<A NAME="10756"></A>
The user is strongly discouraged to use non-local cuts together with
coroutining, or to be precisely aware of their scope.
The danger of a cut is twofold:

<UL><LI>Delaying <B>out of</B> the scope of a cut:
a cut can be executed after some calls preceding it in the clause
(or children of these calls) delay. When they are then woken later,
they may cause the whole execution to fail instead of just the
guard before the cut.

<P>

<LI>Delaying <B>into</B> the scope of a cut:
the head unification of a clause with cuts can wake delayed goals.
If they are nondeterministic, the cut in the body of the waking clause
will commit even the woken goals

</UL>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html3990"
 HREF="node117.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3986"
 HREF="node105.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3980"
 HREF="node115.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3988"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3991"
 HREF="node117.html">Simulating other System's Delay-Primitives</A>
<B> Up:</B> <A NAME="tex2html3987"
 HREF="node105.html">Advanced Control Features</A>
<B> Previous:</B> <A NAME="tex2html3981"
 HREF="node115.html">More about Priorities</A>
 &nbsp <B>  <A NAME="tex2html3989"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
