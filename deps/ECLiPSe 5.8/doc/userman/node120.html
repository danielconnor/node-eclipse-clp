<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Waiting for Binding</TITLE>
<META NAME="description" CONTENT="Waiting for Binding">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node121.html">
<LINK REL="previous" HREF="node119.html">
<LINK REL="up" HREF="node118.html">
<LINK REL="next" HREF="node121.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html4041"
 HREF="node121.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html4037"
 HREF="node118.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html4031"
 HREF="node119.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html4039"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html4042"
 HREF="node121.html">Waiting for other Constraints</A>
<B> Up:</B> <A NAME="tex2html4038"
 HREF="node118.html">More About Suspension</A>
<B> Previous:</B> <A NAME="tex2html4032"
 HREF="node119.html">Waiting for Instantiation</A>
 &nbsp <B>  <A NAME="tex2html4040"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001820000000000000000">
Waiting for Binding</A>
</H1>
Sometimes we want a goal to be woken when a variable is bound
to another one, e.g. to check for
subsumption or disequality.
As an example, let us construct the code for the built-in predicate

<P>
<B>=/2</B>
.
This predicate imposes the disequality constraint on its two arguments.
It works as follows:
<DL COMPACT>
<DT>1.
<DD>It scans the two terms.
If they are identical, it fails.
<P>
<DT>2.
<DD>If it finds a pair of different arguments at least one of which is a
variable, it suspends. If both arguments are variables,
the suspension is placed on the <B>bound</B> suspended list
of both variables.
If only one is a variable, the suspension is placed on its <B>inst</B>
list, because in this case the constraint may be falsified
only if the variable is instantiated.

<P>
<DT>3.
<DD>Otherwise, if it finds a pair of arguments that cannot be unified,
it succeeds.

<P>
<DT>4.
<DD>Otherwise it means that the two terms are equal and it fails.
</DL>

<P>
The code looks as follows. <B>equal_args/3</B> scans the two
arguments.
If it finds a pair of unifyable terms, it returns them in
its third argument.
Otherwise, it calls <B>equal_terms/3</B> which decomposes
the two terms and scans recursively all their arguments.

<P><PRE>
dif(T1, T2) :-
    (equal_args(T1, T2, Vars) -&gt;
        (nonvar(Vars) -&gt;
            (Vars = inst(V) -&gt;
                suspend(dif(T1, T2), 3, V-&gt;inst)
            ;
                suspend(dif(T1, T2), 3, Vars-&gt;bound)
            )
        ;
            fail % nothing to suspend on, they are identical
)
    ;    
        true % the terms are different
).

equal_args(A1, A2, Vars) :-
    (A1 == A2 -&gt;
        true
    ;
    var(A1) -&gt;
        (var(A2) -&gt;
            Vars = bound(A1, A2)
        ;
            Vars = inst(A1)
        )
    ;
    var(A2) -&gt;
        Vars = inst(A2)
    ;
        equal_terms(A1, A2, Vars)
    ).

equal_terms(R1, R2, Vars) :-
    R1 =.. [F|Args1],
    R2 =.. [F|Args2],
    equal_lists(Args1, Args2, Vars).

equal_lists([], [], _).
equal_lists([X1|A1], [X2|A2], Vars) :-
    equal_args(X1, X2, Vars),
    (nonvar(Vars) -&gt;
        true % we have already found a variable
;
        equal_lists(A1, A2, Vars)
    ).
</PRE>

<P>
Note that <B>equal_args/3</B> can yield three possible outcomes:
success, failure and delay.
Therefore, if it succeeds,
we have to make the distinction between a genuine success
and delay, which is done using its third argument.
The predicate <A NAME="tex2html1549"
 HREF="../bips/lib/sicstus/index.html">dif/2</A><A NAME="11638"></A> behaves exactly as the built-in predicate

<P>
<B>=/2</B>:

<P><PRE>
[eclipse 26]: dif(X, Y).

X = X
Y = Y

Delayed goals:
        dif(X, Y)
yes.
[eclipse 27]: dif(X, Y), X=Y.

no (more) solution.
[eclipse 28]: dif(X, Y), X=f(A, B), Y=f(a, C), B=C, A=a.

no (more) solution.
[eclipse 29]: dif(X, Y), X=a, Y=b.

X = a
Y = b
yes.
</PRE>

<P>
Note also that the scan stops at the first variable being compared
to a different term.
In this way, we scan only the part of the terms which is absolutely
necessary to detect failure - the two terms can become
equal only if this variable is bound to a matching term.

<P>
This approach has one disadvantage, though.
We always wake the <A NAME="tex2html1551"
 HREF="../bips/lib/sicstus/index.html">dif/2</A><A NAME="11641"></A> call with the original terms
as arguments.
Each time the suspension is woken, we scan the two terms
from the beginning and thus repeat the same operations.
If, for instance, the compared terms are lists with thousands of elements
and the first 10000 elements are ground, we spend most of our time
checking them again and again.

<P>
The reason for this handling is that the system cannot suspend
the execution of <A NAME="tex2html1553"
 HREF="../bips/lib/sicstus/index.html">dif/2</A><A NAME="11644"></A> while executing its subgoals:
it cannot freeze the state of all the active subgoals and their
arguments.
There is however a possibility for us to do this explicitly:
as soon as we find a variable, we stop scanning the terms
and return a list of continuations for all ancestor compound arguments.
In this way, <B>equal_args</B> returns a list of pairs
and their continuations which will then be processed step by step:

<UL><LI><B>equal_args/4</B> scans again the input arguments.
If it finds a pair of unifyable terms, it inserts it into
a difference list.

<P>

<LI><B>equal_lists/4</B> processes the arguments of compound terms.
As soon as a variable is found, it stops looking at following
arguments but it appends them into the difference list.

<P>

<LI><B>diff_pairs/2</B> processes this list.
If it finds an identical pair, it succeeds, the two terms
are different.
Otherwise, it suspends itself on the variables in the matched
pair (here the suspending is simplified to use only the <B>bound</B>
list).

<P>

<LI>The continuations are just other pairs in the list,
so that no special treatment is necessary.

<P>

<LI>When the variables suspended upon are instantiated
to compound terms, the new terms are again scanned by <B>equal_arg/4</B>,
but the new continuations are prepended to the list.
As a matter of fact, it does not matter if we put the new
pairs at the beginning or at the end of the list,
but tracing is more natural when we use the fifo format.

<P>

<LI>If this list of pairs is exhausted, it means that
no potentially non-matching pairs were found, the two
terms are identical and thus the predicate fails.
note that this is achieved by a matching clause
for <B>diff_pairs/2</B> which fails if its first
argument is a free variable.

<P>

<LI>Note the optimisation for lists in <B>equal_terms/4</B>:
If one term is a list, we pass it directly to <B>equal_lists/4</B>
instead of decomposing each element with <A NAME="tex2html1555"
 HREF="../bips/kernel/termmanip/functor-3.html">functor/3</A><A NAME="11647"></A>.
Obviously, this optimisation is applicable only if the input
terms are known not to contain any pairs which are not proper lists.

</UL><PRE>
dif2(T1, T2) :-
    equal_args(T1, T2, List, Link),
    !,
    diff_pairs(List, Link).
d2if(_, _). % succeed if already different

equal_args(A1, A2, L, L) :-
    A1 == A2,
    !.
equal_args(A1, A2, [A1-A2|Link], Link) :-
    (var(A1);var(A2)),
    !.
equal_args(A1, A2, List, Link) :-
    equal_terms(A1, A2, List, Link).

equal_terms(T1, T2, List, Link) :-
    T1 = [_|_],
    T2 = [_|_],
    !,
    equal_lists(T1, T2, List, Link).
equal_terms(T1, T2, List, Link) :-
    T1 =.. [F|Args1],
    T2 =.. [F|Args2],
    equal_lists(Args1, Args2, List, Link).

equal_lists([], [], L, L).
equal_lists([X1|A1], [X2|A2], List, Link) :-
    equal_args(X1, X2, List, L1),
    (nonvar(List) -&gt;
        L1 = [A1-A2|Link]
    ;
        equal_lists(A1, A2, L1, Link)
    ).

diff_pairs([A1-A2|List], Link) :-
    -?-&gt;
    (A1 == A2 -&gt;
        diff_pairs(List, Link)
    ;
    (var(A1); var(A2)) -&gt;
        suspend(diff_pairs([A1-A2|List], Link), 3, A1-A2-&gt;bound)
    ;
    equal_terms(A1, A2, NewList, NewLink) -&gt;
        NewLink = List, % prepend to the list
diff_pairs(NewList, Link)
    ;
        true
    ).
</PRE>

<P>
Now we can see that compound terms are processed up to the first
potentially matching pair and then the continuations
are stored:

<P><PRE>
[eclipse 30]: dif2(f(g(X, Y), h(Z, 1)), f(g(A, B), h(2, C))).

X = X
...
Delayed goals:
        diff_pairs([X - A, [Y] - [B], [h(Z, 1)] - [h(2, C)]|Link], Link)
yes.
</PRE>

<P>
When a variable in the first pair is bound, the search proceeds
to the next pair:<PRE>
[eclipse 31]: dif2(f(g(X, Y), h(Z, 1)), f(g(A, B), h(2, C))), X=A.

Y = Y
...
Delayed goals:
        diff_pairs([Y - B, [] - [], [h(Z, 1)] - [h(2, C)]|Link], Link)
yes.
</PRE>

<P>
<B>dif2/2</B> does not do any unnecessary processing, so it is
asymptotically much better than the built-in

<P>
<B>=/2</B>.

<P>
This predicate, however, can be used only to <I>impose</I> a constraint
on the two terms (i.e. it is a <I>tell</I> constraint only).
It uses the approach of <I>eager failure</I> and <I>lazy success</I>.
Since it does not process the terms completely, it sometimes
does not detect success:<PRE>
[eclipse 55]: dif2(f(X, a), f(b, b)).

X = X

Delayed goals:
        diff_pairs([X - b, [a] - [b]|Link], Link)
yes.
</PRE>
If we wanted to write a predicate that suspends if and only if
the disequality cannot be decided, we have to use a different
approach.
The easiest way would be to process both terms completely each
time the predicate is woken.
There are, however, better methods.
We can process the terms once when the predicate <A NAME="tex2html1557"
 HREF="../bips/lib/sicstus/index.html">dif/2</A><A NAME="11650"></A>
is called, filter out all possibly matching pairs
and then create a suspension for each of them.
As soon as one of the suspensions is woken and it finds
an incompatible binding, the <A NAME="tex2html1559"
 HREF="../bips/lib/sicstus/index.html">dif/2</A><A NAME="11653"></A> predicate
can succeed.
There are two problems:

<UL><LI>How to report the success? There are N suspensions
and each of them may be able to report success due to its bindings.
All others should be disposed of.

<P>
This can be solved by introducing a new variable
which will be instantiated when the two terms become
non-unifyable. Any predicate can then use this variable
to ask or wait for the result.
At the same time, when it is instantiated, all
suspensions are woken and finished.

<P>

<LI>How to find out that the predicate has failed?
We split the whole predicate into N independent suspensions
and only if all of them are eventually woken and they find identical
pairs, the predicate fails. Any single suspension does not
know if it is the last one or not.

<P>
To cope with this problem, we can use the <I>short
circuit</I> technique:
Each suspension will include two additional variables, the first
one being shared with the previous suspension and the second
one with the next suspension.
All suspensions are thus chained with these variables.
The first variable of the first suspension is instantiated
at the beginning.
When a suspension is woken and it finds out that its pair
of matched terms became identical, it binds those additional
variables to each other.
When all suspensions are woken and their pairs become
identical, the second variable of the last suspension
becomes instantiated and this can be used
for notification that the predicate has failed.

<P>

</UL>

<P><PRE>
dif3(T1, T2, Yes, No) :-
    compare_args(T1, T2, no, No, Yes).

compare_args(_, _, _, _, Yes) :-
    nonvar(Yes).
compare_args(A1, A2, Link, NewLink, Yes) :-
    var(Yes),
    (A1 == A2 -&gt;
        Link = NewLink % short-cut the links
;
    (var(A1);var(A2)) -&gt;
        suspend(compare_args(A1, A2, Link, NewLink, Yes), 3, 
	    [[A1|A2]-&gt;bound, Yes-&gt;inst])
    ;
        compare_terms(A1, A2, Link, NewLink, Yes)
    ).

compare_terms(T1, T2, Link, NewLink, Yes) :-
    T1 =.. [F1|Args1],
    T2 =.. [F2|Args2],
    (F1 = F2 -&gt;
        compare_lists(Args1, Args2, Link, NewLink, Yes)
    ;
        Yes = yes
    ).

compare_lists([], [], L, L, _).
compare_lists([X1|A1], [X2|A2], Link, NewLink, Yes) :-
    compare_args(X1, X2, Link, L1, Yes),
    compare_lists(A1, A2, L1, NewLink, Yes).
</PRE>

<P>
The variable <B>Yes</B> is instantiated as soon as the constraint
becomes true.
This will also wake all pending suspensions which then simply succeed.
The argument <B>No</B> of <B>dif3/4</B> becomes instantiated to <TT>no</TT>
as soon as all suspensions are woken and their matched pairs
become identical:

<P><PRE>
[eclipse 12]: dif3(f(A, B), f(X, Y), Y, N).

Y = Y
...

Delayed goals:
        compare_args(A, X, no, L1, Y)
        compare_args(B, Y, L1, N, Y)
yes.
[eclipse 13]: dif3(f(A, B), f(X, Z), Y, N), A = a, X = b.

Y = yes
N = N
...
yes.
[eclipse 14]: dif3(f(A, B), f(X, Z), Y, N), A=X, B=Z.

Y = Y
N = no
...
yes.
</PRE>

<P>
Now we have a constraint predicate that can be used both to impose
disequality on two terms and to query it.
For instance, a condition "if T1 = T2 then X = single else X = double"
can be expressed as<PRE>
cond(T1, T2, X) :-
    dif3(T1, T2, Yes, No),
    cond_eval(X, Yes, No).

cond_eval(X, yes, _) :- -?-&gt;
    X = double.
cond_eval(X, _, no) :- -?-&gt;
    X = single.
cond_eval(X, Yes, No) :-
    var(Yes),
    var(No),
    suspend(cond_eval(X, Yes, No), 2, Yes-No-&gt;inst).
</PRE>

<P>
This example could be further extended, e.g. to take care of shared
variables, occur check or propagating from the answer variable
(e.g. imposing equality on all matched argument pairs when the
variable <B>Y</B> is instantiated).
We leave this as a (rather advanced) exercise to the reader.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html4041"
 HREF="node121.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html4037"
 HREF="node118.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html4031"
 HREF="node119.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html4039"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html4042"
 HREF="node121.html">Waiting for other Constraints</A>
<B> Up:</B> <A NAME="tex2html4038"
 HREF="node118.html">More About Suspension</A>
<B> Previous:</B> <A NAME="tex2html4032"
 HREF="node119.html">Waiting for Instantiation</A>
 &nbsp <B>  <A NAME="tex2html4040"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
