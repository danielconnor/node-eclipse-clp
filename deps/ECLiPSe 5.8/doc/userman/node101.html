<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Attributed Variable Handlers</TITLE>
<META NAME="description" CONTENT="Attributed Variable Handlers">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node102.html">
<LINK REL="previous" HREF="node100.html">
<LINK REL="up" HREF="node94.html">
<LINK REL="next" HREF="node102.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3756"
 HREF="node102.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3752"
 HREF="node94.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3746"
 HREF="node100.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3754"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3757"
 HREF="node102.html">Built-Ins and Attributed Variables</A>
<B> Up:</B> <A NAME="tex2html3753"
 HREF="node94.html">Attributed Variables</A>
<B> Previous:</B> <A NAME="tex2html3747"
 HREF="node100.html">Attribute Modification</A>
 &nbsp <B>  <A NAME="tex2html3755"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html3758"
 HREF="node101.html#SECTION001671000000000000000">Printing Attributed Variables</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION001670000000000000000"></A>
<A NAME="metahandlers"></A>
<BR>
Attributed Variable Handlers
</H1>
An attributed variable is a variable with some additional information
which is ignored by ordinary <I>object level</I> system predicates.
<I>Meta level</I> operations on attributed variables are handled by
extensions which know
the contents of their attributes and can specify the outcome
of each operation.
This mechanism is implemented using <I>attributed variable handlers</I>,
<A NAME="9636"></A>
which are user-defined predicates invoked
whenever an attributed variable occurs in one of the predefined
operations.
The handlers are specified in the attribute declaration
<B>meta_attribute(Name, HandlerList)</B>, the second argument
is a list of handlers in the form<PRE>
[unify:UnifyHandler, test_unify:TUHandler, ...]
</PRE>
Handlers for operations which are not specified or those that are
<A NAME="tex2html1313"
 HREF="../bips/kernel/control/true-0.html">true/0</A><A NAME="9839"></A> are ignored and never invoked.
If <B>Name</B> is an existing extension, the specified handlers
replace the current ones.

<P>
Whenever one of the specified operations detects an attributed variable,
it will invoke all handlers that were declared for it
and each of them receives either the whole attributed variable
or its particular attribute as argument.
The system does not check if the attribute that corresponds
to a given handler is instantiated or not; this means
that the handler must check itself if the attributed variable
contains any attribute information or not.
For instance, if an attributed variable <I>X{a:_, b:_, c:f(a)}</I>
is unified with the attributed variable <I>Y{a:_, b:_, c:f(b)}</I>,
the handlers for the attributes <I>a</I> and <I>b</I> should
treat this as binding of two plain variables
because their attributes were not involved.
Only the handler for <I>c</I> has any work to do here.
The library <B>suspend.pl</B> can be used as a template
<A NAME="9651"></A>
for writing attributed variable handlers.

<P>
The following operations invoke attributed variable handlers:

<P>

<UL><LI><B>unify</B>: the usual unification.
<A NAME="9654"></A>
The handler procedure is
<BLOCKQUOTE>
unify_handler(+Term, ?Attribute [,SuspAttr])

</BLOCKQUOTE>
The first argument is the term that was unified with the attributed variable,
it is either a nonvariable or an attributed variable.
The second argument is directly the contents of the attribute slot
corresponding to the extension, i.e. it is not the whole attributed variable.
When this handler is invoked, the attributed variable is already bound
to <I>Term</I>.
The optional third argument is the suspend-attribute of the former
variable; it may be needed to wake the variable's 'constrained' suspension
list.

<P>
If an attributed variable is unified with a standard variable, the variable is bound
to the attributed variable and no handlers are invoked.
If an attributed variable is unified with another attributed variable or a non-variable,
the attributed variable is bound (like a standard variable) to the other term
<B>and</B> all handlers for the <B>unify</B> operation are invoked. 
Note that several attributed variable bindings can occur e.g. during a head unification
and also during a single unification of compound terms.
The handlers are only invoked at certain trigger points (usually before the
next predicate call).

<P>

<LI><B>test_unify</B>: the unification which is not supposed
<A NAME="9661"></A>
to trigger constraints propagation, it is used e.g.
in the <A NAME="tex2html1318"
 HREF="../bips/kernel/termcomp/not_unify-2.html">not_unify/2</A><A NAME="9842"></A>
predicate.
The handler procedure is
<BLOCKQUOTE>
test_unify_handler(+Term, ?Attribute)

</BLOCKQUOTE>
where the arguments are the same as for the unify handler.
During the execution of the handler the attributed variable is bound
to <I>Term</I>, however when all local handlers succeed,
all bindings are undone.

<P>

<LI><B>compare_instances</B>: computation of instance, subsumption
<A NAME="9668"></A>
and variance relationship, as performed by the built-ins
<A NAME="tex2html1321"
 HREF="../bips/kernel/termcomp/instance-2.html">instance/2</A><A NAME="9845"></A> and
<A NAME="tex2html1323"
 HREF="../bips/kernel/termcomp/variant-2.html">variant/2</A><A NAME="9848"></A>.
The handler procedure is
<BLOCKQUOTE>
instance_handler(-Res, ?TermL, ?TermR)

</BLOCKQUOTE>
and its arguments are similar to the ones of the
<A NAME="tex2html1325"
 HREF="../bips/kernel/termcomp/compare_instances-3.html">compare_instances/3</A><A NAME="9851"></A>
predicate.
The handler is invoked with one or both of <I>TermL</I> and <I>TermR</I> being
attributed variables. The task of the handler is to compare the two terms
and instantiate <B>Res</B> to either = or &lt; (or fail if the result is &gt;),
according to the result of the comparison.
All bindings made in the handler will be undone after processing
the local handlers.

<P>

<LI><B>copy_term</B>: the handler is invoked when terms are copied by the
<A NAME="9681"></A>
<A NAME="tex2html1328"
 HREF="../bips/kernel/termmanip/copy_term-2.html">copy_term/2</A><A NAME="9854"></A> or
<A NAME="tex2html1330"
 HREF="../bips/kernel/termmanip/copy_term_vars-3.html">copy_term_vars/3</A><A NAME="9857"></A> built-ins.
The handler procedure is
<BLOCKQUOTE>
copy_handler(?AttrVar, ?Copy)

</BLOCKQUOTE>
<I>AttrVar</I> is the attributed variable encountered in the
copied term, <I>Copy</I> is its corresponding variable in the copy.
All extension handlers receive the same arguments.
This means that if the attributed variable should be copied as
an attributed variable, the handler must check if <I>Copy</I> is still
a free variable or if it was already bound to an attributed variable by a previous handler.

<P>

<LI><B>suspensions</B>: this handler is invoked by the
<A NAME="9692"></A>
<A NAME="tex2html1333"
 HREF="../bips/kernel/suspensions/suspensions-2.html">suspensions/2</A><A NAME="9860"></A> predicate
to collect all the suspension lists inside the attribute.
The handler call pattern is
<BLOCKQUOTE>
suspensions_handler(?AttrVar, -ListOfSuspLists, -Tail)

</BLOCKQUOTE>
<I>AttrVar</I> is an attributed variable. The handler should bind
<I>ListOfSuspLists</I> to a list containing all the attribute's
suspension lists and ending with <I>Tail</I>.

<P>

<LI><B>delayed_goals_number</B>: handler is invoked by the
<A NAME="9701"></A>
<A NAME="tex2html1336"
 HREF="../bips/kernel/suspensions/delayed_goals_number-2.html">delayed_goals_number/2</A><A NAME="9863"></A>
predicate.
The handler call pattern is
<BLOCKQUOTE>
delayed_goals_number_handler(?AttrVar, -Number)

</BLOCKQUOTE>
<I>AttrVar</I> is the attributed variable encountered in the
term, <I>Number</I> is the number of delayed
goals occurring in this attribute.
Its main purpose is for the first-fail selection predicates,
i.e. it should return the number of constraints imposed on
the variable.

<P>

<LI><B>get_bounds</B>:
<A NAME="9709"></A>
    This handler is used by the predicate
    <A NAME="tex2html1339"
 HREF="../bips/kernel/termmanip/get_var_bounds-3.html">get_var_bounds/3</A><A NAME="9866"></A>

to retrieve information about the lower and upper bound of a numeric
    variable. 
    The handler should therefore only be defined if the attribute contains
    that kind of information. The handler call pattern is
    <BLOCKQUOTE>
    get_bounds_handler(?AttrVar, -Lwb, -Upb)
    
</BLOCKQUOTE>
    The handler is only invoked if the variable has the corresponding
    (non-empty) attribute.
    The handler should bind <I>Lwb</I> and <I>Upb</I> to numbers
    (any numeric type) reflecting the attribute's information about lower
    and upper bound of the variable, respectively.
    If different attributes return different bounds information,
    <A NAME="tex2html1341"
 HREF="../bips/kernel/termmanip/get_var_bounds-3.html">get_var_bounds/3</A><A NAME="9869"></A>

will return the narrowest ones.

<LI><B>set_bounds</B>:
<A NAME="9719"></A>
    This handler is used by the predicate
    <A NAME="tex2html1344"
 HREF="../bips/kernel/termmanip/set_var_bounds-3.html">set_var_bounds/3</A><A NAME="9872"></A>

to distribute information about the lower and upper bound of a numeric
    variable to all its existing attributes. 
    The handler should therefore only be defined if the attribute can
    incorporate this kind of information. The handler call pattern is
    <BLOCKQUOTE>
    set_bounds_handler(?AttrVar, +Lwb, +Upb)
    
</BLOCKQUOTE>
    The handler is only invoked if the variable has the corresponding
    (non-empty) attribute.
    <I>Lwb</I> and <I>Upb</I> are the numbers that were passed to
    <A NAME="tex2html1346"
 HREF="../bips/kernel/termmanip/set_var_bounds-3.html">set_var_bounds/3</A><A NAME="9875"></A>, and the handler is expected to update its

own bounds representation accordingly.

<P>

<LI><B>print</B>: attribute printing in
<A NAME="9729"></A>
<A NAME="tex2html1349"
 HREF="../bips/kernel/ioterm/write-1.html">write/1,2</A><A NAME="9878"></A>,
<A NAME="tex2html1351"
 HREF="../bips/kernel/ioterm/writeln-1.html">writeln/1,2</A><A NAME="9881"></A>,
<A NAME="tex2html1353"
 HREF="../bips/kernel/ioterm/printf-2.html">printf/2,3</A><A NAME="9884"></A>
when the <B>m</B> option is specified.
The handler procedure is
<BLOCKQUOTE>
print_handler(?AttrVar, -Attribute)

</BLOCKQUOTE>
<I>AttrVar</I> is the attributed variable being printed, <I>Attribute</I>
is the term which will be printed as a value for this attribute,
prefixed by the attribute name.
If no handler is specified for an attribute, or the print handler fails, 
the attribute will not be printed.

<P>

</UL>

<P>
The following handlers are still supported for compatibility,
but their use is not recommened:

<UL><LI><B>pre_unify</B>: this is another handler which can be invoked on
<A NAME="9744"></A>
normal unification, but it is called <I>before</I> the unification
itself occurs.
The handler procedure is
<BLOCKQUOTE>
pre_unify_handler(?AttrVar, +Term)

</BLOCKQUOTE>
The first argument is the attributed variable to be unfied,
the second argument is the term it is going to be unified with.
This handler is provided only for compatibility with SICStus Prolog
and its use is not recommended, because it is less efficient
than the <B>unify</B> handler and because its semantics is somewhat
unclear, there may be cases where changes inside this handler
may have unexpected effects.

<P>

<LI><B>delayed_goals</B>: this handler is superseded by the
<A NAME="9750"></A>
suspensions-handler, which should be preferred. If there is no suspensions-
handler, this handler is invoked by the obsolete
<A NAME="tex2html1357"
 HREF="../bips/kernel/suspensions/delayed_goals-2.html">delayed_goals/2</A><A NAME="9887"></A> predicate.
The handler procedure is
<BLOCKQUOTE>
delayed_goals_handler(?AttrVar, ?GoalList, -GoalCont)

</BLOCKQUOTE>
<I>AttrVar</I> is the attributed variable encountered in the
term, <I>GoalList</I> is an open-ended list of all delayed
goals in this attribute and <I>GoalCont</I> is the
tail of this list.

<P>

</UL>

<P>

<H2><A NAME="SECTION001671000000000000000"></A>
<A NAME="9760"></A>
<A NAME="9761"></A>
<BR>
Printing Attributed Variables
</H2>
The different output predicates treat attributed variables differently.
The <A NAME="tex2html1362"
 HREF="../bips/kernel/ioterm/write-1.html">write/1</A><A NAME="9890"></A> predicate prints
the attributes using the print-handlers,
while <A NAME="tex2html1364"
 HREF="../bips/kernel/ioterm/writeq-1.html">writeq/1</A><A NAME="9893"></A> prints the whole attribute, so that the attributed variable
can be read back.
The <A NAME="tex2html1366"
 HREF="../bips/kernel/ioterm/printf-2.html">printf/2</A><A NAME="9896"></A> predicate has two options to be combined with
the <B>w</B> format: <B>M</B> forces the whole attributed variable to be printed
together with all its attributes in the standard format, so that
it can be read back in.
With the <B>m</B> option the attributed variable is printed using the handlers
defined for the <B>print</B> operation.
If there is only one handled attribute, the attributed variable is printed as
<BLOCKQUOTE>
X{Attr}

</BLOCKQUOTE>
where <I>Attr</I> is the value obtained from the handler.
If there are several handled attributes, all attributes are qualified
like in
<BLOCKQUOTE>
X{a:A, b:B, c:C}.

</BLOCKQUOTE>

An attributed variable <TT>X{m:a}</TT> with <B>print</B> handler <B>=/2</B>
can thus be printed in different ways, e.g.:
<A NAME="tex2html1361"
 HREF="footnode.html#foot9819"><SUP>16.1</SUP></A><PRE>
printf("%w", [X{m:a}])   or write(X{m:a}):    X   
printf("%vMw", [X{m:a}]) or writeq(X{m:a}):   _g246{suspend : _g242, m : a}
printf("%mw", [X{m:a}]):                      X{a}
printf("%Mw", [X{m:a}]):                      X{suspend : _g251, m : a}
printf("%Vmw", [X{m:a}]):                     X_g252{a}
</PRE>

<P>
<A NAME="9785"></A>
Write macros for attributed variables are not allowed because one extension alone
should not decide whether the other attributes will be printed or not.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html3756"
 HREF="node102.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3752"
 HREF="node94.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3746"
 HREF="node100.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3754"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3757"
 HREF="node102.html">Built-Ins and Attributed Variables</A>
<B> Up:</B> <A NAME="tex2html3753"
 HREF="node94.html">Attributed Variables</A>
<B> Previous:</B> <A NAME="tex2html3747"
 HREF="node100.html">Attribute Modification</A>
 &nbsp <B>  <A NAME="tex2html3755"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
