<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Advanced Topics</TITLE>
<META NAME="description" CONTENT="Advanced Topics">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node43.html">
<LINK REL="previous" HREF="node41.html">
<LINK REL="up" HREF="node39.html">
<LINK REL="next" HREF="node43.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html2868"
 HREF="node43.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2864"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2858"
 HREF="node41.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2866"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2869"
 HREF="node43.html">Less Common Topics</A>
<B> Up:</B> <A NAME="tex2html2865"
 HREF="node39.html">Module System</A>
<B> Previous:</B> <A NAME="tex2html2859"
 HREF="node41.html">Getting Started</A>
 &nbsp <B>  <A NAME="tex2html2867"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html2870"
 HREF="node42.html#SECTION00731000000000000000">Solving Name Conflicts</A>
<LI><A NAME="tex2html2871"
 HREF="node42.html#SECTION00732000000000000000">Qualified Access via :/2</A>
<LI><A NAME="tex2html2872"
 HREF="node42.html#SECTION00733000000000000000">Reexport - Making Modules from Modules</A>
<LI><A NAME="tex2html2873"
 HREF="node42.html#SECTION00734000000000000000">Modules and Source Files</A>
<LI><A NAME="tex2html2874"
 HREF="node42.html#SECTION00735000000000000000">Tools and Caller Modules</A>
<UL>
<LI><A NAME="tex2html2875"
 HREF="node42.html#SECTION00735100000000000000">Tools</A>
<LI><A NAME="tex2html2876"
 HREF="node42.html#SECTION00735200000000000000">System Tools</A>
</UL>
<LI><A NAME="tex2html2877"
 HREF="node42.html#SECTION00736000000000000000">Lookup Module vs Caller Module</A>
<LI><A NAME="tex2html2878"
 HREF="node42.html#SECTION00737000000000000000">The Module Interface</A>
<LI><A NAME="tex2html2879"
 HREF="node42.html#SECTION00738000000000000000">Module-related Predicate Properties</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00730000000000000000">
Advanced Topics</A>
</H1>

<H2><A NAME="SECTION00731000000000000000">
Solving Name Conflicts</A>
</H2>

<P>
Name conflicts occur in two flavours:
<A NAME="3903"></A>
<DL>
<DT><STRONG>Import/Import conflict:</STRONG>
<DD>this is the case when two or more imported modules provide a
    predicate of the same name.
<DT><STRONG>Import/Local conflict:</STRONG>
<DD>this is the case when a local (or exported) predicate has the
    same name as a predicate provided from an imported module.
</DL>
Conflicts of the first type are accepted silently by the system as
long as there is no reference to the conflict predicate. Only when an attempt
<A NAME="3906"></A>
is made to access the conflict predicate is an error raised.
The conflict can be resolved by explicitly importing one of the versions, e.g.<PRE>
:- lib(ria). % exports #&gt;= / 2
:- lib(eplex). % exports #&gt;= / 2
:- import (#&gt;=)/2 from ria. % resolves the conflict
</PRE>
Alternatively, the conflict can remain unresolved and qualified access can
be used whenever the predicates are referred to (see&nbsp;<A HREF="node42.html#qualifiedaccess">7.3.2</A>).

<P>
Conflicts of the second type give rise to an error or warning message
<A NAME="3912"></A>
<A NAME="3913"></A>
when the compiler encounters the local (re)definition. To avoid that,
an explicit
<A NAME="tex2html455"
 HREF="../bips/kernel/modules/local-1.html">local/1</A><A NAME="4196"></A>
declaration has to be used:<PRE>
:- local write/1.
write(X) :- % my own version of write/1
...
</PRE>
Note that the <A NAME="tex2html457"
 HREF="../bips/kernel/modules/local-1.html">local/1</A><A NAME="4199"></A>-declaration
must occur textually before any use of the predicate inside the module.

<P>

<H2><A NAME="SECTION00732000000000000000"></A>
<A NAME="qualifiedaccess"></A><A NAME="3924"></A>
<BR>
Qualified Access via :/2
</H2>

<P>
Normally, it is convenient to import predicates which are needed.
By importing, they become <B>visible</B> and can be used within
<A NAME="3926"></A>
the module in the same way as local definitions.
However, sometimes it is preferable to explicitly specify from
which module a definition is meant to be taken. This is the case for
example when multiple versions of the predicate are needed,
or when the presence of a local definition makes it impossible
to import a predicate of the same name from elsewhere.
A call with explicit module qualification is done using
<A NAME="tex2html461"
 HREF="../bips/kernel/control/N-2.html">: /2</A><A NAME="4202"></A>
and looks like this:<PRE>
lists:print_list([1,2,3])
</PRE>
Here, the module where the definition of print_list/1 is looked up
(the <B>lookup module</B>) is explicitly specified. To call print_list/1
like this, it is not necessary to make print_list/1 visible.
The only requirement is that it is exported (or reexported) from
the module <TT>lists</TT>.

<P>
Note that, if the called predicate is in operator notation, it will
often be necessary to use brackets, e.g. in<PRE>
..., ria:(X #&gt;= Y), ...
</PRE>

<P>
The <A NAME="tex2html463"
 HREF="../bips/kernel/control/N-2.html">: /2</A><A NAME="4205"></A> primitive can be used to resolve import conflicts,
i.e. the case where the same name is exported from more than one
module and both are needed. In this case, none of the conflicting
predicates is imported - an attempt to call the unqualified predicate
raises an error.
The solution is to qualify every reference with the module name:<PRE>
:- lib(ria). % exports #&gt;= / 2
:- lib(eplex). % exports #&gt;= / 2

    ..., ria:(X #&gt;= Y), ...
    ..., eplex:(X #&gt;= Y), ...
</PRE>

<P>
Another case is the situation that a module wants to define a
predicate of a given name but at the same time use a predicate
of the same name from another module. It is not possible to
import the predicate because of the name conflict with the local
definition. Explicit qualification must be used instead:<PRE>
:- lib(lists).

print_list(List) :-
        writeln("This is the list"),
        lists:print_list(List).
</PRE>

<P>
A more unusual feature, which is however very appropriate for
constraint programming, is the possibility to call several versions
of the same predicate by specifying several lookup modules:<PRE>
    ..., [ria,eplex]:(X #&gt;= Y), ...
</PRE>
which has exactly the same meaning as<PRE>
    ..., ria:(X #&gt;= Y), eplex:(X #&gt;= Y), ...
</PRE>
Note that the modules do not have to be known at compile time, i.e. it
is allowed to write code like<PRE>
    after(X, Y, Solver) :-
        Solver:(X #&gt;= Y).
</PRE>
However, this is likely to be less efficient because it prevents
compile-time optimizations.

<P>

<H2><A NAME="SECTION00733000000000000000">
Reexport - Making Modules from Modules</A>
</H2>

<P>
To allow more flexibility in the design of module interfaces, and to
avoid duplication of definitions, it is possible to re-export definitions.
A reexport is an import combined with an export.
That means that a reexported definition becomes visible inside the
reexporting module and is at the same time exported again.
A user of a module's interface sees no difference between
exported and reexported definitions<A NAME="tex2html465"
 HREF="footnode.html#foot3962"><SUP>7.2</SUP></A>.

<P>
There are 3 forms of the
<A NAME="tex2html467"
 HREF="../bips/kernel/modules/reexport-1.html">reexport/1</A><A NAME="4208"></A>
directive. To reexport the complete
module interface of another module, use<PRE>
:- reexport amodule.
</PRE>
To reexport only an explicitly enumerated selection, use<PRE>
:- reexport p/1,q/2 from amodule.
</PRE>
To reexport everything except some explicitly enumerated items, use<PRE>
:- reexport amodule except p/2,q/3.
</PRE>

<P>
These facilities make it possible to extend, modify, restrict or
combine modules into new modules, as illustrated in figure&nbsp;<A HREF="node42.html#reexport">7.1</A>. 

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="reexport"></A><A NAME="3982"></A>
<TABLE>
<CAPTION><STRONG>Figure 7.1:</STRONG>
Making modules from modules with reexport</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
</DIV><!-- MATH: $\includegraphics{reexport.eps}$ -->
<IMG
 WIDTH="713" HEIGHT="392" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.gif"
 ALT="\includegraphics{reexport.eps}">
<DIV ALIGN="CENTER">
</DIV></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00734000000000000000"></A>
<A NAME="3986"></A>
<BR>
Modules and Source Files
</H2>

<P>
When a source file contains no module directives, it becomes part of
the module from which its compilation was invoked.  This makes it
possible to write small programs without caring about modules. 
However, serious applications should be structured into modules. 

<P>
Often it is the most appropriate to have one file per module and to
have the file name match the module name.

<P>
It is however possible to have several modules in one file, e.g. a
main module and one or more auxiliary modules - in that
case the name of the main module should match the filename.
Every module-directive in the file marks the end of the previous
module and the start of the next one.

<P>
It is also possible to spread the contents of a module over several
files. In this case, there should be a main file whose filename
matches the module name, and the other files should be referenced
from the main file using the <A NAME="tex2html470"
 HREF="../bips/kernel/directives/include-1.html">include/1</A><A NAME="4211"></A> directive, e.g.<PRE>
:- module(bigmodule).
:- include(part1).
:- include(part2).
</PRE>

<P>

<H2><A NAME="SECTION00735000000000000000">
Tools and Caller Modules</A>
</H2>

<P>

<H3><A NAME="SECTION00735100000000000000"></A>
<A NAME="3995"></A>
<A NAME="3996"></A>
<A NAME="tools"></A>
<BR>
Tools
</H3>
There are predicates in a modular system that need to know from which
module they were called (since this may be different from the module
in which they were defined).
<A NAME="3998"></A>
The most common case is where a predicate is a meta-predicate,
i.e. a predicate that has another goal or predicate name as an argument.
Other cases are I/O predicates - they need to be executed in a
certain module context in order to obey the correct syntax of this module.
In ECLiPSe, such predicates that need to know their caller module
are called <B>tool</B> predicates<A NAME="tex2html474"
 HREF="footnode.html#foot4001"><SUP>7.3</SUP></A>.

<P>
Tool predicates must be declared.  As a consequence, the system will
automatically add a <B>caller module</B> argument whenever such a tool
predicate is called.

<P>
Consider for example a predicate that calls another predicate twice.
<A NAME="4003"></A>
The naive version of this predicate looks like<PRE>
twice(Goal) :-
    call(Goal),
    call(Goal).
</PRE>
As long as no modules are involved, this works fine.
Now consider the situation where the definition of twice/1 and a
call of twice/1 are in two different modules:<PRE>
:- module(stuff).
:- export twice/1.
twice(Goal) :-
    call(Goal),
    call(Goal).

:- module(main).
:- import stuff.

top :- twice(hello).

hello :- writeln(hi).
</PRE>
This will not work because hello/0 is only visible in module main
and an attempt to call it from within twice/1 in module stuff will
raise an error. The solution is to declare twice/1 as a tool and
change the code as follows:<PRE>
:- module(stuff).
:- export twice/1.
:- tool(twice/1, twice/2).
twice(Goal, Module) :-
    call(Goal)@Module,
    call(Goal)@Module.
</PRE>
What happens now is that the call to twice/1 in module main<PRE>
..., twice(hello), ...
</PRE>
is effectively replaced by the system with a call to twice/2 where
the additional argument is the module in which the call occurs:<PRE>
..., twice(hello, main), ...
</PRE>
This caller module is then used by twice/2 to execute<PRE>
..., call(hello)@main, ...
</PRE>
The 
<A NAME="tex2html477"
 HREF="../bips/kernel/control/A-2.html">call(Goal)@Module</A><A NAME="4214"></A>
construct means that the call is supposed to happen
<EM>in the context</EM> of module main.

<P>
The debugger trace shows what happens:<PRE>
[main 5]: top.
  (1) 1 CALL  top
  (2) 2 CALL  twice(hello)
  (3) 3 CALL  twice(hello, main)
  (4) 4 CALL  call(hello) @ main
  (5) 5 CALL  call(hello)
  (6) 6 CALL  hello
S (7) 7 CALL  writeln(hi)
hi
S (7) 7 EXIT  writeln(hi)
  (6) 6 EXIT  hello
  ...
</PRE>

<P>
One complication that can arise when you use tools is that the compiler
must know that a predicate is a tool in order to properly compile
a call to the tool.
If the call occurs textually before the tool
declaration,  this will therefore give rise to an
<B>inconsistent tool redefinition</B> error.
The
<A NAME="tex2html479"
 HREF="../bips/kernel/modules/tool-2.html">tool/2</A><A NAME="4217"></A>
declaration must therefore occur before any call to the tool.

<P>

<H3><A NAME="SECTION00735200000000000000"></A>
<A NAME="4040"></A>
<BR>
System Tools
</H3>
Many of the system built-in predicates are in fact tools, e.g.
<A NAME="tex2html482"
 HREF="../bips/kernel/ioterm/read-1.html">read/1</A><A NAME="4220"></A>,
<A NAME="tex2html484"
 HREF="../bips/kernel/ioterm/write-1.html">write/1</A><A NAME="4223"></A>,
<A NAME="tex2html486"
 HREF="../bips/kernel/record/record-2.html">record/2</A><A NAME="4226"></A>,
<A NAME="tex2html488"
 HREF="../bips/kernel/database/compile-1.html">compile/1</A><A NAME="4229"></A>, etc.
All predicates which handle modular items must be tools
so that they know from which module they have been called.
In case that the built-in predicate has to be executed in
a different module (this is very often the case inside
user tool predicates), the 
<A NAME="tex2html490"
 HREF="../bips/kernel/control/A-2.html">@ /2</A><A NAME="4232"></A>
construct must be used, e.g.<PRE>
current_predicate(P) @ SomeModule
</PRE>

<P>

<H2><A NAME="SECTION00736000000000000000"></A>
<A NAME="4056"></A>
<A NAME="4057"></A>
<BR>
Lookup Module vs Caller Module
</H2>

<P>
The following table summarises the different call patterns with and
without module specifications.
There are only two basic rules to remember:

<UL><LI><A NAME="tex2html494"
 HREF="../bips/kernel/control/N-2.html">: /2</A><A NAME="4235"></A>

specifies the <B>lookup module</B> (to find the definition)

<LI><A NAME="tex2html496"
 HREF="../bips/kernel/control/A-2.html">@ /2</A><A NAME="4238"></A>

specifies the <B>caller module</B> (to know the context)

</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Call inside module(m)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Module where definition of twice/1 is looked up</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Caller module argument added to twice/1</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>..., twice(X), ...</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>m</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>m</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>..., lm : twice(X), ...</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>lm</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>m</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>..., twice(X) @ cm, ...</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>m</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>cm</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>..., lm : twice(X) @ cm, ...</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>lm</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>cm</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>..., call(twice(X)) @ cm, ...</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>cm</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>cm</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION00737000000000000000">
The Module Interface</A>
</H2>
The primitive 
<A NAME="tex2html498"
 HREF="../bips/kernel/modules/current_module-1.html">current_module/1</A><A NAME="4241"></A>
can be used to check for the existence of a module, or to enumerate
all currently defined modules.

<P>
Further details about existing modules can be retrieved using
<A NAME="4074"></A>
<A NAME="tex2html501"
 HREF="../bips/kernel/modules/get_module_info-3.html">get_module_info/3</A><A NAME="4244"></A>,
in particular information about the module's interface, what other
modules it uses and whether it is locked (see&nbsp;<A HREF="node43.html#locking">7.4.4</A>).

<P>

<H2><A NAME="SECTION00738000000000000000">
Module-related Predicate Properties</A>
</H2>
Information about a predicate's properties can be retrieved using the 
<A NAME="4079"></A>
<A NAME="tex2html504"
 HREF="../bips/kernel/database/get_flag-3.html">get_flag/3</A><A NAME="4247"></A> primitive
or printed using <A NAME="tex2html506"
 HREF="../bips/kernel/env/pred-1.html">pred/1</A><A NAME="4250"></A>.
The module-related predicate properties are
<DL>
<DT><STRONG>defined</STRONG>
<DD>(on/off) indicates whether code for the predicate has already

been compiled. If not, only a declaration was encountered.
<DT><STRONG>definition_module</STRONG>
<DD>(an atom) the module where the predicate is defined.
<DT><STRONG>visibility</STRONG>
<DD>(local/exported/reexported/imported) indicates the visibility
	of the predicate in the caller module.
<DT><STRONG>tool</STRONG>
<DD>(on/off) indicates whether the predicate has been declared a tool.
</DL>
For tool predicates, 
<A NAME="tex2html508"
 HREF="../bips/kernel/modules/tool_body-3.html">tool_body/3</A><A NAME="4253"></A>
can be used to retrieve the predicate it maps to when the module
argument is added.

<P>
To get information about a predicate visible in a different module,
use for instance<PRE>
    get_flag(p/3, visibility, V) @ othermodule
</PRE>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html2868"
 HREF="node43.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2864"
 HREF="node39.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2858"
 HREF="node41.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2866"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2869"
 HREF="node43.html">Less Common Topics</A>
<B> Up:</B> <A NAME="tex2html2865"
 HREF="node39.html">Module System</A>
<B> Previous:</B> <A NAME="tex2html2859"
 HREF="node41.html">Getting Started</A>
 &nbsp <B>  <A NAME="tex2html2867"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
