<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Timing Profiler</TITLE>
<META NAME="description" CONTENT="Timing Profiler">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node91.html">
<LINK REL="previous" HREF="node89.html">
<LINK REL="up" HREF="node84.html">
<LINK REL="next" HREF="node91.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html3612"
 HREF="node91.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3608"
 HREF="node84.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3602"
 HREF="node89.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3610"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3613"
 HREF="node91.html">Port Profiler</A>
<B> Up:</B> <A NAME="tex2html3609"
 HREF="node84.html">Development Support Tools</A>
<B> Previous:</B> <A NAME="tex2html3603"
 HREF="node89.html">Pretty Printer Tool</A>
 &nbsp <B>  <A NAME="tex2html3611"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001560000000000000000"></A>

<A NAME="9285"></A>
<BR>
Timing Profiler
</H1> The profiling tool<A NAME="tex2html1272"
 HREF="footnode.html#foot9286"><SUP>15.1</SUP></A> helps to find <I>hot spots</I> in
a program that are worth optimising. It can be used any time with any
compiled Prolog code, it is not necessary to use a special compilation
mode or set any flags.  Note however that it is not available on
Windows<A NAME="9288"></A>.  When<PRE>

?- profile(Goal).
</PRE>
<A NAME="9293"></A> is called, the profiler executes the <I>Goal</I> in
the profiling mode, which means that every 100th of a second the
execution is interrupted and the profiler records the currently
executing procedure.

Issuing the following query will result in the profiler recording the
currently executing goal 100 times a second.
<PRE>

?- profile(queen([1,2,3,4,5,6,7,8,9],Out)).
goal succeeded

                PROFILING STATISTICS
                --------------------

Goal:             queen([1, 2, 3, 4, 5, 6, 7, 8, 9], Out)
Total user time:  0.03s

Predicate             Module %Time   Time   %Cum
--------------------------------------------------------
qdelete           /4  eclipse       50.0%   0.01s  50.0%
nodiag            /3  eclipse       50.0%   0.01s 100.0%

Out = [1, 3, 6, 8, 2, 4, 9, 7, 5]
Yes (0.14s cpu)
</PRE>

From the above result we can see how the profiler output contains four
important areas of information:
<DL COMPACT>
<DT>1.
<DD>The first line of output indicates whether the specified goal
<B>succeeded</B>, <B>failed</B> or <B>aborted</B>.  The
<code>profile/1</code> predicate itself always succeeds.
<DT>2.
<DD>The line beginning <code>Goal:</code> shows the goal which was
profiled.
<DT>3.
<DD>The next line shows the time spent executing the goal.
<DT>4.
<DD>Finally the predicates which were being executed when the
profiler sampled, ranked in decreasing sample count order are shown. 
</DL>

Auxiliary system predicates are printed under a
common name without arity, e.g. <I>arithmetic</I> or <I>
all_solutions</I>.
Predicates which are local to locked modules are printed
together on a single line that contains only the module name.
By default only predicates written in Prolog are profiled, i.e.
if a Prolog predicate calls an external or built-in predicate
written in C, the time will be assigned to the Prolog predicate.

The predicate <B>profile(Goal, Flags)</B> can be used to change
the way profiling is made, <I>Flags</I> is a list of flags.
Currently only the flag <TT>simple</TT> is accepted and it
causes separate profiling of simple predicates, i.e.
those written in C.

The problem with the results displayed above is that the sampling
frequency is too low when compared to the total user time spent
executing the goal.  In fact in the above example the profiler was
only able to take two samples before the goal terminated.

The frequency at which the profiler samples is fixed, so in order to
obtain more representative results one should have an auxiliary
predicate which calls the goal a number of times, and compile and
profile a call to this auxiliary predicate. eg.
<PRE>

queen_100 :-
  (for(_,1,100,1) do queen([1,2,3,4,5,6,7,8,9],_Out)).
</PRE>

Note that, when compiled, the above <code>do/2</code> loop would be
efficiently implemented and not cause overhead that would distort the
measurement.  Section <A HREF="node22.html#doloops">5.2</A> presents a 
detailed description of logical loops.
<PRE>

?- profile(queen_100).
goal succeeded

                PROFILING STATISTICS
                --------------------

Goal:             queen_100
Total user time:  3.19s

Predicate             Module %Time   Time   %Cum
--------------------------------------------------------
nodiag            /3  eclipse       52.2%   1.67s  52.2%
qdelete           /4  eclipse       27.4%   0.87s  79.6%
qperm             /2  eclipse       17.0%   0.54s  96.5%
safe              /1  eclipse        2.8%   0.09s  99.4%
queen             /2  eclipse        0.6%   0.02s 100.0%

Yes (3.33s cpu)
</PRE>

In the above example, the profiler takes over three hundred samples
resulting in a more accurate view of where the time is being spent in
the program.  In this instance we can see that more than half of the
time is spent in the <code>nodiag/3</code> predicate, making it an ideal
candidate for optimisation.  This is left as an exercise for the
reader.

<HR>
<!--Navigation Panel-->
<A NAME="tex2html3612"
 HREF="node91.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html3608"
 HREF="node84.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html3602"
 HREF="node89.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html3610"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3613"
 HREF="node91.html">Port Profiler</A>
<B> Up:</B> <A NAME="tex2html3609"
 HREF="node84.html">Development Support Tools</A>
<B> Previous:</B> <A NAME="tex2html3603"
 HREF="node89.html">Pretty Printer Tool</A>
 &nbsp <B>  <A NAME="tex2html3611"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
