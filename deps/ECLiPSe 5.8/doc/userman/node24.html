<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>The String Data Type</TITLE>
<META NAME="description" CONTENT="The String Data Type">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node25.html">
<LINK REL="previous" HREF="node23.html">
<LINK REL="up" HREF="node20.html">
<LINK REL="next" HREF="node25.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html2603"
 HREF="node25.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2599"
 HREF="node20.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2593"
 HREF="node23.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2601"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2604"
 HREF="node25.html">Matching Clauses</A>
<B> Up:</B> <A NAME="tex2html2600"
 HREF="node20.html">ECLiPSe-specific Language Features</A>
<B> Previous:</B> <A NAME="tex2html2594"
 HREF="node23.html">Array Notation</A>
 &nbsp <B>  <A NAME="tex2html2602"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html2605"
 HREF="node24.html#SECTION00541000000000000000">Choosing The Appropriate Data Type</A>
<UL>
<LI><A NAME="tex2html2606"
 HREF="node24.html#SECTION00541100000000000000">Strings vs. Character Lists</A>
<LI><A NAME="tex2html2607"
 HREF="node24.html#SECTION00541200000000000000">Strings vs. Atoms</A>
<LI><A NAME="tex2html2608"
 HREF="node24.html#SECTION00541300000000000000">Conclusion</A>
</UL>
<LI><A NAME="tex2html2609"
 HREF="node24.html#SECTION00542000000000000000">Builtin Support for Strings</A>
<LI><A NAME="tex2html2610"
 HREF="node24.html#SECTION00543000000000000000">Quoted lists</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00540000000000000000"></A>
<A NAME="chapstring"></A><A NAME="2269"></A>
<BR>
The String Data Type
</H1>

<P>
In the Prolog community there have been ongoing discussions about the need
to have a special string data type.
The main argument against strings is that everything that can be done
with strings can as well be done with atoms or with lists, depending
on the application.
Nevertheless, in ECLiPSe it was decided to have the string data type, so that
users that are aware of the advantages and disadvantages of the
different data types can always choose the most appropriate one.
The system provides efficient builtins for converting from one data
type to another.

<P>

<H2><A NAME="SECTION00541000000000000000">
Choosing The Appropriate Data Type</A>
</H2>
Strings, atoms and character lists differ in space consumption and in
the time needed for performing operations on the data.

<P>

<H3><A NAME="SECTION00541100000000000000"></A>
<A NAME="2273"></A>
<BR>
Strings vs. Character Lists
</H3>
Let us first compare strings with character lists.
The space consumption of a string is always less than that of the corresponding
list. For long strings, it is asymptotically 16 times more compact.
Items of both types are allocated on the global stack, which means that
the space is reclaimed on failure and on garbage collection.

<P>
For the complexity of operations it must be kept in mind that the string type
is essentially an array representation, ie. every character in the string
can be immediately accessed via its index.
The list representation allows only sequential access.
The time complexity for extracting a substring when the position is given
is therefore only dependent on the size of the substring for strings,
while for lists it is also dependent on the position of the substring.
Comparing two strings is of the same order as comparing two lists, but
faster by a constant factor.
If a string is to be processed character by character, this is easier to
do using the list representation, since using strings involves keeping
index counters and calling the <A NAME="tex2html196"
 HREF="../bips/kernel/stratom/string_code-3.html">string_code/3</A><A NAME="2381"></A> predicate.

<P>
The higher memory consumption of lists is sometimes compensated by the
property that when two lists are concatenated, only the first one needs
to be copied, while the list that makes up the tail of the concatenated
list can be shared.
When two string are concatenated, both strings must be copied to form
the new one.

<P>

<H3><A NAME="SECTION00541200000000000000"></A>
<A NAME="2277"></A>
<BR>
Strings vs. Atoms
</H3>
At a first glance, an atom does not look too different from a string.
In ECLiPSe, many predicates accept both strings and atoms (e.g. the file name
in open/3) and some predicates are provided in two versions, one for
atoms and one for strings (e.g. concat_atoms/3 and concat_strings/3).

<P>
However, internally these data types are quite different.
While a string is simply stored as a character sequence, an atom is mapped
into an internal constant.
This mapping is done via a table called the <EM>dictionary</EM>.
A consequence of this representation is that copying and comparing atoms
is a unit time operation, 
while for strings both is proportional to the string length.
On the other hand, each time an atom is read into the system, it has to
be looked up and possibly entered into the dictionary, which implies
some overhead.
The dictionary is a much less dynamic memory area than the global stack.
That means that once an atom has been entered there, this space will
only be reclaimed by a relatively expensive dictionary garbage collection.
It is therefore in general not a good idea to have a
program creating new atoms dynamically at runtime.

<P>
Atoms should always be preferred when they are involved in unification
and matching. As opposed to strings, they can be used for <EM>indexing</EM>
clauses of predicates.
Consider the following example:
<PRE>
[eclipse 1]: [user].
 afather(mary, george).
 afather(john, george).
 afather(sue, harry).
 afather(george, edward).

 sfather("mary", "george").
 sfather("john", "george").
 sfather("sue", "harry").
 sfather("george", "edward").
user   compiled 676 bytes in 0.00 seconds

yes.
[eclipse 2]: afather(sue,X).

X = harry
yes.
[eclipse 3]: sfather("sue",X).

X = "harry"     More? (;)

no (more) solution.
</PRE>
<A NAME="2283"></A>
The predicate with atoms is <EM>indexed</EM>, that means that the matching
clause is directly selected and the <EM>determinacy</EM> of the call is recognised
(the system does not prompt for more solutions).
When the names are instead written as strings, the system attempts
to unify the call with the first clause, then the second and so on until
a match is found. This is much slower than the indexed access.
Moreover the call leaves a choicepoint behind (as shown by the more-prompt).

<P>

<H3><A NAME="SECTION00541300000000000000">
Conclusion</A>
</H3>
Atoms should be used for representing (naming) the items that a
program reasons about, much like enumeration constants in PASCAL.
If used like this, an atom is in fact <EM>indivisible</EM> and there should
be no need to ever consider the atom name as a sequence of characters.

<P>
When a program deals with text processing, it should choose between string
and list representation.
When there is a lot of
manipulation on the single character level, it is probably best to use
the character list representation, since this
makes it very easy to write recursive predicates walking through the text.

<P>
The string type can be viewed as being a compromise between atoms and lists.
It should be used when handling large amounts of input, when the extreme
flexibility of lists is not needed, when space is a problem or when
handling very temporary data.

<P>

<H2><A NAME="SECTION00542000000000000000">
Builtin Support for Strings</A>
</H2>
Most ECLiPSe builtins that deliver text objects (like
<A NAME="tex2html200"
 HREF="../bips/kernel/opsys/getcwd-1.html">getcwd/1</A><A NAME="2384"></A>,
<A NAME="tex2html202"
 HREF="../bips/kernel/iochar/read_string-3.html">read_string/3,4</A><A NAME="2387"></A> and many others) return strings.
Strings can be created and their contents may be read using the string
stream feature (cf. section <A HREF="node62.html#stringio">10.3.1</A>).
By means of the builtins
<A NAME="tex2html204"
 HREF="../bips/kernel/stratom/atom_string-2.html">atom_string/2</A><A NAME="2390"></A>,
<A NAME="tex2html206"
 HREF="../bips/kernel/stratom/string_list-2.html">string_list/2</A><A NAME="2393"></A>,
<A NAME="tex2html208"
 HREF="../bips/kernel/stratom/number_string-2.html">number_string/2</A><A NAME="2396"></A> and
<A NAME="tex2html210"
 HREF="../bips/kernel/termmanip/term_string-2.html">term_string/2</A><A NAME="2399"></A>,
strings can easily be converted to other data types.

<P>

<H2><A NAME="SECTION00543000000000000000">
Quoted lists</A>
</H2>

<P>
As already discussed, many Prologs use the double quotes as a notation for
lists of characters. By default, ECLiPSe does not provide any
syntactical support for such quoted lists. However, the  user can
manipulate the quotes by means of the <A NAME="tex2html212"
 HREF="../bips/kernel/syntax/set_chtab-2.html">set_chtab/2</A><A NAME="2402"></A>
predicate.
A quote is defined by setting the character class of the chosen character
to <TT>string_quote</TT>, <TT>list_quote</TT> or <TT>atom_quote</TT> respectively.
To create a list quote (which is not available by default)
one may use:
<PRE>
[eclipse 1]: set_chtab(0'`, list_quote).

yes.
[eclipse 2]: X = `text`, Y = "text", type_of(X, TX), type_of(Y, TY).

X = [116, 101, 120, 116]
TX = compound
Y = "text"
TY = string
yes.
</PRE>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html2603"
 HREF="node25.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2599"
 HREF="node20.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2593"
 HREF="node23.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2601"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2604"
 HREF="node25.html">Matching Clauses</A>
<B> Up:</B> <A NAME="tex2html2600"
 HREF="node20.html">ECLiPSe-specific Language Features</A>
<B> Previous:</B> <A NAME="tex2html2594"
 HREF="node23.html">Array Notation</A>
 &nbsp <B>  <A NAME="tex2html2602"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
