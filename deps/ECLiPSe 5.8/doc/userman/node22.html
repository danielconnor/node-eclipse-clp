<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Loop/Iterator Constructs</TITLE>
<META NAME="description" CONTENT="Loop/Iterator Constructs">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node23.html">
<LINK REL="previous" HREF="node21.html">
<LINK REL="up" HREF="node20.html">
<LINK REL="next" HREF="node23.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html2577"
 HREF="node23.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2573"
 HREF="node20.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2567"
 HREF="node21.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2575"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2578"
 HREF="node23.html">Array Notation</A>
<B> Up:</B> <A NAME="tex2html2574"
 HREF="node20.html">ECLiPSe-specific Language Features</A>
<B> Previous:</B> <A NAME="tex2html2568"
 HREF="node21.html">Structure Notation</A>
 &nbsp <B>  <A NAME="tex2html2576"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html2579"
 HREF="node22.html#SECTION00521000000000000000">Examples</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00520000000000000000"></A>
<A NAME="doloops"></A><A NAME="2063"></A>
<A NAME="2064"></A>
<BR>
Loop/Iterator Constructs
</H1>
Many types of simple iterations are inconvenient to write in the
form of recursive predicates. ECLiPSe therefore provides a logical
iteration construct
<A NAME="tex2html166"
 HREF="../bips/kernel/control/do-2.html">do/2</A><A NAME="2360"></A>,
which can be understood either by itself
or by its translation to an equivalent recursion.

<P>
A simple example is the traversal of a list<PRE>
main :-
        write_list([1,2,3]).

    write_list([]).
    write_list([X|Xs]) :-
        writeln(X),
        write_list(Xs).
</PRE>
which can be written as follows without the need for an auxiliary predicate:<PRE>
main :-
        ( foreach(X, [1,2,3]) do
            writeln(X)
        ).
</PRE>
This looks very much like a loop in a procedural language. However,
due to the relational nature of logic programming, the same <B>foreach</B>-
construct can be used not only to control iteration over an existing list, 
but also to build a new list during an iteration. For example<PRE>
main :-
        ( foreach(X, [1,2,3]), foreach(Y, Negatives) do
            Y is -X
        ),
        writeln(Negatives).
</PRE>
will print [-1, -2, -3].

<P>
The general form of a do-loop is
<BLOCKQUOTE>
( IterationSpecs <B>do</B> Goals )

</BLOCKQUOTE>
and it corresponds to a call to an auxiliary recursive
predicate of the form<PRE>
    do__n(...).
    do__n(...) :- Goals, do__n(...).
</PRE>

<P>
The IterationSpecs determine the number of times the loop is executed
(i.e. the termination condition), and the way information is passed
into the loop, from one iteration to the next, and out of the loop.

<P>
IterationSpecs is one (or a comma-separated sequence) of the following:

<P>
<DL>
<DT><STRONG>fromto(First,In,Out,Last)</STRONG>
<DD> 
<BR>
<A NAME="2089"></A>
    iterate Goals starting with In=First until Out=Last.
    In and Out are local variables in Goals. For all but the first
    iteration, the value of In is the same as the value of Out in the
    previous iteration.

<P>
<DT><STRONG>foreach(X,List)</STRONG>
<DD> 
<BR>
<A NAME="2090"></A>
    iterate Goals with X ranging over all elements of List.
    X is a local variable in Goals.
    Can also be used for constructing a list.

<P>
<DT><STRONG>foreacharg(X,Struct)</STRONG>
<DD> 
<BR>
<A NAME="2091"></A>
    iterate Goals with X ranging over all elements of Struct.
    X is a local variable in Goals.
    Cannot be used for constructing a term.

<P>
<DT><STRONG>foreacharg(X,Struct,Idx)</STRONG>
<DD> 
<BR>
same as before, but Idx is set to the argument position of X in Struct,
    i.e. <code>arg(Idx, Struct, X)</code> is true.
    Idx is a local variable in Goals.

<P>
<DT><STRONG>foreachelem(X,Array)</STRONG>
<DD> 
<BR>
<A NAME="2092"></A>
    like foreacharg/2, but iterates over all elements of an array
    of arbitrary dimension.  The order is the natural order, i.e.     if <code>Array = []([](a, b, c), [](d, e, f))</code>, then for successive
    iterations X is bound in turn to a, b, c, d, e and f.
    X is a local variable in Goals.
    Cannot be used for constructing a term.

<P>
<DT><STRONG>foreachelem(X,Array,Idx)</STRONG>
<DD> 
<BR>
same as before, but Idx is set to the index position of X in
    Array, i.e. <code>subscript(Array, Idx, X)</code> is true.
    Idx is a local variable in Goals.

<P>
<DT><STRONG>foreachindex(Idx,Array)</STRONG>
<DD> 
<BR>
<A NAME="2093"></A>
    like foreachelem/3, but returns just the index position and not the
    element.

<P>
<DT><STRONG>for(I,MinExpr,MaxExpr)</STRONG>
<DD> 
<BR>
<A NAME="2094"></A>
    iterate Goals with I ranging over integers from MinExpr to MaxExpr.
    I is a local variable in Goals.
    MinExpr and MaxExpr can be arithmetic expressions.
    Can be used only for controlling iteration, i.e. MaxExpr cannot
    be uninstantiated.

<P>
<DT><STRONG>for(I,MinExpr,MaxExpr,Increment)</STRONG>
<DD> 
<BR>
same as before, but Increment can be specified (it defaults to 1).

<P>
<DT><STRONG>multifor(List,MinList,MaxList)</STRONG>
<DD> 
<BR>
<A NAME="2095"></A>
    like for/3, but allows iteration over multiple indices (saves
    writing nested loops).  Each element of List takes a value
    between the corresponding elements in MinList and MaxList.
    Successive iterations go through the possible combinations of
    values for List in lexicographic order.  List is a local
    variable in Goals.  MinList and MaxList must be either lists of
    arithmetic expressions evaluating to integers, or arithmetic
    expressions evaluating to integers (in the latter case they are
    treated as lists containing the (evaluated) integer repeated an
    appropriate number of times).  At least one of List, MinList and
    MaxList must be a list of fixed length at call time so that it is
    known how many indices are to be iterated.

<P>
<DT><STRONG>multifor(List,MinList,MaxList,IncrementList)</STRONG>
<DD> 
<BR>
same as before, but IncrementList can be specified (i.e. how
    much to increment each element of List by).  IncrementList must be
    either a list of arithmetic expressions evaluating to non-zero
    integers, or an arithmetic expression evaluating to a non-zero
    integer (in which case all elements are incremented by this
    amount).  IncrementList defaults to 1.

<P>
<DT><STRONG>count(I,Min,Max)</STRONG>
<DD> 
<BR>
<A NAME="2096"></A>
    iterate Goals with I ranging over integers from Min up to Max.
    I is a local variable in Goals.
    Can be used for controlling iteration as well as counting,
    i.e. Max can be a variable.

<P>
<DT><STRONG>param(Var1,Var2,...)</STRONG>
<DD> 
<BR>
<A NAME="2097"></A>
    for declaring variables in Goals global, ie shared with the context.
    CAUTION: By default, variables in Goals are local!
</DL>

<P>
Note that fromto/4 is the most general specifier (subsuming the
functionality of all the others), but foreach/2, foreacharg/2,3,
foreachelem/2,3, foreachindex/2, count/3, for/3,4, multifor/3,4 and
param/N are convenient shorthands.

<P>
More than one iteration specifier can be given in one do-loop,
and the order in which they are written does not matter.
In the case of several iteration specifiers, typically not all
of them will impose a termination condition on the loop
(e.g. <B>foreach</B> with an uninstantiated list, or <B>count</B>
with an uninstantiated maximum do not impose a termination condition),
but at least one of them should do so. If several specifiers
impose termination conditions, these conditions must coincide,
i.e. specify the same number of iterations.

<P>
Syntactically, the do-operator binds like the semicolon, i.e. less than comma.
That means that the whole do-construct should always be enclosed in
parentheses (see examples).

<P>
Unless you use :-pragma(noexpand) or :-dbgcomp, the do-construct is
compiled into an efficient auxiliary predicate named do__nnn, where
nnn is a unique integer. This will be visible during debugging.
To make debugging easier, it is possible to give the loop a
user-defined name by adding <B>loop_name(Name)</B>
<A NAME="2102"></A>
to the iteration specifiers.  Name must be an atom, and is used as the
name of the auxiliary predicate into which the loop is compiled
(instead of do__nnn).  The name should therefore not clash with other
predicate names in the same module.

<P>

<H2><A NAME="SECTION00521000000000000000">
Examples</A>
</H2>

<P>
Iterate over list<PRE>
foreach(X,[1,2,3]) do writeln(X).
</PRE>

<P>
Maplist (construct a new list from an existing list)<PRE>
(foreach(X,[1,2,3]), foreach(Y,List) do Y is X+3).
</PRE>

<P>
Sumlist<PRE>
(foreach(X,[1,2,3]), fromto(0,In,Out,Sum) do Out is In+X).
</PRE>

<P>
Reverse list<PRE>
(foreach(X,[1,2,3]), fromto([],In,Out,   Rev) do Out=[X|In]). % or:
(foreach(X,[1,2,3]), fromto([],In,[X|In],Rev) do true).
</PRE>

<P>
Iterate over integers from 1 up to 5<PRE>
for(I,1,5) do writeln(I). % or:
count(I,1,5) do writeln(I).
</PRE>

<P>
Iterate over integers from 5 down to 1<PRE>
(for(I,5,1,-1) do writeln(I)).
</PRE>

<P>
Make list of integers [1,2,3,4,5]<PRE>
(for(I,1,5), foreach(I,List) do true). % or:
(count(I,1,5), foreach(I,List) do true).
</PRE>

<P>
Make a list of length 3<PRE>
(foreach(_,List), for(_,1,3) do true). % or:
(foreach(_,List), count(_,1,3) do true).
</PRE>

<P>
Get the length of a list<PRE>
(foreach(_,[a,b,c]), count(_,1,N) do true).
</PRE>

<P>
Actually, the length/2 builtin is (almost)<PRE>
length(List, N) :- (foreach(_,List), count(_,1,N) do true).
</PRE>

<P>
Iterate [I,J] over [1,1], [1,2], [1,3], [2,1], ..., [3,3]:<PRE>
(multifor([I,J],1,3) do writeln([I,J])).
</PRE>

<P>
Similar, but have different start/stop values for I and J:<PRE>
(multifor([I,J], [2,1], [4,5]) do writeln([I,J])).
</PRE>

<P>
Similar, but only do odd values for the second variable:<PRE>
(multifor(List, [2,1], [4,5], [1,2]) do writeln(List)).
</PRE>

<P>
Filter list elements<PRE>
(foreach(X,[5,3,8,1,4,6]), fromto(List,Out,In,[]) do
    X&gt;3 -&gt; Out=[X|In] ; Out=In).
</PRE>

<P>
Iterate over structure arguments<PRE>
(foreacharg(X,s(a,b,c,d,e)) do writeln(X)).
</PRE>

<P>
Collect args in list
(bad example, use =.. if you really want to do that!)<PRE>
(foreacharg(X,s(a,b,c,d,e)), foreach(X,List) do true).
</PRE>

<P>
Collect args reverse<PRE>
(foreacharg(X,s(a,b,c,d,e)), fromto([],In,[X|In],List) do true).
</PRE>

<P>
or like this:<PRE>
S = s(a,b,c,d,e), functor(S, _, N),
(for(I,N,1,-1), foreach(A,List), param(S) do arg(I,S,A)).
</PRE>

<P>
Rotate args in a struct<PRE>
S0 = s(a,b,c,d,e), functor(S0, F, N), functor(S1, F, N),
(foreacharg(X,S0,I), param(S1, N) do I1 is (I mod N)+1, arg(I1,S1,X)).
</PRE>

<P>
Flatten an array into a list<PRE>
(foreachelem(X,[]([](5,1,2),[](3,3,2))), foreach(X,List) do true).
</PRE>

<P>
Transpose a 2D array<PRE>
A = []([](5,1,2),[](3,3,2)), dim(A, [R,C]), dim(T, [C,R]),
(foreachelem(X,A,[I,J]), param(T) do X is T[J,I]).
</PRE>

<P>
Same, using foreachindex<PRE>
A = []([](5,1,2),[](3,3,2)), dim(A, [R,C]), dim(T, [C,R]),
(foreachindex([I,J],A), param(A, T) do
    subscript(A, [I,J], X), subscript(T, [J,I], X)).
</PRE>

<P>
The following two are equivalent<PRE>
foreach(X,[1,2,3])        do             writeln(X).
fromto([1,2,3],In,Out,[]) do In=[X|Out], writeln(X).
</PRE>

<P>
The following two are equivalent<PRE>
count(I,1,5)     do            writeln(I).
fromto(0,I0,I,5) do I is I0+1, writeln(I).
</PRE>

<P>
Some examples for nested loops. Print all pairs of list elements:<PRE>
Xs = [1,2,3,4],
( foreach(X, Xs), param(Xs) do
    ( foreach(Y,Xs), param(X) do
        writeln(X-Y)
    )
).
</PRE>
and the same without symmetries:<PRE>
Xs = [1,2,3,4],
( fromto(Xs, [X|Xs1], Xs1, []) do
    ( foreach(Y,Xs1), param(X) do
        writeln(X-Y)
    )
).
</PRE>
Find all pairs of list elements and collect them in a result list:<PRE>
pairs(Xs, Ys, Zs) :-
    (
        foreach(X,Xs),
        fromto(Zs, Zs4, Zs1, []),
        param(Ys)
    do
        (
            foreach(Y,Ys),
            fromto(Zs4, Zs3, Zs2, Zs1),
            param(X)
        do
            Zs3 = [X-Y|Zs2]
        )
    ).
</PRE>

<P>
Flatten a 2-dimensional matrix into a list:<PRE>
flatten_matrix(Mat, Xs) :-
    dim(Mat, [M,N]),
    (
        for(I,1,M),
        fromto(Xs, Xs4, Xs1, []),
        param(Mat,N)
    do
        (
            for(J,1,N),
            fromto(Xs4, [X|Xs2], Xs2, Xs1),
            param(Mat,I)
        do
            subscript(Mat, [I,J], X)
        )
    ).
</PRE>

<P>
Same using multifor to avoid nesting:<PRE>
flatten_matrix(Mat, Xs) :-
    dim(Mat, [M,N]),
    (
        multifor([I,J], 1, [M,N]),
        foreach(X, Xs),
        param(Mat)
    do
        subscript(Mat, [I,J], X)
    ).
</PRE>

<P>
Same for an array of arbitrary dimension:<PRE>
flatten_array(Array, Xs) :-
    dim(Array, Dims),
    (
        multifor(Idx, 1, Dims),
        foreach(X, Xs),
        param(Array)
    do
        subscript(Array, Idx, X)
    ).
</PRE>

<P>
Same but returns the elements in the reverse order:<PRE>
flatten_array(Array, Xs) :-
    dim(Array, Dims),
    (
        multifor(Idx, Dims, 1, -1),
        foreach(X, Xs),
        param(Array)
    do
        subscript(Array, Idx, X)
    ).
</PRE>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html2577"
 HREF="node23.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2573"
 HREF="node20.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2567"
 HREF="node21.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2575"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2578"
 HREF="node23.html">Array Notation</A>
<B> Up:</B> <A NAME="tex2html2574"
 HREF="node20.html">ECLiPSe-specific Language Features</A>
<B> Previous:</B> <A NAME="tex2html2568"
 HREF="node21.html">Structure Notation</A>
 &nbsp <B>  <A NAME="tex2html2576"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
