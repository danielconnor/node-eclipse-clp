<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.2 beta5 (July 28th, 1998)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Writing Efficient Code</TITLE>
<META NAME="description" CONTENT="Writing Efficient Code">
<META NAME="keywords" CONTENT="umsroot">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="umsroot.css">
<LINK REL="next" HREF="node37.html">
<LINK REL="previous" HREF="node35.html">
<LINK REL="up" HREF="node27.html">
<LINK REL="next" HREF="node37.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html2764"
 HREF="node37.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2760"
 HREF="node27.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2754"
 HREF="node35.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2762"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2765"
 HREF="node37.html">Compiling and loading object</A>
<B> Up:</B> <A NAME="tex2html2761"
 HREF="node27.html">The Compiler</A>
<B> Previous:</B> <A NAME="tex2html2755"
 HREF="node35.html">Compiler Pragmas</A>
 &nbsp <B>  <A NAME="tex2html2763"
 HREF="node158.html">Index</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00690000000000000000"></A>
<A NAME="secefficientcode"></A>
<BR>
Writing Efficient Code
</H1>
The ECLiPSe compiler tries its best, however there are some
constructs which can be compiled more efficiently than others.
On the other hand, many Prolog programmers overemphasize
the importance of efficient code and write completely unreadable
programs which can be only hardly maintained and which are only
marginally faster than simple, straightforward and readable
programs.
The advice is therefore <B>Try the simple and straightforward
solution first!</B>
The second rule is to keep this original program even if you try
to optimise it. You may find out that the optimisation
was not worth the effort.

<P>
To achieve the maximum speed of your programs, you must
produce the optimised code with the flag <TT>debug_compile</TT>
being off, e.g. 
by calling <B>set_flag(debug_compile, off)</B>,
or using the pragma <B>nodebug</B>.
Setting the flag <TT>variable_names</TT> can also cause slight
performance degradations and it is thus better to have
it off, unless variable names have to be kept.
Unlike in the previous releases, the flag <TT>coroutine</TT>
has now no influence on the execution speed.
Some programs spend a lot of time in the garbage collection,
collecting the stacks and/or the dictionary.
If the space is known to be deallocated anyway, e.g. on failure,
the programs can be often speeded up considerably
by switching the garbage collector off or by increasing
the <TT>gc_interval</TT> flag.
As the global stack expands automatically, this does not cause
any stack overflow, but it may of course exhaust the machine memory.

<P>
When the program is running and its speed is still
not satisfactory, use the profiling tools.
The profiler can tell you which predicates
are the most expensive ones, and the statistics tool
tells you why.
A program may spend its time in a predicate because the predicate
itself is very time consuming, or because it was frequently executed.
The statistics tool gives you this information.
It can also tell whether the predicate was slow because it
has created a choice point or because there was too much
backtracking due to bad indexing.

<P>
One of the very important points is the selection
of the clause that matches the current call.
If there is only one clause that can potentially match,
the compiler is expected to recognise this and generate code
that will directly execute the right clause
instead of trying several subsequent clauses until the
matching one is found.
Unlike most of the current Prolog compilers, the ECLiPSe
compiler tries to base this selection (<I>indexing</I>) on the most suitable
argument of the predicate<A NAME="tex2html311"
 HREF="footnode.html#foot2918"><SUP>6.4</SUP></A>.
It is therefore not necessary to reorder the predicate
arguments so that the first one is the crucial argument
for indexing.
However, the decision is still based only on one argument.
If it is necessary to look at two arguments
in order to select the matching clause, e.g. in<PRE>
p(a, a) :- a.
p(b, a) :- b.
p(a, b) :- c.
p(d, b) :- d.
p(b, c) :- e.
</PRE>
and if it is crucial that this procedure is executed
as fast as possible, it is necessary to define
an auxiliary procedure which can be indexed on the other argument:<PRE>
p(X, a) :- pa(X).
p(X, b) :- pb(X).
p(b, c) :- e.

pa(a) :- a. pa(b) :- b.

pb(a) :- c. pb(d) :- d.
</PRE>

<P>
The compiler also tries to use for indexing all type-testing information
that appears at the beginning of the clause body:

<UL><LI>Type testing predicates <A NAME="tex2html312"
 HREF="../bips/kernel/typetest/free-1.html">free/1</A><A NAME="3211"></A>, <A NAME="tex2html314"
 HREF="../bips/kernel/typetest/var-1.html">var/1</A><A NAME="3214"></A>, <A NAME="tex2html316"
 HREF="../bips/kernel/typetest/meta-1.html">meta/1</A><A NAME="3217"></A>,
<A NAME="tex2html318"
 HREF="../bips/kernel/typetest/atom-1.html">atom/1</A><A NAME="3220"></A>, <A NAME="tex2html320"
 HREF="../bips/kernel/typetest/integer-1.html">integer/1</A><A NAME="3223"></A>,
<A NAME="tex2html322"
 HREF="../bips/kernel/typetest/rational-1.html">rational/1</A><A NAME="3226"></A>,
<A NAME="tex2html324"
 HREF="../bips/kernel/typetest/float-1.html">float/1</A><A NAME="3229"></A>,
<A NAME="tex2html326"
 HREF="../bips/kernel/typetest/breal-1.html">breal/1</A><A NAME="3232"></A>,
<A NAME="tex2html328"
 HREF="../bips/kernel/typetest/real-1.html">real/1</A><A NAME="3235"></A>,
<A NAME="tex2html330"
 HREF="../bips/kernel/typetest/number-1.html">number/1</A><A NAME="3238"></A>,
<A NAME="tex2html332"
 HREF="../bips/kernel/typetest/string-1.html">string/1</A><A NAME="3241"></A>, <A NAME="tex2html334"
 HREF="../bips/kernel/typetest/atomic-1.html">atomic/1</A><A NAME="3244"></A>, <A NAME="tex2html336"
 HREF="../bips/kernel/typetest/compound-1.html">compound/1</A><A NAME="3247"></A>, <A NAME="tex2html338"
 HREF="../bips/kernel/typetest/nonvar-1.html">nonvar/1</A><A NAME="3250"></A> and
<A NAME="tex2html340"
 HREF="../bips/kernel/typetest/nonground-1.html">nonground/1</A><A NAME="3253"></A>.

<P>

<LI>Explicit unification and value testing
<A NAME="tex2html342"
 HREF="../bips/kernel/termcomp/E-2.html">=/2</A><A NAME="3256"></A>, <A NAME="tex2html344"
 HREF="../bips/kernel/termcomp/EE-2.html">==/2</A><A NAME="3259"></A>, 

<P>
<A NAME="tex2html346"
 HREF="../bips/kernel/termcomp/REE-2.html"><code>\==</code>/2</A><A NAME="3262"></A>
and <A NAME="tex2html348"
 HREF="../bips/kernel/termcomp/RE-2.html"><code>\=</code>/2</A><A NAME="3265"></A>.

<P>

<LI>Combinations of tests with <A NAME="tex2html350"
 HREF="../bips/kernel/control/C-2.html">,/2</A><A NAME="3268"></A>, <A NAME="tex2html352"
 HREF="../bips/kernel/control/O-2.html">;/2</A><A NAME="3271"></A>,
<A NAME="tex2html354"
 HREF="../bips/kernel/control/not-1.html">not/1</A><A NAME="3274"></A>, <A NAME="tex2html356"
 HREF="../bips/kernel/control/-G-2.html">-&gt;/2</A><A NAME="3277"></A>.

<P>

<LI>Arithmetic testing predicates
<A NAME="tex2html358"
 HREF="../bips/kernel/arithmetic/L-2.html">&lt;/2</A><A NAME="3280"></A>,
<A NAME="tex2html360"
 HREF="../bips/kernel/arithmetic/EL-2.html">=&lt;/2</A><A NAME="3283"></A>,
<A NAME="tex2html362"
 HREF="../bips/kernel/arithmetic/G-2.html">&gt;/2</A><A NAME="3286"></A>,
<A NAME="tex2html364"
 HREF="../bips/kernel/arithmetic/GE-2.html">&gt;=/2</A><A NAME="3289"></A> if one argument is an integer constant and the
other one known to be of the integer type.

<P>

<LI>A cut after the type tests.

</UL>

<P>
If the compiler can decide about the clause selection at compile time,
the type tests are never executed and thus they incur no overhead.
When the clauses are not disjoint because of the type tests, either a cut
after the test or more tests into the other clauses can be added.
For example, the following procedure will be recognised as deterministic
and all tests are optimised away:

<P>
<PRE>
 % a procedure without cuts
p(X) :- var(X), ...
    p(X) :- (atom(X); integer(X)), X \= [], ...
    p(X) :- nonvar(X), X = [_|_], ...
    p(X) :- nonvar(X), X = [], ...
</PRE>

<P>
Another example:
<PRE>
 % A procedure with cuts
p(X{_}) ?- !, ...
    p(X) :- var(X), !, ...
    p(X) :- integer(X), ...
    p(X) :- real(X), ...
    p([H|T]) :- ...
    p([]) :- ...
</PRE>

<P>
Integers less than or greater than a constant can also be
recognised by the compiler:
<PRE>
    p(X) :- integer(X), X &lt; 5, ...
    p(7) :- ...
    p(9) :- ...
    p(X) :- integer(X), X &gt;= 15, ...
</PRE>

<P>
If the clause contains tests of several head arguments, only the
first one is taken into account for indexing.

<P>
Here are some more hints for efficient coding with ECLiPSe:

<UL><LI>Arguments which are repeated in the clause head and in the first
regular goal in the body do not require any data moving and thus
they do not cost anything. For example,<PRE>
p(X, Y, Z, T, U) :- q(X, Y, Z, T, U).
</PRE>
is as expensive as<PRE>
p :- q.
</PRE>
On the other hand, switching arguments requires data moves and so<PRE>
p(A, B, C) :- q(B, C, A).
</PRE>
is significantly more expensive.

<P>

<LI>When accessing an argument of a
structure whose functor is known, unification
is better than <A NAME="tex2html366"
 HREF="../bips/kernel/termmanip/arg-3.html">arg/3</A><A NAME="3292"></A>.
Note, however, that for better maintainability the <B>structure
notation</B> (see section&nbsp;<A HREF="node21.html#chapstruct">5.1</A>)
should be used to define the structures.
<A NAME="3017"></A>

<P>

<LI>Tests are generally rather slow unless they can be compiled away
(see <I>indexing</I>).

<LI>When processing all arguments of a structure, using <A NAME="tex2html369"
 HREF="../bips/kernel/termmanip/EDD-2.html">=../2</A><A NAME="3295"></A>
and list predicates is always faster, more readable
and easier analyzable by automated tools than using <A NAME="tex2html371"
 HREF="../bips/kernel/termmanip/functor-3.html">functor/3</A><A NAME="3298"></A>
and <A NAME="tex2html373"
 HREF="../bips/kernel/termmanip/arg-3.html">arg/3</A><A NAME="3301"></A> loops.

<P>

<LI>Similarly, when adding one new element to a structure, using <B>=../2</B>
and <A NAME="tex2html375"
 HREF="../bips/lib/lists/append-3.html">append/3</A><A NAME="3304"></A> is faster than functor/arg.

<P>

<LI>Waking is less expensive than metacalling and more expensive
than direct calling.
Metacalls, although generally slow, are still a lot faster than
in some other Prolog systems.

<P>

<LI>Sorting using <A NAME="tex2html377"
 HREF="../bips/kernel/termcomp/sort-2.html">sort/2</A><A NAME="3307"></A> is very efficient and it does not use
much space.
Using <A NAME="tex2html379"
 HREF="../bips/kernel/allsols/setof-3.html">setof/3</A><A NAME="3310"></A>, <A NAME="tex2html381"
 HREF="../bips/kernel/allsols/findall-3.html">findall/3</A><A NAME="3313"></A> etc. is also efficient enough
to be used every time a list of all solutions is needed.

<P>

<LI>using <B>not not Goal</B> is optimised in the compiler
to use only one choice point.

<P>

<LI><A NAME="tex2html383"
 HREF="../bips/kernel/termcomp/E-2.html">=/2</A><A NAME="3316"></A>, when expanded by the compiler, is faster than <A NAME="tex2html385"
 HREF="../bips/kernel/termcomp/EE-2.html">==/2</A><A NAME="3319"></A>
or <A NAME="tex2html387"
 HREF="../bips/kernel/arithmetic/ENE-2.html">=:=/2</A><A NAME="3322"></A>.

<P>

<LI><A NAME="tex2html389"
 HREF="../bips/kernel/control/N-2.html">:/2</A><A NAME="3325"></A> is optimised away by the compiler
if both argument are known.

<P>

<LI>Using several clauses is much more efficient than using
a disjunction if the clause heads contain nonvariables
which can be used for indexing.
If no indexing can be made anyway, using a disjunction
is slightly faster.

<P>

<LI>Conditionals with <B>-&gt; ;</B> are compiled more efficiently
if the condition is a simple built-in test.
However, using several clauses can be faster if the compiler
optimises the test away.

<P>

</UL>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html2764"
 HREF="node37.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2760"
 HREF="node27.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2754"
 HREF="node35.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>  
<A NAME="tex2html2762"
 HREF="node158.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2765"
 HREF="node37.html">Compiling and loading object</A>
<B> Up:</B> <A NAME="tex2html2761"
 HREF="node27.html">The Compiler</A>
<B> Previous:</B> <A NAME="tex2html2755"
 HREF="node35.html">Compiler Pragmas</A>
 &nbsp <B>  <A NAME="tex2html2763"
 HREF="node158.html">Index</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Warwick Harvey</I>
<BR><I>2005-01-25</I>
</ADDRESS>
</BODY>
</HTML>
