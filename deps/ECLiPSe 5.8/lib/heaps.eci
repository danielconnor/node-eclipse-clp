:- module(heaps).
:- export min_of_heap / 5.
:- export min_of_heap / 3.
:- export list_to_heap / 2.
:- export heap_to_list / 2.
:- export heap_size / 2.
:- export get_from_heap / 4.
:- export add_to_heap / 4.
:- comment(summary, "Implement heaps in Prolog").
:- comment(author, "R.A.O'Keefe").
:- comment(date, "29 November 1983").
:- comment(desc, html("<P>\n    A heap is a labelled binary tree where the key of each node is less\n    than or equal to the keys of its sons.  The point of a heap is that\n    we can keep on adding new elements to the heap and we can keep on\n    taking out the minimum element.  If there are N elements total, the\n    total time is O(NlgN).  If you know all the elements in advance, you\n    are better off doing a merge-sort, but this file is for when you\n    want to do say a best-first search, and have no idea when you start\n    how many elements there will be, let alone what they are.\n</P><P>\n    A heap is represented as a triple t(N, Free, Tree) where N is the\n    number of elements in the tree, Free is a list of integers which\n    specifies unused positions in the tree, and Tree is a tree made of\n<PRE>\n\tt\t\t\tterms for empty subtrees and\n\tt(Key,Datum,Lson,Rson)\tterms for the rest\n</PRE>\n    The nodes of the tree are notionally numbered like this:\n<PRE>\n\t\t\t\t    1\n\t\t     2\t\t\t\t    3\n             4               6               5               7\n         8      12      10     14       9       13      11     15\n      ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\n</PRE>\n    The idea is that if the maximum number of elements that have been in\n    the heap so far is M, and the tree currently has K elements, the tree\n    is some subtreee of the tree of this form having exactly M elements,\n    and the Free list is a list of K-M integers saying which of the \n    positions in the M-element tree are currently unoccupied.  This free\n    list is needed to ensure that the cost of passing N elements through\n    the heap is O(NlgM) instead of O(NlgN).  For M say 100 and N say 10^4\n    this means a factor of two.  The cost of the free list is slight.\n    The storage cost of a heap in a copying Prolog (which Dec-10 Prolog is\n    not) is 2K+3M words.\n</P>\n")).
:- comment(add_to_heap / 4, [summary : "inserts the new Key-Datum pair into the heap", template : "add_to_heap(+OldHeap, +Key, +Datum, -NewHeap)", desc : html("\n    inserts the new Key-Datum pair into the heap.  The insertion is\n    not stable, that is, if you insert several pairs with the same\n    Key it is not defined which of them will come out first, and it\n    is possible for any of them to come out first depending on the \n    history of the heap.  If you need a stable heap, you could add\n    a counter to the heap and include the counter at the time of\n    insertion in the key.  If the free list is empty, the tree will\n    be grown, otherwise one of the empty slots will be re-used.  (I\n    use imperative programming language, but the heap code is as \n    pure as the trees code, you can create any number of variants\n    starting from the same heap, and they will share what common\n    structure they can without interfering with each other.)\n    ")]).
:- comment(get_from_heap / 4, [summary : "returns the Key-Datum pair in OldHeap with the smallest Key", template : "get_from_heap(+OldHeap, ?Key, ?Datum, -NewHeap)", desc : html("\n    returns the Key-Datum pair in OldHeap with the smallest Key, and\n    also a New Heap which is the Old Heap with that pair deleted.\n    The easy part is picking off the smallest element.  The hard part\n    is repairing the heap structure.  repair_heap/4 takes a pair of\n    heaps and returns a new heap built from their elements, and the\n    position number of the gap in the new tree.  Note that repair_heap\n    is *not* tail-recursive.\n    ")]).
:- comment(heap_size / 2, [summary : "reports the number of elements currently in the heap", template : "heap_size(+Heap, ?Size)"]).
:- comment(heap_to_list / 2, [summary : "returns the current set of Key-Datum pairs in the Heap as a List.", template : "heap_to_list(+Heap, -List)", desc : html("\n    returns the current set of Key-Datum pairs in the Heap as a\n    List, sorted into ascending order of Keys.  This is included\n    simply because I think every data structure foo ought to have\n    a foo_to_list and list_to_foo relation (where, of course, it\n    makes sense!) so that conversion between arbitrary data\n    structures is as easy as possible.  This predicate is basically\n    just a merge sort, where we can exploit the fact that the tops\n    of the subtrees are smaller than their descendants.\n    ")]).
:- comment(list_to_heap / 2, [summary : "takes a list of Key-Datum pairs and forms them into a heap", template : "list_to_heap(+List, -Heap)", desc : html("\n    takes a list of Key-Datum pairs (such as keysort could be used to\n    sort) and forms them into a heap.  We could do that a wee bit\n    faster by keysorting the list and building the tree directly, but\n    this algorithm makes it obvious that the result is a heap, and\n    could be adapted for use when the ordering predicate is not @<\n    and hence keysort is inapplicable.\n    ")]).
:- comment(min_of_heap / 3, [summary : "returns the Key-Datum pair at the top of the heap", template : "min_of_heap(+Heap, ?Key, ?Datum)", desc : html("\n    returns the Key-Datum pair at the top of the heap (which is of\n    course the pair with the smallest Key), but does not remove it\n    from the heap.  It fails if the heap is empty.\n    ")]).
:- comment(min_of_heap / 5, [summary : "returns the smallest and second smallest pairs in the heap", template : "min_of_heap(+Heap, ?Key1, ?Datum1, ?Key2, ?Datum2)", desc : html("\n    returns the smallest (Key1) and second smallest (Key2) pairs in\n    the heap, without deleting them.  It fails if the heap does not\n    have at least two elements.\n    ")]).
